var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Blender addon","text":"<p>Blender integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_blender<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>capture</li> <li>colorspace</li> <li>lib</li> <li>ops</li> <li>pipeline</li> <li>plugin</li> <li>render_lib</li> <li>workio</li> </ul> </li> <li>blender_addon<ul> <li>startup<ul> <li>init</li> </ul> </li> </ul> </li> <li>hooks<ul> <li>pre_add_run_python_script_arg</li> <li>pre_pyside_install</li> <li>pre_windows_console</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>convert_legacy</li> <li>create_action</li> <li>create_animation</li> <li>create_blendScene</li> <li>create_camera</li> <li>create_layout</li> <li>create_model</li> <li>create_pointcache</li> <li>create_render</li> <li>create_review</li> <li>create_rig</li> <li>create_usd</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>import_workfile</li> <li>load_action</li> <li>load_animation</li> <li>load_audio</li> <li>load_blend</li> <li>load_blendscene</li> <li>load_cache</li> <li>load_camera_abc</li> <li>load_camera_fbx</li> <li>load_fbx</li> <li>load_image_compositor</li> <li>load_image_shader</li> <li>load_layout_json</li> <li>load_look</li> </ul> </li> <li>publish<ul> <li>collect_current_file</li> <li>collect_file_dependencies</li> <li>collect_instance</li> <li>collect_instance_frame_range</li> <li>collect_render</li> <li>collect_review</li> <li>collect_workfile</li> <li>extract_abc</li> <li>extract_abc_animation</li> <li>extract_blend</li> <li>extract_blend_animation</li> <li>extract_camera_abc</li> <li>extract_camera_fbx</li> <li>extract_fbx</li> <li>extract_fbx_animation</li> <li>extract_layout</li> <li>extract_playblast</li> <li>extract_thumbnail</li> <li>extract_usd</li> <li>increment_workfile_version</li> <li>integrate_animation</li> <li>validate_absolute_external_data_paths</li> <li>validate_camera_zero_keyframe</li> <li>validate_deadline_publish</li> <li>validate_file_saved</li> <li>validate_frame_range</li> <li>validate_instance_empty</li> <li>validate_mesh_has_uv</li> <li>validate_mesh_no_negative_scale</li> <li>validate_model_uv_map1</li> <li>validate_no_colons_in_name</li> <li>validate_object_mode</li> <li>validate_render_camera_is_set</li> <li>validate_transform_zero</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>imageio</li> <li>main</li> <li>publish_plugins</li> <li>render_settings</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_blender/index.html","title":"ayon_blender","text":""},{"location":"autoapi/client/ayon_blender/index.html#client.ayon_blender.BlenderAddon","title":"<code>BlenderAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>class BlenderAddon(AYONAddon, IHostAddon):\n    name = \"blender\"\n    version = __version__\n    host_name = \"blender\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        # Prepare path to implementation script\n        implementation_script_path = os.path.join(\n            BLENDER_ADDON_ROOT,\n            \"blender_addon\"\n        )\n\n        # Add blender implementation script path to PYTHONPATH\n        python_path = env.get(\"PYTHONPATH\") or \"\"\n        python_path_parts = [\n            path\n            for path in python_path.split(os.pathsep)\n            if path\n        ]\n        python_path_parts.insert(0, implementation_script_path)\n        env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n        # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n        # to initialize the Blender startup environment, otherwise use the\n        # `BLENDER_USER_PATH`.\n        use_system_path = env_value_to_bool(\"AYON_BLENDER_USE_SYSTEM_PATH\")\n        if use_system_path:\n            self._configure_blender_system_paths(\n                env, implementation_script_path\n            )\n        else:\n            # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n            # nor supported multiple paths for it. See:\n            # https://projects.blender.org/blender/blender/issues/127013\n            self._configure_blender_user_paths(env, implementation_script_path)\n\n        # Define Qt binding if not defined\n        env.pop(\"QT_PREFERRED_BINDING\", None)\n\n    def _configure_blender_user_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_USER_SCRIPTS to configure AYON startup\"\"\"\n        previous_user_scripts = set()\n        # Implementation path is added to set for easier paths check inside\n        #   loops - will be removed at the end\n        previous_user_scripts.add(implementation_script_path)\n\n        ayon_blender_user_scripts = env.get(\"AYON_BLENDER_USER_SCRIPTS\") or \"\"\n        for path in ayon_blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        blender_user_scripts = env.get(\"BLENDER_USER_SCRIPTS\") or \"\"\n        for path in blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        # Remove implementation path from user script paths as is set to\n        #   `BLENDER_USER_SCRIPTS`\n        previous_user_scripts.remove(implementation_script_path)\n        env[\"BLENDER_USER_SCRIPTS\"] = implementation_script_path\n\n        # Set custom user scripts env\n        env[\"AYON_BLENDER_USER_SCRIPTS\"] = os.pathsep.join(\n            previous_user_scripts\n        )\n\n    def _configure_blender_system_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_SYSTEM_SCRIPTS to configure AYON startup.\n\n        This would only work with Blender 4.4+ due to new changes implemented\n        to `BLENDER_SYSTEM_SCRIPTS` functionality starting with that release.\n        \"\"\"\n        paths = [implementation_script_path]\n\n        # Support older AYON_BLENDER_USER_SCRIPTS for compatibility\n        if env.get(\"AYON_BLENDER_USER_SCRIPTS\"):\n            # Note that we `pop` the AYON_BLENDER_USER_SCRIPTS to avoid\n            # the legacy post-Blender launch logic script to trigger which\n            # is incompatible with Blender 4.4+\n            paths.append(env.pop(\"AYON_BLENDER_USER_SCRIPTS\"))\n\n        # Preserve existing BLENDER_SYSTEM_SCRIPTS, append them at the end\n        if env.get(\"BLENDER_SYSTEM_SCRIPTS\"):\n            paths.append(env.get(\"BLENDER_SYSTEM_SCRIPTS\"))\n\n        # Set custom user scripts env\n        env[\"BLENDER_SYSTEM_SCRIPTS\"] = os.pathsep.join(paths)\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(BLENDER_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/index.html#client.ayon_blender.BlenderAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    # Prepare path to implementation script\n    implementation_script_path = os.path.join(\n        BLENDER_ADDON_ROOT,\n        \"blender_addon\"\n    )\n\n    # Add blender implementation script path to PYTHONPATH\n    python_path = env.get(\"PYTHONPATH\") or \"\"\n    python_path_parts = [\n        path\n        for path in python_path.split(os.pathsep)\n        if path\n    ]\n    python_path_parts.insert(0, implementation_script_path)\n    env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n    # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n    # to initialize the Blender startup environment, otherwise use the\n    # `BLENDER_USER_PATH`.\n    use_system_path = env_value_to_bool(\"AYON_BLENDER_USE_SYSTEM_PATH\")\n    if use_system_path:\n        self._configure_blender_system_paths(\n            env, implementation_script_path\n        )\n    else:\n        # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n        # nor supported multiple paths for it. See:\n        # https://projects.blender.org/blender/blender/issues/127013\n        self._configure_blender_user_paths(env, implementation_script_path)\n\n    # Define Qt binding if not defined\n    env.pop(\"QT_PREFERRED_BINDING\", None)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_blender/addon.html#client.ayon_blender.addon.BlenderAddon","title":"<code>BlenderAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>class BlenderAddon(AYONAddon, IHostAddon):\n    name = \"blender\"\n    version = __version__\n    host_name = \"blender\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        # Prepare path to implementation script\n        implementation_script_path = os.path.join(\n            BLENDER_ADDON_ROOT,\n            \"blender_addon\"\n        )\n\n        # Add blender implementation script path to PYTHONPATH\n        python_path = env.get(\"PYTHONPATH\") or \"\"\n        python_path_parts = [\n            path\n            for path in python_path.split(os.pathsep)\n            if path\n        ]\n        python_path_parts.insert(0, implementation_script_path)\n        env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n        # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n        # to initialize the Blender startup environment, otherwise use the\n        # `BLENDER_USER_PATH`.\n        use_system_path = env_value_to_bool(\"AYON_BLENDER_USE_SYSTEM_PATH\")\n        if use_system_path:\n            self._configure_blender_system_paths(\n                env, implementation_script_path\n            )\n        else:\n            # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n            # nor supported multiple paths for it. See:\n            # https://projects.blender.org/blender/blender/issues/127013\n            self._configure_blender_user_paths(env, implementation_script_path)\n\n        # Define Qt binding if not defined\n        env.pop(\"QT_PREFERRED_BINDING\", None)\n\n    def _configure_blender_user_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_USER_SCRIPTS to configure AYON startup\"\"\"\n        previous_user_scripts = set()\n        # Implementation path is added to set for easier paths check inside\n        #   loops - will be removed at the end\n        previous_user_scripts.add(implementation_script_path)\n\n        ayon_blender_user_scripts = env.get(\"AYON_BLENDER_USER_SCRIPTS\") or \"\"\n        for path in ayon_blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        blender_user_scripts = env.get(\"BLENDER_USER_SCRIPTS\") or \"\"\n        for path in blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        # Remove implementation path from user script paths as is set to\n        #   `BLENDER_USER_SCRIPTS`\n        previous_user_scripts.remove(implementation_script_path)\n        env[\"BLENDER_USER_SCRIPTS\"] = implementation_script_path\n\n        # Set custom user scripts env\n        env[\"AYON_BLENDER_USER_SCRIPTS\"] = os.pathsep.join(\n            previous_user_scripts\n        )\n\n    def _configure_blender_system_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_SYSTEM_SCRIPTS to configure AYON startup.\n\n        This would only work with Blender 4.4+ due to new changes implemented\n        to `BLENDER_SYSTEM_SCRIPTS` functionality starting with that release.\n        \"\"\"\n        paths = [implementation_script_path]\n\n        # Support older AYON_BLENDER_USER_SCRIPTS for compatibility\n        if env.get(\"AYON_BLENDER_USER_SCRIPTS\"):\n            # Note that we `pop` the AYON_BLENDER_USER_SCRIPTS to avoid\n            # the legacy post-Blender launch logic script to trigger which\n            # is incompatible with Blender 4.4+\n            paths.append(env.pop(\"AYON_BLENDER_USER_SCRIPTS\"))\n\n        # Preserve existing BLENDER_SYSTEM_SCRIPTS, append them at the end\n        if env.get(\"BLENDER_SYSTEM_SCRIPTS\"):\n            paths.append(env.get(\"BLENDER_SYSTEM_SCRIPTS\"))\n\n        # Set custom user scripts env\n        env[\"BLENDER_SYSTEM_SCRIPTS\"] = os.pathsep.join(paths)\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(BLENDER_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/addon.html#client.ayon_blender.addon.BlenderAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    # Prepare path to implementation script\n    implementation_script_path = os.path.join(\n        BLENDER_ADDON_ROOT,\n        \"blender_addon\"\n    )\n\n    # Add blender implementation script path to PYTHONPATH\n    python_path = env.get(\"PYTHONPATH\") or \"\"\n    python_path_parts = [\n        path\n        for path in python_path.split(os.pathsep)\n        if path\n    ]\n    python_path_parts.insert(0, implementation_script_path)\n    env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n    # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n    # to initialize the Blender startup environment, otherwise use the\n    # `BLENDER_USER_PATH`.\n    use_system_path = env_value_to_bool(\"AYON_BLENDER_USE_SYSTEM_PATH\")\n    if use_system_path:\n        self._configure_blender_system_paths(\n            env, implementation_script_path\n        )\n    else:\n        # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n        # nor supported multiple paths for it. See:\n        # https://projects.blender.org/blender/blender/issues/127013\n        self._configure_blender_user_paths(env, implementation_script_path)\n\n    # Define Qt binding if not defined\n    env.pop(\"QT_PREFERRED_BINDING\", None)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/version.html","title":"version","text":"<p>Package declaring AYON addon 'blender' version.</p>"},{"location":"autoapi/client/ayon_blender/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost","title":"<code>BlenderHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>IPublishHost</code>, <code>ILoadHost</code></p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>class BlenderHost(HostBase, IWorkfileHost, IPublishHost, ILoadHost):\n    name = \"blender\"\n\n    def install(self):\n        \"\"\"Override install method from HostBase.\n        Install Blender host functionality.\"\"\"\n        install()\n\n    def get_containers(self) -&gt; Iterator:\n        \"\"\"List containers from active Blender scene.\"\"\"\n        return ls()\n\n    def get_workfile_extensions(self) -&gt; List[str]:\n        \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n        Get workfile possible extensions.\n\n        Returns:\n            List[str]: Workfile extensions.\n        \"\"\"\n        return file_extensions()\n\n    def save_workfile(self, dst_path: str = None):\n        \"\"\"Override save_workfile method from IWorkfileHost.\n        Save currently opened workfile.\n\n        Args:\n            dst_path (str): Where the current scene should be saved. Or use\n                current path if `None` is passed.\n        \"\"\"\n        save_file(dst_path if dst_path else bpy.data.filepath)\n\n    def open_workfile(self, filepath: str):\n        \"\"\"Override open_workfile method from IWorkfileHost.\n        Open workfile at specified filepath in the host.\n\n        Args:\n            filepath (str): Path to workfile.\n        \"\"\"\n        open_file(filepath)\n\n    def get_current_workfile(self) -&gt; str:\n        \"\"\"Override get_current_workfile method from IWorkfileHost.\n        Retrieve currently opened workfile path.\n\n        Returns:\n            str: Path to currently opened workfile.\n        \"\"\"\n        return current_file()\n\n    def workfile_has_unsaved_changes(self) -&gt; bool:\n        \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n        Returns True if opened workfile has no unsaved changes.\n\n        Returns:\n            bool: True if scene is saved and False if it has unsaved\n                modifications.\n        \"\"\"\n        return has_unsaved_changes()\n\n    def work_root(self, session) -&gt; str:\n        \"\"\"Override work_root method from IWorkfileHost.\n        Modify workdir per host.\n\n        Args:\n            session (dict): Session context data.\n\n        Returns:\n            str: Path to new workdir.\n        \"\"\"\n        return work_root(session)\n\n    def get_context_data(self) -&gt; dict:\n        \"\"\"Override abstract method from IPublishHost.\n        Get global data related to creation-publishing from workfile.\n\n        Returns:\n            dict: Context data stored using 'update_context_data'.\n        \"\"\"\n        property = bpy.context.scene.get(AVALON_PROPERTY)\n        if property:\n            return property.to_dict()\n        return {}\n\n    def update_context_data(self, data: dict, changes: dict):\n        \"\"\"Override abstract method from IPublishHost.\n        Store global context data to workfile.\n\n        Args:\n            data (dict): New data as are.\n            changes (dict): Only data that has been changed. Each value has\n                tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n        \"\"\"\n        bpy.context.scene[AVALON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_containers","title":"<code>get_containers()</code>","text":"<p>List containers from active Blender scene.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_containers(self) -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\"\"\"\n    return ls()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Override abstract method from IPublishHost. Get global data related to creation-publishing from workfile.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data stored using 'update_context_data'.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_context_data(self) -&gt; dict:\n    \"\"\"Override abstract method from IPublishHost.\n    Get global data related to creation-publishing from workfile.\n\n    Returns:\n        dict: Context data stored using 'update_context_data'.\n    \"\"\"\n    property = bpy.context.scene.get(AVALON_PROPERTY)\n    if property:\n        return property.to_dict()\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_current_workfile","title":"<code>get_current_workfile()</code>","text":"<p>Override get_current_workfile method from IWorkfileHost. Retrieve currently opened workfile path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to currently opened workfile.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_current_workfile(self) -&gt; str:\n    \"\"\"Override get_current_workfile method from IWorkfileHost.\n    Retrieve currently opened workfile path.\n\n    Returns:\n        str: Path to currently opened workfile.\n    \"\"\"\n    return current_file()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Override get_workfile_extensions method from IWorkfileHost. Get workfile possible extensions.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Workfile extensions.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_workfile_extensions(self) -&gt; List[str]:\n    \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n    Get workfile possible extensions.\n\n    Returns:\n        List[str]: Workfile extensions.\n    \"\"\"\n    return file_extensions()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.install","title":"<code>install()</code>","text":"<p>Override install method from HostBase. Install Blender host functionality.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Override install method from HostBase.\n    Install Blender host functionality.\"\"\"\n    install()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.open_workfile","title":"<code>open_workfile(filepath)</code>","text":"<p>Override open_workfile method from IWorkfileHost. Open workfile at specified filepath in the host.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to workfile.</p> required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def open_workfile(self, filepath: str):\n    \"\"\"Override open_workfile method from IWorkfileHost.\n    Open workfile at specified filepath in the host.\n\n    Args:\n        filepath (str): Path to workfile.\n    \"\"\"\n    open_file(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.save_workfile","title":"<code>save_workfile(dst_path=None)</code>","text":"<p>Override save_workfile method from IWorkfileHost. Save currently opened workfile.</p> <p>Parameters:</p> Name Type Description Default <code>dst_path</code> <code>str</code> <p>Where the current scene should be saved. Or use current path if <code>None</code> is passed.</p> <code>None</code> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def save_workfile(self, dst_path: str = None):\n    \"\"\"Override save_workfile method from IWorkfileHost.\n    Save currently opened workfile.\n\n    Args:\n        dst_path (str): Where the current scene should be saved. Or use\n            current path if `None` is passed.\n    \"\"\"\n    save_file(dst_path if dst_path else bpy.data.filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Override abstract method from IPublishHost. Store global context data to workfile.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>New data as are.</p> required <code>changes</code> <code>dict</code> <p>Only data that has been changed. Each value has tuple with '(, )' value. required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def update_context_data(self, data: dict, changes: dict):\n    \"\"\"Override abstract method from IPublishHost.\n    Store global context data to workfile.\n\n    Args:\n        data (dict): New data as are.\n        changes (dict): Only data that has been changed. Each value has\n            tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n    \"\"\"\n    bpy.context.scene[AVALON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.work_root","title":"<code>work_root(session)</code>","text":"<p>Override work_root method from IWorkfileHost. Modify workdir per host.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict</code> <p>Session context data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to new workdir.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def work_root(self, session) -&gt; str:\n    \"\"\"Override work_root method from IWorkfileHost.\n    Modify workdir per host.\n\n    Args:\n        session (dict): Session context data.\n\n    Returns:\n        str: Path to new workdir.\n    \"\"\"\n    return work_root(session)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.workfile_has_unsaved_changes","title":"<code>workfile_has_unsaved_changes()</code>","text":"<p>Override wokfile_has_unsaved_changes method from IWorkfileHost. Returns True if opened workfile has no unsaved changes.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if scene is saved and False if it has unsaved modifications.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def workfile_has_unsaved_changes(self) -&gt; bool:\n    \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n    Returns True if opened workfile has no unsaved changes.\n\n    Returns:\n        bool: True if scene is saved and False if it has unsaved\n            modifications.\n    \"\"\"\n    return has_unsaved_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='CON')</code>","text":"<p>Bundle <code>nodes</code> into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>List</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>Dict</code> <p>Asset information</p> required <code>loader</code> <code>Optional[str]</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Type Description <code>Collection</code> <p>The container assembly</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def containerise(name: str,\n                 namespace: str,\n                 nodes: List,\n                 context: Dict,\n                 loader: Optional[str] = None,\n                 suffix: Optional[str] = \"CON\") -&gt; bpy.types.Collection:\n    \"\"\"Bundle `nodes` into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name: Name of resulting assembly\n        namespace: Namespace under which to host container\n        nodes: Long names of nodes to containerise\n        context: Asset information\n        loader: Name of loader used to produce this container.\n        suffix: Suffix of container, defaults to `_CON`.\n\n    Returns:\n        The container assembly\n\n    \"\"\"\n\n    node_name = f\"{context['folder']['name']}_{name}\"\n    if namespace:\n        node_name = f\"{namespace}:{node_name}\"\n    if suffix:\n        node_name = f\"{node_name}_{suffix}\"\n    container = bpy.data.collections.new(name=node_name)\n    # Link the children nodes\n    for obj in nodes:\n        container.objects.link(obj)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    }\n\n    metadata_update(container, data)\n    add_to_avalon_container(container)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.current_file","title":"<code>current_file()</code>","text":"<p>Return the path of the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def current_file() -&gt; Optional[str]:\n    \"\"\"Return the path of the open scene file.\"\"\"\n\n    current_filepath = bpy.data.filepath\n    if Path(current_filepath).is_file():\n        return current_filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.file_extensions","title":"<code>file_extensions()</code>","text":"<p>Return the supported file extensions for Blender scene files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def file_extensions() -&gt; List[str]:\n    \"\"\"Return the supported file extensions for Blender scene files.\"\"\"\n\n    return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.get_selection","title":"<code>get_selection(include_collections=False)</code>","text":"<p>Returns a list of selected objects in the current Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>include_collections</code> <code>bool</code> <p>Whether to include selected</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Object]</code> <p>List[bpy.types.Object]: A list of selected objects.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_selection(include_collections: bool = False) -&gt; List[bpy.types.Object]:\n    \"\"\"\n    Returns a list of selected objects in the current Blender scene.\n\n    Args:\n        include_collections (bool, optional): Whether to include selected\n        collections in the result. Defaults to False.\n\n    Returns:\n        List[bpy.types.Object]: A list of selected objects.\n    \"\"\"\n    selection = [obj for obj in bpy.context.scene.objects if obj.select_get()]\n\n    if include_collections:\n        selection.extend(get_selected_collections())\n\n    return selection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.has_unsaved_changes","title":"<code>has_unsaved_changes()</code>","text":"<p>Does the open scene file have unsaved changes?</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def has_unsaved_changes() -&gt; bool:\n    \"\"\"Does the open scene file have unsaved changes?\"\"\"\n\n    return bpy.data.is_dirty\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.install","title":"<code>install()</code>","text":"<p>Install Blender configuration for Avalon.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install():\n    \"\"\"Install Blender configuration for Avalon.\"\"\"\n    sys.excepthook = pype_excepthook_handler\n\n    pyblish.api.register_host(\"blender\")\n    pyblish.api.register_plugin_path(str(PUBLISH_PATH))\n\n    register_loader_plugin_path(str(LOAD_PATH))\n    register_creator_plugin_path(str(CREATE_PATH))\n\n    lib.append_user_scripts()\n    lib.set_app_templates_path()\n\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"open\", on_open)\n\n    _register_callbacks()\n    _register_events()\n\n    if not IS_HEADLESS:\n        ops.register()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.ls","title":"<code>ls()</code>","text":"<p>List containers from active Blender scene.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Blender; once loaded they are called containers.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def ls() -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\n\n    This is the host-equivalent of api.ls(), but instead of listing assets on\n    disk, it lists assets already loaded in Blender; once loaded they are\n    called containers.\n    \"\"\"\n    container_ids = {\n        AYON_CONTAINER_ID,\n        # Backwards compatibility\n        AVALON_CONTAINER_ID\n    }\n\n    for id_type in container_ids:\n        for container in lib.lsattr(\"id\", id_type):\n            yield parse_container(container)\n\n    # Compositor nodes are not in `bpy.data` that `lib.lsattr` looks in.\n    node_tree = bpy.context.scene.node_tree\n    if node_tree:\n        for node in node_tree.nodes:\n            if not node.get(AVALON_PROPERTY):\n                continue\n\n            if node.get(AVALON_PROPERTY).get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(node)\n\n    # Shader nodes are not available in a way that `lib.lsattr` can find.\n    for material in bpy.data.materials:\n        material_node_tree = material.node_tree\n        if not material_node_tree:\n            continue\n\n        for shader_node in material_node_tree.nodes:\n            if not shader_node.get(AVALON_PROPERTY):\n                continue\n\n            if shader_node.get(AVALON_PROPERTY).get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(shader_node)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.lsattr","title":"<code>lsattr(attr, value=None)</code>","text":"<p>Return nodes matching <code>attr</code> and <code>value</code></p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Name of Blender property</p> required <code>value</code> <code>Union[str, int, bool, List, Dict, None]</code> <p>Value of attribute. If none is provided, return all nodes with this attribute.</p> <code>None</code> Example <p>lsattr(\"id\", \"myId\") ...   [bpy.data.objects[\"myNode\"] lsattr(\"id\") ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]</p> <p>Returns:</p> Type Description <code>List</code> <p>list</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattr(attr: str,\n           value: Union[str, int, bool, List, Dict, None] = None) -&gt; List:\n    r\"\"\"Return nodes matching `attr` and `value`\n\n    Arguments:\n        attr: Name of Blender property\n        value: Value of attribute. If none\n            is provided, return all nodes with this attribute.\n\n    Example:\n        &gt;&gt;&gt; lsattr(\"id\", \"myId\")\n        ...   [bpy.data.objects[\"myNode\"]\n        &gt;&gt;&gt; lsattr(\"id\")\n        ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]\n\n    Returns:\n        list\n    \"\"\"\n\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.lsattrs","title":"<code>lsattrs(attrs)</code>","text":"<p>Return nodes with the given attribute(s).</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict</code> <p>Name and value pairs of expected matches</p> required Example <p>lsattrs({\"age\": 5})  # Return nodes with an <code>age</code> of 5</p> <p>Returns a list.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattrs(attrs: Dict) -&gt; List:\n    r\"\"\"Return nodes with the given attribute(s).\n\n    Arguments:\n        attrs: Name and value pairs of expected matches\n\n    Example:\n        &gt;&gt;&gt; lsattrs({\"age\": 5})  # Return nodes with an `age` of 5\n        # Return nodes with both `age` and `color` of 5 and blue\n        &gt;&gt;&gt; lsattrs({\"age\": 5, \"color\": \"blue\"})\n\n    Returns a list.\n\n    \"\"\"\n\n    # For now return all objects, not filtered by scene/collection/view_layer.\n    matches = set()\n    for coll in dir(bpy.data):\n        if not isinstance(\n                getattr(bpy.data, coll),\n                bpy.types.bpy_prop_collection,\n        ):\n            continue\n        for node in getattr(bpy.data, coll):\n            for attr, value in attrs.items():\n                avalon_prop = node.get(pipeline.AVALON_PROPERTY)\n                if not avalon_prop:\n                    continue\n                if (avalon_prop.get(attr)\n                        and (value is None or avalon_prop.get(attr) == value)):\n                    matches.add(node)\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.lsattrs--return-nodes-with-both-age-and-color-of-5-and-blue","title":"Return nodes with both <code>age</code> and <code>color</code> of 5 and blue","text":"<p>lsattrs({\"age\": 5, \"color\": \"blue\"})</p>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     # Modify selection ...     bpy.ops.object.select_all(action='DESELECT')</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    r\"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     # Modify selection\n        ...     bpy.ops.object.select_all(action='DESELECT')\n        &gt;&gt;&gt; # Selection restored\n    \"\"\"\n\n    previous_selection = get_selection()\n    previous_active = bpy.context.view_layer.objects.active\n    try:\n        yield\n    finally:\n        # Clear the selection\n        for node in get_selection():\n            node.select_set(state=False)\n        if previous_selection:\n            for node in previous_selection:\n                try:\n                    node.select_set(state=True)\n                except ReferenceError:\n                    # This could happen if a selected node was deleted during\n                    # the context.\n                    log.exception(\"Failed to reselect\")\n                    continue\n        try:\n            bpy.context.view_layer.objects.active = previous_active\n        except ReferenceError:\n            # This could happen if the active node was deleted during the\n            # context.\n            log.exception(\"Failed to set active object.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.maintained_selection--selection-restored","title":"Selection restored","text":""},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.maintained_time","title":"<code>maintained_time()</code>","text":"<p>Maintain current frame during context.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_time():\n    \"\"\"Maintain current frame during context.\"\"\"\n    current_time = bpy.context.scene.frame_current\n    try:\n        yield\n    finally:\n        bpy.context.scene.frame_current = current_time\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Open the scene file in Blender.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def open_file(filepath: str) -&gt; Optional[str]:\n    \"\"\"Open the scene file in Blender.\"\"\"\n    OpenFileCacher.set_opening()\n\n    preferences = bpy.context.preferences\n    load_ui = preferences.filepaths.use_load_ui\n    use_scripts = preferences.filepaths.use_scripts_auto_execute\n    result = bpy.ops.wm.open_mainfile(\n        filepath=filepath,\n        load_ui=load_ui,\n        use_scripts=use_scripts,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.publish","title":"<code>publish()</code>","text":"<p>Shorthand to publish from within host.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def publish():\n    \"\"\"Shorthand to publish from within host.\"\"\"\n\n    return pyblish.util.publish()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.read","title":"<code>read(node)</code>","text":"<p>Return user-defined attributes from <code>node</code></p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def read(node: bpy.types.bpy_struct_meta_idprop):\n    \"\"\"Return user-defined attributes from `node`\"\"\"\n\n    data = dict(node.get(pipeline.AVALON_PROPERTY, {}))\n\n    # Ignore hidden/internal data\n    data = {\n        key: value\n        for key, value in data.items() if not key.startswith(\"_\")\n    }\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.save_file","title":"<code>save_file(filepath, copy=False)</code>","text":"<p>Save the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def save_file(filepath: str, copy: bool = False) -&gt; Optional[str]:\n    \"\"\"Save the open scene file.\"\"\"\n\n    preferences = bpy.context.preferences\n    compress = preferences.filepaths.use_file_compression\n    relative_remap = preferences.filepaths.use_relative_paths\n    result = bpy.ops.wm.save_as_mainfile(\n        filepath=filepath,\n        compress=compress,\n        relative_remap=relative_remap,\n        copy=copy,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall Blender configuration for Avalon.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def uninstall():\n    \"\"\"Uninstall Blender configuration for Avalon.\"\"\"\n    sys.excepthook = ORIGINAL_EXCEPTHOOK\n\n    pyblish.api.deregister_host(\"blender\")\n    pyblish.api.deregister_plugin_path(str(PUBLISH_PATH))\n\n    deregister_loader_plugin_path(str(LOAD_PATH))\n    deregister_creator_plugin_path(str(CREATE_PATH))\n\n    if not IS_HEADLESS:\n        ops.unregister()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.work_root","title":"<code>work_root(session)</code>","text":"<p>Return the default root to browse for work files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def work_root(session: dict) -&gt; str:\n    \"\"\"Return the default root to browse for work files.\"\"\"\n\n    work_dir = session[\"AYON_WORKDIR\"]\n    scene_dir = session.get(\"AVALON_SCENEDIR\")\n    if scene_dir:\n        return str(Path(work_dir, scene_dir))\n    return work_dir\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_blender/api/action.html#client.ayon_blender.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid objects in Blender when a publish plug-in failed.</p> Source code in <code>client/ayon_blender/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid objects in Blender when a publish plug-in failed.\"\"\"\n    label = \"Select Invalid\"\n    on = \"failed\"\n    icon = \"search\"\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(context,\n                                                               plugin=plugin)\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes...\")\n        invalid = list()\n        for instance in errored_instances:\n            invalid_nodes = plugin.get_invalid(instance)\n            if invalid_nodes:\n                if isinstance(invalid_nodes, (list, tuple)):\n                    invalid.extend(invalid_nodes)\n                else:\n                    self.log.warning(\n                        \"Failed plug-in doesn't have any selectable objects.\"\n                    )\n\n        bpy.ops.object.select_all(action='DESELECT')\n\n        # Make sure every node is only processed once\n        invalid = list(set(invalid))\n        if not invalid:\n            self.log.info(\"No invalid nodes found.\")\n            return\n\n        invalid_names = [obj.name for obj in invalid]\n        self.log.info(\n            \"Selecting invalid objects: %s\", \", \".join(invalid_names)\n        )\n        # Select the objects and also make the last one the active object.\n        for obj in invalid:\n            obj.select_set(True)\n\n        bpy.context.view_layer.objects.active = invalid[-1]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html","title":"capture","text":"<p>Blender Capture Playblasting with independent viewport, camera and display options</p>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_frame_range","title":"<code>applied_frame_range(window, start, end, step)</code>","text":"<p>Context manager for setting frame range.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef applied_frame_range(window, start, end, step):\n    \"\"\"Context manager for setting frame range.\"\"\"\n    # Store current frame range\n    current_frame_start = window.scene.frame_start\n    current_frame_end = window.scene.frame_end\n    current_frame_step = window.scene.frame_step\n    # Apply frame range\n    window.scene.frame_start = start\n    window.scene.frame_end = end\n    window.scene.frame_step = step\n    try:\n        yield\n    finally:\n        # Restore frame range\n        window.scene.frame_start = current_frame_start\n        window.scene.frame_end = current_frame_end\n        window.scene.frame_step = current_frame_step\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_image_settings","title":"<code>applied_image_settings(window, options)</code>","text":"<p>Context manager to override image settings.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef applied_image_settings(window, options):\n    \"\"\"Context manager to override image settings.\"\"\"\n\n    options = options or ImageSettings.copy()\n    ffmpeg = options.pop(\"ffmpeg\", {})\n    render = window.scene.render\n\n    # Store current image settings\n    original = {}\n    for opt in options.copy():\n        try:\n            original[opt] = getattr(render.image_settings, opt)\n        except ValueError:\n            options.pop(opt)\n\n    # Store current ffmpeg settings\n    original_ffmpeg = {}\n    for opt in ffmpeg.copy():\n        try:\n            original_ffmpeg[opt] = getattr(render.ffmpeg, opt)\n        except ValueError:\n            ffmpeg.pop(opt)\n\n    # Apply image settings\n    for opt, value in options.items():\n        setattr(render.image_settings, opt, value)\n\n    # Apply ffmpeg settings\n    for opt, value in ffmpeg.items():\n        setattr(render.ffmpeg, opt, value)\n\n    try:\n        yield\n    finally:\n        # Restore previous settings\n        for opt, value in original.items():\n            setattr(render.image_settings, opt, value)\n        for opt, value in original_ffmpeg.items():\n            setattr(render.ffmpeg, opt, value)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_render_options","title":"<code>applied_render_options(window, options)</code>","text":"<p>Context manager for setting render options.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef applied_render_options(window, options):\n    \"\"\"Context manager for setting render options.\"\"\"\n    render = window.scene.render\n\n    # Store current settings\n    original = {}\n    for opt in options.copy():\n        try:\n            original[opt] = getattr(render, opt)\n        except ValueError:\n            options.pop(opt)\n\n    # Apply settings\n    _apply_options(render, options)\n\n    try:\n        yield\n    finally:\n        # Restore previous settings\n        _apply_options(render, original)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_view","title":"<code>applied_view(window, camera, isolate=None, options=None)</code>","text":"<p>Apply view options to window.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def applied_view(window, camera, isolate=None, options=None):\n    \"\"\"Apply view options to window.\"\"\"\n    area = window.screen.areas[0]\n    space = area.spaces[0]\n\n    area.ui_type = \"VIEW_3D\"\n\n    types = {\"MESH\", \"GPENCIL\"}\n    objects = [obj for obj in window.scene.objects if obj.type in types]\n\n    if camera == \"AUTO\":\n        space.region_3d.view_perspective = \"ORTHO\"\n        isolate_objects(window, isolate or objects)\n    else:\n        isolate_objects(window, isolate or objects)\n        space.camera = window.scene.objects.get(camera)\n        space.region_3d.view_perspective = \"CAMERA\"\n\n    if isinstance(options, dict):\n        _apply_options(space, options)\n    else:\n        space.shading.type = \"SOLID\"\n        space.shading.color_type = \"MATERIAL\"\n        space.show_gizmo = False\n        space.overlay.show_overlays = False\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.capture","title":"<code>capture(camera=None, width=None, height=None, filename=None, start_frame=None, end_frame=None, step_frame=None, sound=None, isolate=None, maintain_aspect_ratio=True, overwrite=False, image_settings=None, display_options=None)</code>","text":"<p>Playblast in an independent windows Arguments:     camera (str, optional): Name of camera, defaults to \"Camera\"     width (int, optional): Width of output in pixels     height (int, optional): Height of output in pixels     filename (str, optional): Name of output file path. Defaults to current         render output path.     start_frame (int, optional): Defaults to current start frame.     end_frame (int, optional): Defaults to current end frame.     step_frame (int, optional): Defaults to 1.     sound (str, optional):  Specify the sound node to be used during         playblast. When None (default) no sound will be used.     isolate (list): List of nodes to isolate upon capturing     maintain_aspect_ratio (bool, optional): Modify height in order to         maintain aspect ratio.     overwrite (bool, optional): Whether or not to overwrite if file         already exists. If disabled and file exists and error will be         raised.     image_settings (dict, optional): Supplied image settings for render,         using <code>ImageSettings</code>     display_options (dict, optional): Supplied display options for render</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def capture(\n    camera=None,\n    width=None,\n    height=None,\n    filename=None,\n    start_frame=None,\n    end_frame=None,\n    step_frame=None,\n    sound=None,\n    isolate=None,\n    maintain_aspect_ratio=True,\n    overwrite=False,\n    image_settings=None,\n    display_options=None\n):\n    \"\"\"Playblast in an independent windows\n    Arguments:\n        camera (str, optional): Name of camera, defaults to \"Camera\"\n        width (int, optional): Width of output in pixels\n        height (int, optional): Height of output in pixels\n        filename (str, optional): Name of output file path. Defaults to current\n            render output path.\n        start_frame (int, optional): Defaults to current start frame.\n        end_frame (int, optional): Defaults to current end frame.\n        step_frame (int, optional): Defaults to 1.\n        sound (str, optional):  Specify the sound node to be used during\n            playblast. When None (default) no sound will be used.\n        isolate (list): List of nodes to isolate upon capturing\n        maintain_aspect_ratio (bool, optional): Modify height in order to\n            maintain aspect ratio.\n        overwrite (bool, optional): Whether or not to overwrite if file\n            already exists. If disabled and file exists and error will be\n            raised.\n        image_settings (dict, optional): Supplied image settings for render,\n            using `ImageSettings`\n        display_options (dict, optional): Supplied display options for render\n    \"\"\"\n\n    scene = bpy.context.scene\n    camera = camera or \"Camera\"\n\n    # Ensure camera exists.\n    if camera not in scene.objects and camera != \"AUTO\":\n        raise RuntimeError(\"Camera does not exist: {0}\".format(camera))\n\n    # Ensure resolution.\n    if width and height:\n        maintain_aspect_ratio = False\n    width = width or scene.render.resolution_x\n    height = height or scene.render.resolution_y\n    if maintain_aspect_ratio:\n        ratio = scene.render.resolution_x / scene.render.resolution_y\n        height = round(width / ratio)\n\n    # Get frame range.\n    if start_frame is None:\n        start_frame = scene.frame_start\n    if end_frame is None:\n        end_frame = scene.frame_end\n    if step_frame is None:\n        step_frame = 1\n    frame_range = (start_frame, end_frame, step_frame)\n\n    if filename is None:\n        filename = scene.render.filepath\n\n    render_options = {\n        \"filepath\": \"{}.\".format(filename.rstrip(\".\")),\n        \"resolution_x\": width,\n        \"resolution_y\": height,\n        \"use_overwrite\": overwrite,\n    }\n\n    with _independent_window() as window:\n\n        applied_view(window, camera, isolate, options=display_options)\n\n        with contextlib.ExitStack() as stack:\n            stack.enter_context(maintain_camera(window, camera))\n            stack.enter_context(applied_frame_range(window, *frame_range))\n            stack.enter_context(applied_render_options(window, render_options))\n            stack.enter_context(applied_image_settings(window, image_settings))\n            stack.enter_context(maintained_time())\n\n            bpy.ops.render.opengl(\n                animation=True,\n                render_keyed_only=False,\n                sequencer=False,\n                write_still=False,\n                view_context=True\n            )\n\n    return filename\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.isolate_objects","title":"<code>isolate_objects(window, objects)</code>","text":"<p>Isolate selection</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def isolate_objects(window, objects):\n    \"\"\"Isolate selection\"\"\"\n    deselect_all()\n\n    for obj in objects:\n        obj.select_set(True)\n\n    context = create_blender_context(selected=objects, window=window)\n\n    with bpy.context.temp_override(**context):\n        bpy.ops.view3d.view_axis(type=\"FRONT\")\n        bpy.ops.view3d.localview()\n\n    deselect_all()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.maintain_camera","title":"<code>maintain_camera(window, camera)</code>","text":"<p>Context manager to override camera.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef maintain_camera(window, camera):\n    \"\"\"Context manager to override camera.\"\"\"\n    current_camera = window.scene.camera\n    if camera in window.scene.objects:\n        window.scene.camera = window.scene.objects.get(camera)\n    try:\n        yield\n    finally:\n        window.scene.camera = current_camera\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.restore_global_view","title":"<code>restore_global_view(window)</code>","text":"<p>Exit local view if active.</p> <p>Blender currently does not exit localview when closing windows.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def restore_global_view(window):\n    \"\"\"Exit local view if active.\n\n    Blender currently does not exit localview when closing windows.\n    \"\"\"\n\n    types = {\"MESH\", \"GPENCIL\"}\n    objects = [obj for obj in window.scene.objects if obj.type in types]\n\n    context = create_blender_context(selected=objects, window=window)\n\n    with bpy.context.temp_override(**context):\n        # Only toggle back if in local view\n        if bpy.context.space_data.local_view:\n            bpy.ops.view3d.localview()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html","title":"colorspace","text":""},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.ARenderProduct","title":"<code>ARenderProduct</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>class ARenderProduct(object):\n    def __init__(self, frame_start, frame_end):\n        \"\"\"Constructor.\"\"\"\n        # Initialize\n        self.layer_data = self._get_layer_data(frame_start, frame_end)\n        self.layer_data.products = self.get_render_products()\n\n    def _get_layer_data(\n        self,\n        frame_start: int,\n        frame_end: int\n    ) -&gt; LayerMetadata:\n        return LayerMetadata(\n            frameStart=int(frame_start),\n            frameEnd=int(frame_end),\n        )\n\n    def get_render_products(self):\n        \"\"\"To be implemented by renderer class.\n        This should return a list of RenderProducts.\n        Returns:\n            list: List of RenderProduct\n        \"\"\"\n        return [\n            RenderProduct(\n                colorspace=\"sRGB\",\n                view=\"ACES 1.0\",\n                productName=\"\"\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.ARenderProduct.__init__","title":"<code>__init__(frame_start, frame_end)</code>","text":"<p>Constructor.</p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>def __init__(self, frame_start, frame_end):\n    \"\"\"Constructor.\"\"\"\n    # Initialize\n    self.layer_data = self._get_layer_data(frame_start, frame_end)\n    self.layer_data.products = self.get_render_products()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.ARenderProduct.get_render_products","title":"<code>get_render_products()</code>","text":"<p>To be implemented by renderer class. This should return a list of RenderProducts. Returns:     list: List of RenderProduct</p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>def get_render_products(self):\n    \"\"\"To be implemented by renderer class.\n    This should return a list of RenderProducts.\n    Returns:\n        list: List of RenderProduct\n    \"\"\"\n    return [\n        RenderProduct(\n            colorspace=\"sRGB\",\n            view=\"ACES 1.0\",\n            productName=\"\"\n        )\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.LayerMetadata","title":"<code>LayerMetadata</code>","text":"<p>               Bases: <code>object</code></p> <p>Data class for Render Layer metadata.</p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>@attr.s\nclass LayerMetadata(object):\n    \"\"\"Data class for Render Layer metadata.\"\"\"\n    frameStart = attr.ib()\n    frameEnd = attr.ib()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.RenderProduct","title":"<code>RenderProduct</code>","text":"<p>               Bases: <code>object</code></p> <p>Getting Colorspace as Specific Render Product Parameter for submitting publish job.</p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>@attr.s\nclass RenderProduct(object):\n    \"\"\"\n    Getting Colorspace as Specific Render Product Parameter for submitting\n    publish job.\n    \"\"\"\n    colorspace = attr.ib()  # colorspace\n    view = attr.ib()        # OCIO view transform\n    productName = attr.ib(default=None)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.attribute_overrides","title":"<code>attribute_overrides(obj, attribute_values)</code>","text":"<p>Apply attribute or property overrides during context.</p> <p>Supports nested/deep overrides, that is also why it does not use **kwargs as function arguments because it requires the keys to support dots (<code>.</code>).</p> Example <p>with attribute_overrides(scene, { ...     \"render.fps\": 30, ...     \"frame_start\": 1001} ... ): ...     print(scene.render.fps) ...     print(scene.frame_start)</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to set attributes and properties on.</p> required <code>attribute_values</code> <p>(dict[str, Any]): The property names mapped to the values that will be applied during the context.</p> required Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef attribute_overrides(\n        obj,\n        attribute_values\n):\n    \"\"\"Apply attribute or property overrides during context.\n\n    Supports nested/deep overrides, that is also why it does not use **kwargs\n    as function arguments because it requires the keys to support dots (`.`).\n\n    Example:\n        &gt;&gt;&gt; with attribute_overrides(scene, {\n        ...     \"render.fps\": 30,\n        ...     \"frame_start\": 1001}\n        ... ):\n        ...     print(scene.render.fps)\n        ...     print(scene.frame_start)\n        # 30\n        # 1001\n\n    Arguments:\n        obj (Any): The object to set attributes and properties on.\n        attribute_values: (dict[str, Any]): The property names mapped to the\n            values that will be applied during the context.\n    \"\"\"\n    if not attribute_values:\n        # do nothing\n        yield\n        return\n\n    # Helper functions to get and set nested keys on the scene object like\n    # e.g. \"scene.unit_settings.scale_length\" or \"scene.render.fps\"\n    # by doing `setattr_deep(scene, \"unit_settings.scale_length\", 10)`\n    def getattr_deep(root, path):\n        for key in path.split(\".\"):\n            root = getattr(root, key)\n        return root\n\n    def setattr_deep(root, path, value):\n        keys = path.split(\".\")\n        last_key = keys.pop()\n        for key in keys:\n            root = getattr(root, key)\n        return setattr(root, last_key, value)\n\n    # Get original values\n    original = {\n        key: getattr_deep(obj, key) for key in attribute_values\n    }\n    try:\n        for key, value in attribute_values.items():\n            setattr_deep(obj, key, value)\n        yield\n    finally:\n        for key, value in original.items():\n            setattr_deep(obj, key, value)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.attribute_overrides--30","title":"30","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.attribute_overrides--1001","title":"1001","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.collect_animation_defs","title":"<code>collect_animation_defs(create_context, step=True, fps=False)</code>","text":"<p>Get the basic animation attribute definitions for the publisher.</p> <p>Parameters:</p> Name Type Description Default <code>create_context</code> <code>CreateContext</code> <p>The context of publisher will be used to define the defaults for the attributes to use the current context's entity frame range as default values.</p> required <code>step</code> <code>bool</code> <p>Whether to include <code>step</code> attribute definition.</p> <code>True</code> <code>fps</code> <code>bool</code> <p>Whether to include <code>fps</code> attribute definition.</p> <code>False</code> <p>Returns:</p> Type Description <p>List[NumberDef]: List of number attribute definitions.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def collect_animation_defs(create_context, step=True, fps=False):\n    \"\"\"Get the basic animation attribute definitions for the publisher.\n\n    Arguments:\n        create_context (CreateContext): The context of publisher will be\n            used to define the defaults for the attributes to use the current\n            context's entity frame range as default values.\n        step (bool): Whether to include `step` attribute definition.\n        fps (bool): Whether to include `fps` attribute definition.\n\n    Returns:\n        List[NumberDef]: List of number attribute definitions.\n\n    \"\"\"\n\n    # get scene values as defaults\n    scene = bpy.context.scene\n    # frame_start = scene.frame_start\n    # frame_end = scene.frame_end\n    # handle_start = 0\n    # handle_end = 0\n\n    # use task entity attributes to set defaults based on current context\n    task_entity = create_context.get_current_task_entity()\n    attrib: dict = task_entity[\"attrib\"]\n    frame_start = attrib[\"frameStart\"]\n    frame_end = attrib[\"frameEnd\"]\n    handle_start = attrib[\"handleStart\"]\n    handle_end = attrib[\"handleEnd\"]\n\n    # build attributes\n    defs = [\n        NumberDef(\"frameStart\",\n                  label=\"Frame Start\",\n                  default=frame_start,\n                  decimals=0),\n        NumberDef(\"frameEnd\",\n                  label=\"Frame End\",\n                  default=frame_end,\n                  decimals=0),\n        NumberDef(\"handleStart\",\n                  label=\"Handle Start\",\n                  tooltip=\"Frames added before frame start to use as handles.\",\n                  default=handle_start,\n                  decimals=0),\n        NumberDef(\"handleEnd\",\n                  label=\"Handle End\",\n                  tooltip=\"Frames added after frame end to use as handles.\",\n                  default=handle_end,\n                  decimals=0),\n    ]\n\n    if step:\n        defs.append(\n            NumberDef(\n                \"step\",\n                label=\"Step size\",\n                tooltip=\"Number of frames to skip forward while rendering/\"\n                        \"playing back each frame\",\n                default=1,\n                decimals=0\n            )\n        )\n\n    if fps:\n        current_fps = scene.render.fps / scene.render.fps_base\n        fps_def = NumberDef(\n            \"fps\", label=\"FPS\", default=current_fps, decimals=5\n        )\n        defs.append(fps_def)\n\n    return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_all_parents","title":"<code>get_all_parents(obj)</code>","text":"<p>Get all recursive parents of object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Object</code> <p>Object to get all parents for.</p> required <p>Returns:</p> Type Description <p>List[bpy.types.Object]: All parents of object</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_all_parents(obj):\n    \"\"\"Get all recursive parents of object.\n\n    Arguments:\n        obj (bpy.types.Object): Object to get all parents for.\n\n    Returns:\n        List[bpy.types.Object]: All parents of object\n\n    \"\"\"\n    result = []\n    while True:\n        obj = obj.parent\n        if not obj:\n            break\n        result.append(obj)\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_blender_version","title":"<code>get_blender_version()</code>","text":"<p>Get Blender Version</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_blender_version():\n    \"\"\"Get Blender Version\n    \"\"\"\n    major, minor, subversion = bpy.app.version\n    return major, minor, subversion\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_highest_root","title":"<code>get_highest_root(objects)</code>","text":"<p>Get the highest object (the least parents) among the objects.</p> <p>If multiple objects have the same amount of parents (or no parents) the first object found in the input iterable will be returned.</p> <p>Note that this will not return objects outside of the input list, as such it will not return the root of node from a child node. It is purely intended to find the highest object among a list of objects. To instead get the root from one object use, e.g. <code>get_all_parents(obj)[-1]</code></p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>List[Object]</code> <p>Objects to find the highest root in.</p> required <p>Returns:</p> Type Description <p>Optional[bpy.types.Object]: First highest root found or None if no <code>bpy.types.Object</code> found in input list.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_highest_root(objects):\n    \"\"\"Get the highest object (the least parents) among the objects.\n\n    If multiple objects have the same amount of parents (or no parents) the\n    first object found in the input iterable will be returned.\n\n    Note that this will *not* return objects outside of the input list, as\n    such it will not return the root of node from a child node. It is purely\n    intended to find the highest object among a list of objects. To instead\n    get the root from one object use, e.g. `get_all_parents(obj)[-1]`\n\n    Arguments:\n        objects (List[bpy.types.Object]): Objects to find the highest root in.\n\n    Returns:\n        Optional[bpy.types.Object]: First highest root found or None if no\n            `bpy.types.Object` found in input list.\n\n    \"\"\"\n    included_objects = {obj.name_full for obj in objects}\n    num_parents_to_obj = {}\n    for obj in objects:\n        if isinstance(obj, bpy.types.Object):\n            parents = get_all_parents(obj)\n            # included parents\n            parents = [parent for parent in parents if\n                       parent.name_full in included_objects]\n            if not parents:\n                # A node without parents must be a highest root\n                return obj\n\n            num_parents_to_obj.setdefault(len(parents), obj)\n\n    if not num_parents_to_obj:\n        return\n\n    minimum_parent = min(num_parents_to_obj)\n    return num_parents_to_obj[minimum_parent]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_selected_collections","title":"<code>get_selected_collections()</code>","text":"<p>Returns a list of the currently selected collections in the outliner.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the outliner cannot be found in the main Blender</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of <code>bpy.types.Collection</code> objects that are currently</p> <p>selected in the outliner.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_selected_collections():\n    \"\"\"\n    Returns a list of the currently selected collections in the outliner.\n\n    Raises:\n        RuntimeError: If the outliner cannot be found in the main Blender\n        window.\n\n    Returns:\n        list: A list of `bpy.types.Collection` objects that are currently\n        selected in the outliner.\n    \"\"\"\n    window = bpy.context.window or bpy.context.window_manager.windows[0]\n\n    try:\n        area = next(\n            area for area in window.screen.areas\n            if area.type == 'OUTLINER')\n        region = next(\n            region for region in area.regions\n            if region.type == 'WINDOW')\n    except StopIteration as e:\n        raise RuntimeError(\"Could not find outliner. An outliner space \"\n                           \"must be in the main Blender window.\") from e\n\n    with bpy.context.temp_override(\n        window=window,\n        area=area,\n        region=region,\n        screen=window.screen\n    ):\n        ids = bpy.context.selected_ids\n\n    return [id for id in ids if isinstance(id, bpy.types.Collection)]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_selection","title":"<code>get_selection(include_collections=False)</code>","text":"<p>Returns a list of selected objects in the current Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>include_collections</code> <code>bool</code> <p>Whether to include selected</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Object]</code> <p>List[bpy.types.Object]: A list of selected objects.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_selection(include_collections: bool = False) -&gt; List[bpy.types.Object]:\n    \"\"\"\n    Returns a list of selected objects in the current Blender scene.\n\n    Args:\n        include_collections (bool, optional): Whether to include selected\n        collections in the result. Defaults to False.\n\n    Returns:\n        List[bpy.types.Object]: A list of selected objects.\n    \"\"\"\n    selection = [obj for obj in bpy.context.scene.objects if obj.select_get()]\n\n    if include_collections:\n        selection.extend(get_selected_collections())\n\n    return selection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.imprint","title":"<code>imprint(node, data)</code>","text":"<p>Write <code>data</code> to <code>node</code> as userDefined attributes</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>bpy_struct_meta_idprop</code> <p>Long name of node</p> required <code>data</code> <code>Dict</code> <p>Dictionary of key/value pairs</p> required Example <p>import bpy def compute(): ...   return 6 ... bpy.ops.mesh.primitive_cube_add() cube = bpy.context.view_layer.objects.active imprint(cube, { ...   \"regularString\": \"myFamily\", ...   \"computedValue\": lambda: compute() ... }) ... cube['avalon']['computedValue'] 6</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def imprint(node: bpy.types.bpy_struct_meta_idprop, data: Dict):\n    r\"\"\"Write `data` to `node` as userDefined attributes\n\n    Arguments:\n        node: Long name of node\n        data: Dictionary of key/value pairs\n\n    Example:\n        &gt;&gt;&gt; import bpy\n        &gt;&gt;&gt; def compute():\n        ...   return 6\n        ...\n        &gt;&gt;&gt; bpy.ops.mesh.primitive_cube_add()\n        &gt;&gt;&gt; cube = bpy.context.view_layer.objects.active\n        &gt;&gt;&gt; imprint(cube, {\n        ...   \"regularString\": \"myFamily\",\n        ...   \"computedValue\": lambda: compute()\n        ... })\n        ...\n        &gt;&gt;&gt; cube['avalon']['computedValue']\n        6\n    \"\"\"\n\n    imprint_data = dict()\n\n    for key, value in data.items():\n        if value is None:\n            continue\n\n        if callable(value):\n            # Support values evaluated at imprint\n            value = value()\n\n        if not isinstance(value, (int, float, bool, str, list, dict)):\n            raise TypeError(f\"Unsupported type: {type(value)}\")\n\n        imprint_data[key] = value\n\n    pipeline.metadata_update(node, imprint_data)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.load_scripts","title":"<code>load_scripts(paths)</code>","text":"<p>Copy of <code>load_scripts</code> from Blender's implementation.</p> <p>It is possible that this function will be changed in future and usage will be based on Blender version.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def load_scripts(paths):\n    \"\"\"Copy of `load_scripts` from Blender's implementation.\n\n    It is possible that this function will be changed in future and usage will\n    be based on Blender version.\n    \"\"\"\n    import bpy_types\n\n    loaded_modules = set()\n\n    previous_classes = [\n        cls\n        for cls in bpy.types.bpy_struct.__subclasses__()\n    ]\n\n    def register_module_call(mod):\n        register = getattr(mod, \"register\", None)\n        if register:\n            try:\n                register()\n            except:  # noqa E722\n                traceback.print_exc()\n        else:\n            print(\"\\nWarning! '%s' has no register function, \"\n                  \"this is now a requirement for registerable scripts\" %\n                  mod.__file__)\n\n    def unregister_module_call(mod):\n        unregister = getattr(mod, \"unregister\", None)\n        if unregister:\n            try:\n                unregister()\n            except:  # noqa E722\n                traceback.print_exc()\n\n    def test_reload(mod):\n        # reloading this causes internal errors\n        # because the classes from this module are stored internally\n        # possibly to refresh internal references too but for now, best not to.\n        if mod == bpy_types:\n            return mod\n\n        try:\n            return importlib.reload(mod)\n        except:  # noqa E722\n            traceback.print_exc()\n\n    def test_register(mod):\n        if mod:\n            register_module_call(mod)\n            bpy.utils._global_loaded_modules.append(mod.__name__)\n\n    from bpy_restrict_state import RestrictBlend\n\n    with RestrictBlend():\n        for base_path in paths:\n            for path_subdir in bpy.utils._script_module_dirs:\n                path = os.path.join(base_path, path_subdir)\n                if not os.path.isdir(path):\n                    continue\n\n                bpy.utils._sys_path_ensure_prepend(path)\n\n                # Only add to 'sys.modules' unless this is 'startup'.\n                if path_subdir != \"startup\":\n                    continue\n                for mod in bpy.utils.modules_from_path(path, loaded_modules):\n                    test_register(mod)\n\n    addons_paths = []\n    for base_path in paths:\n        addons_path = os.path.join(base_path, \"addons\")\n        if not os.path.exists(addons_path):\n            continue\n        addons_paths.append(addons_path)\n        addons_module_path = os.path.join(addons_path, \"modules\")\n        if os.path.exists(addons_module_path):\n            bpy.utils._sys_path_ensure_prepend(addons_module_path)\n\n    if addons_paths:\n        # Fake addons\n        origin_paths = addon_utils.paths\n\n        def new_paths():\n            paths = origin_paths() + addons_paths\n            return paths\n\n        addon_utils.paths = new_paths\n        addon_utils.modules_refresh()\n\n    # load template (if set)\n    if any(bpy.utils.app_template_paths()):\n        import bl_app_template_utils\n        bl_app_template_utils.reset(reload_scripts=False)\n        del bl_app_template_utils\n\n    for cls in bpy.types.bpy_struct.__subclasses__():\n        if cls in previous_classes:\n            continue\n        if not getattr(cls, \"is_registered\", False):\n            continue\n        for subcls in cls.__subclasses__():\n            if not subcls.is_registered:\n                print(\n                    \"Warning, unregistered class: %s(%s)\" %\n                    (subcls.__name__, cls.__name__)\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.lsattr","title":"<code>lsattr(attr, value=None)</code>","text":"<p>Return nodes matching <code>attr</code> and <code>value</code></p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Name of Blender property</p> required <code>value</code> <code>Union[str, int, bool, List, Dict, None]</code> <p>Value of attribute. If none is provided, return all nodes with this attribute.</p> <code>None</code> Example <p>lsattr(\"id\", \"myId\") ...   [bpy.data.objects[\"myNode\"] lsattr(\"id\") ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]</p> <p>Returns:</p> Type Description <code>List</code> <p>list</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattr(attr: str,\n           value: Union[str, int, bool, List, Dict, None] = None) -&gt; List:\n    r\"\"\"Return nodes matching `attr` and `value`\n\n    Arguments:\n        attr: Name of Blender property\n        value: Value of attribute. If none\n            is provided, return all nodes with this attribute.\n\n    Example:\n        &gt;&gt;&gt; lsattr(\"id\", \"myId\")\n        ...   [bpy.data.objects[\"myNode\"]\n        &gt;&gt;&gt; lsattr(\"id\")\n        ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]\n\n    Returns:\n        list\n    \"\"\"\n\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.lsattrs","title":"<code>lsattrs(attrs)</code>","text":"<p>Return nodes with the given attribute(s).</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict</code> <p>Name and value pairs of expected matches</p> required Example <p>lsattrs({\"age\": 5})  # Return nodes with an <code>age</code> of 5</p> <p>Returns a list.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattrs(attrs: Dict) -&gt; List:\n    r\"\"\"Return nodes with the given attribute(s).\n\n    Arguments:\n        attrs: Name and value pairs of expected matches\n\n    Example:\n        &gt;&gt;&gt; lsattrs({\"age\": 5})  # Return nodes with an `age` of 5\n        # Return nodes with both `age` and `color` of 5 and blue\n        &gt;&gt;&gt; lsattrs({\"age\": 5, \"color\": \"blue\"})\n\n    Returns a list.\n\n    \"\"\"\n\n    # For now return all objects, not filtered by scene/collection/view_layer.\n    matches = set()\n    for coll in dir(bpy.data):\n        if not isinstance(\n                getattr(bpy.data, coll),\n                bpy.types.bpy_prop_collection,\n        ):\n            continue\n        for node in getattr(bpy.data, coll):\n            for attr, value in attrs.items():\n                avalon_prop = node.get(pipeline.AVALON_PROPERTY)\n                if not avalon_prop:\n                    continue\n                if (avalon_prop.get(attr)\n                        and (value is None or avalon_prop.get(attr) == value)):\n                    matches.add(node)\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.lsattrs--return-nodes-with-both-age-and-color-of-5-and-blue","title":"Return nodes with both <code>age</code> and <code>color</code> of 5 and blue","text":"<p>lsattrs({\"age\": 5, \"color\": \"blue\"})</p>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     # Modify selection ...     bpy.ops.object.select_all(action='DESELECT')</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    r\"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     # Modify selection\n        ...     bpy.ops.object.select_all(action='DESELECT')\n        &gt;&gt;&gt; # Selection restored\n    \"\"\"\n\n    previous_selection = get_selection()\n    previous_active = bpy.context.view_layer.objects.active\n    try:\n        yield\n    finally:\n        # Clear the selection\n        for node in get_selection():\n            node.select_set(state=False)\n        if previous_selection:\n            for node in previous_selection:\n                try:\n                    node.select_set(state=True)\n                except ReferenceError:\n                    # This could happen if a selected node was deleted during\n                    # the context.\n                    log.exception(\"Failed to reselect\")\n                    continue\n        try:\n            bpy.context.view_layer.objects.active = previous_active\n        except ReferenceError:\n            # This could happen if the active node was deleted during the\n            # context.\n            log.exception(\"Failed to set active object.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.maintained_selection--selection-restored","title":"Selection restored","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.maintained_time","title":"<code>maintained_time()</code>","text":"<p>Maintain current frame during context.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_time():\n    \"\"\"Maintain current frame during context.\"\"\"\n    current_time = bpy.context.scene.frame_current\n    try:\n        yield\n    finally:\n        bpy.context.scene.frame_current = current_time\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.read","title":"<code>read(node)</code>","text":"<p>Return user-defined attributes from <code>node</code></p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def read(node: bpy.types.bpy_struct_meta_idprop):\n    \"\"\"Return user-defined attributes from `node`\"\"\"\n\n    data = dict(node.get(pipeline.AVALON_PROPERTY, {}))\n\n    # Ignore hidden/internal data\n    data = {\n        key: value\n        for key, value in data.items() if not key.startswith(\"_\")\n    }\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html","title":"ops","text":"<p>Blender operators and menus for use with Avalon.</p>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchCreator","title":"<code>LaunchCreator</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch Avalon Creator.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchCreator(LaunchQtApp):\n    \"\"\"Launch Avalon Creator.\"\"\"\n\n    bl_idname = \"wm.avalon_creator\"\n    bl_label = \"Create...\"\n    _tool_name = \"creator\"\n\n    def before_window_show(self):\n        self._window.refresh()\n\n    def execute(self, context):\n        host_tools.show_publisher(tab=\"create\")\n        return {\"FINISHED\"}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchLibrary","title":"<code>LaunchLibrary</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch Library Loader.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchLibrary(LaunchQtApp):\n    \"\"\"Launch Library Loader.\"\"\"\n\n    bl_idname = \"wm.library_loader\"\n    bl_label = \"Library...\"\n    _tool_name = \"libraryloader\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchLoader","title":"<code>LaunchLoader</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch AYON Loader.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchLoader(LaunchQtApp):\n    \"\"\"Launch AYON Loader.\"\"\"\n\n    bl_idname = \"wm.avalon_loader\"\n    bl_label = \"Load...\"\n    _tool_name = \"loader\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchManager","title":"<code>LaunchManager</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch Avalon Manager.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchManager(LaunchQtApp):\n    \"\"\"Launch Avalon Manager.\"\"\"\n\n    bl_idname = \"wm.avalon_manager\"\n    bl_label = \"Manage...\"\n    _tool_name = \"sceneinventory\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchPublisher","title":"<code>LaunchPublisher</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch Avalon Publisher.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchPublisher(LaunchQtApp):\n    \"\"\"Launch Avalon Publisher.\"\"\"\n\n    bl_idname = \"wm.avalon_publisher\"\n    bl_label = \"Publish...\"\n\n    def execute(self, context):\n        host_tools.show_publisher(tab=\"publish\")\n        return {\"FINISHED\"}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchQtApp","title":"<code>LaunchQtApp</code>","text":"<p>               Bases: <code>Operator</code></p> <p>A Base class for operators to launch a Qt app.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchQtApp(bpy.types.Operator):\n    \"\"\"A Base class for operators to launch a Qt app.\"\"\"\n\n    _window = Union[QtWidgets.QDialog, ModuleType]\n    _tool_name: str = None\n    _init_args: Optional[List] = list()\n    _init_kwargs: Optional[Dict] = dict()\n    bl_idname: str = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if self.bl_idname is None:\n            raise NotImplementedError(\"Attribute `bl_idname` must be set!\")\n        print(f\"Initialising {self.bl_idname}...\")\n        GlobalClass.app = BlenderApplication.get_app()\n\n        if not bpy.app.timers.is_registered(_process_app_events):\n            bpy.app.timers.register(\n                _process_app_events,\n                persistent=True\n            )\n\n    def execute(self, context):\n        \"\"\"Execute the operator.\n\n        The child class must implement `execute()` where it only has to set\n        `self._window` to the desired Qt window and then simply run\n        `return super().execute(context)`.\n        `self._window` is expected to have a `show` method.\n        If the `show` method requires arguments, you can set `self._show_args`\n        and `self._show_kwargs`. `args` should be a list, `kwargs` a\n        dictionary.\n        \"\"\"\n\n        if self._tool_name is None:\n            if self._window is None:\n                raise AttributeError(\"`self._window` is not set.\")\n\n        else:\n            window = BlenderApplication.get_window(self.bl_idname)\n            if window is None:\n                window = host_tools.get_tool_by_name(self._tool_name)\n                BlenderApplication.store_window(self.bl_idname, window)\n            self._window = window\n\n        if not isinstance(self._window, (QtWidgets.QWidget, ModuleType)):\n            raise AttributeError(\n                \"`window` should be a `QWidget or module`. Got: {}\".format(\n                    str(type(self._window))\n                )\n            )\n\n        self.before_window_show()\n\n        def pull_to_front(window):\n            \"\"\"Pull window forward to screen.\n\n            If Window is minimized this will un-minimize, then it can be raised\n            and activated to the front.\n            \"\"\"\n            window.setWindowState(\n                (window.windowState() &amp; ~QtCore.Qt.WindowMinimized) |\n                QtCore.Qt.WindowActive\n            )\n            window.raise_()\n            window.activateWindow()\n\n        if isinstance(self._window, ModuleType):\n            self._window.show()\n            pull_to_front(self._window)\n\n            # Pull window to the front\n            window = None\n            if hasattr(self._window, \"window\"):\n                window = self._window.window\n            elif hasattr(self._window, \"_window\"):\n                window = self._window.window\n\n            if window:\n                BlenderApplication.store_window(self.bl_idname, window)\n\n        else:\n            origin_flags = self._window.windowFlags()\n            on_top_flags = origin_flags | QtCore.Qt.WindowStaysOnTopHint\n            self._window.setWindowFlags(on_top_flags)\n            self._window.show()\n            pull_to_front(self._window)\n\n            # if on_top_flags != origin_flags:\n            #     self._window.setWindowFlags(origin_flags)\n            #     self._window.show()\n\n        return {'FINISHED'}\n\n    def before_window_show(self):\n        return\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchQtApp.execute","title":"<code>execute(context)</code>","text":"<p>Execute the operator.</p> <p>The child class must implement <code>execute()</code> where it only has to set <code>self._window</code> to the desired Qt window and then simply run <code>return super().execute(context)</code>. <code>self._window</code> is expected to have a <code>show</code> method. If the <code>show</code> method requires arguments, you can set <code>self._show_args</code> and <code>self._show_kwargs</code>. <code>args</code> should be a list, <code>kwargs</code> a dictionary.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def execute(self, context):\n    \"\"\"Execute the operator.\n\n    The child class must implement `execute()` where it only has to set\n    `self._window` to the desired Qt window and then simply run\n    `return super().execute(context)`.\n    `self._window` is expected to have a `show` method.\n    If the `show` method requires arguments, you can set `self._show_args`\n    and `self._show_kwargs`. `args` should be a list, `kwargs` a\n    dictionary.\n    \"\"\"\n\n    if self._tool_name is None:\n        if self._window is None:\n            raise AttributeError(\"`self._window` is not set.\")\n\n    else:\n        window = BlenderApplication.get_window(self.bl_idname)\n        if window is None:\n            window = host_tools.get_tool_by_name(self._tool_name)\n            BlenderApplication.store_window(self.bl_idname, window)\n        self._window = window\n\n    if not isinstance(self._window, (QtWidgets.QWidget, ModuleType)):\n        raise AttributeError(\n            \"`window` should be a `QWidget or module`. Got: {}\".format(\n                str(type(self._window))\n            )\n        )\n\n    self.before_window_show()\n\n    def pull_to_front(window):\n        \"\"\"Pull window forward to screen.\n\n        If Window is minimized this will un-minimize, then it can be raised\n        and activated to the front.\n        \"\"\"\n        window.setWindowState(\n            (window.windowState() &amp; ~QtCore.Qt.WindowMinimized) |\n            QtCore.Qt.WindowActive\n        )\n        window.raise_()\n        window.activateWindow()\n\n    if isinstance(self._window, ModuleType):\n        self._window.show()\n        pull_to_front(self._window)\n\n        # Pull window to the front\n        window = None\n        if hasattr(self._window, \"window\"):\n            window = self._window.window\n        elif hasattr(self._window, \"_window\"):\n            window = self._window.window\n\n        if window:\n            BlenderApplication.store_window(self.bl_idname, window)\n\n    else:\n        origin_flags = self._window.windowFlags()\n        on_top_flags = origin_flags | QtCore.Qt.WindowStaysOnTopHint\n        self._window.setWindowFlags(on_top_flags)\n        self._window.show()\n        pull_to_front(self._window)\n\n        # if on_top_flags != origin_flags:\n        #     self._window.setWindowFlags(origin_flags)\n        #     self._window.show()\n\n    return {'FINISHED'}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchWorkFiles","title":"<code>LaunchWorkFiles</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch Avalon Work Files.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchWorkFiles(LaunchQtApp):\n    \"\"\"Launch Avalon Work Files.\"\"\"\n\n    bl_idname = \"wm.avalon_workfiles\"\n    bl_label = \"Work Files...\"\n    _tool_name = \"workfiles\"\n\n    def execute(self, context):\n        return super().execute(context)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.MainThreadItem","title":"<code>MainThreadItem</code>","text":"<p>Structure to store information about callback in main thread.</p> <p>Item should be used to execute callback in main thread which may be needed for execution of Qt objects.</p> <p>Item store callback (callable variable), arguments and keyword arguments for the callback. Item hold information about it's process.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class MainThreadItem:\n    \"\"\"Structure to store information about callback in main thread.\n\n    Item should be used to execute callback in main thread which may be needed\n    for execution of Qt objects.\n\n    Item store callback (callable variable), arguments and keyword arguments\n    for the callback. Item hold information about it's process.\n    \"\"\"\n    not_set = object()\n    sleep_time = 0.1\n\n    def __init__(self, callback, *args, **kwargs):\n        self.done = False\n        self.exception = self.not_set\n        self.result = self.not_set\n        self.callback = callback\n        self.args = args\n        self.kwargs = kwargs\n\n    def execute(self):\n        \"\"\"Execute callback and store its result.\n\n        Method must be called from main thread. Item is marked as `done`\n        when callback execution finished. Store output of callback of exception\n        information when callback raises one.\n        \"\"\"\n        print(\"Executing process in main thread\")\n        if self.done:\n            print(\"- item is already processed\")\n            return\n\n        callback = self.callback\n        args = self.args\n        kwargs = self.kwargs\n        print(\"Running callback: {}\".format(str(callback)))\n        try:\n            result = callback(*args, **kwargs)\n            self.result = result\n\n        except Exception:\n            self.exception = sys.exc_info()\n\n        finally:\n            print(\"Done\")\n            self.done = True\n\n    def wait(self):\n        \"\"\"Wait for result from main thread.\n\n        This method stops current thread until callback is executed.\n\n        Returns:\n            object: Output of callback. May be any type or object.\n\n        Raises:\n            Exception: Reraise any exception that happened during callback\n                execution.\n        \"\"\"\n        while not self.done:\n            print(self.done)\n            time.sleep(self.sleep_time)\n\n        if self.exception is self.not_set:\n            return self.result\n        raise self.exception\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.MainThreadItem.execute","title":"<code>execute()</code>","text":"<p>Execute callback and store its result.</p> <p>Method must be called from main thread. Item is marked as <code>done</code> when callback execution finished. Store output of callback of exception information when callback raises one.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def execute(self):\n    \"\"\"Execute callback and store its result.\n\n    Method must be called from main thread. Item is marked as `done`\n    when callback execution finished. Store output of callback of exception\n    information when callback raises one.\n    \"\"\"\n    print(\"Executing process in main thread\")\n    if self.done:\n        print(\"- item is already processed\")\n        return\n\n    callback = self.callback\n    args = self.args\n    kwargs = self.kwargs\n    print(\"Running callback: {}\".format(str(callback)))\n    try:\n        result = callback(*args, **kwargs)\n        self.result = result\n\n    except Exception:\n        self.exception = sys.exc_info()\n\n    finally:\n        print(\"Done\")\n        self.done = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.MainThreadItem.wait","title":"<code>wait()</code>","text":"<p>Wait for result from main thread.</p> <p>This method stops current thread until callback is executed.</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Output of callback. May be any type or object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Reraise any exception that happened during callback execution.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def wait(self):\n    \"\"\"Wait for result from main thread.\n\n    This method stops current thread until callback is executed.\n\n    Returns:\n        object: Output of callback. May be any type or object.\n\n    Raises:\n        Exception: Reraise any exception that happened during callback\n            execution.\n    \"\"\"\n    while not self.done:\n        print(self.done)\n        time.sleep(self.sleep_time)\n\n    if self.exception is self.not_set:\n        return self.result\n    raise self.exception\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.TOPBAR_MT_avalon","title":"<code>TOPBAR_MT_avalon</code>","text":"<p>               Bases: <code>Menu</code></p> <p>Avalon menu.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class TOPBAR_MT_avalon(bpy.types.Menu):\n    \"\"\"Avalon menu.\"\"\"\n\n    bl_idname = \"TOPBAR_MT_avalon\"\n    bl_label = os.environ.get(\"AYON_MENU_LABEL\")\n\n    def draw(self, context):\n        \"\"\"Draw the menu in the UI.\"\"\"\n\n        layout = self.layout\n\n        pcoll = PREVIEW_COLLECTIONS.get(\"avalon\")\n        if pcoll:\n            pyblish_menu_icon = pcoll[\"pyblish_menu_icon\"]\n            pyblish_menu_icon_id = pyblish_menu_icon.icon_id\n        else:\n            pyblish_menu_icon_id = 0\n\n        folder_path = get_current_folder_path()\n        task_name = get_current_task_name()\n        context_label = f\"{folder_path}, {task_name}\"\n        context_label_item = layout.row()\n        context_label_item.operator(\n            LaunchWorkFiles.bl_idname, text=context_label\n        )\n        context_label_item.enabled = False\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n        if project_settings[\"core\"][\"tools\"][\"ayon_menu\"].get(\n            \"version_up_current_workfile\"):\n                layout.separator()\n                layout.operator(\n                    VersionUpWorkfile.bl_idname,\n                    text=\"Version Up Workfile\"\n                )\n                wm = bpy.context.window_manager\n                keyconfigs = wm.keyconfigs\n                keymap = keyconfigs.addon.keymaps.new(name='Window', space_type='EMPTY')\n                keymap.keymap_items.new(\n                    VersionUpWorkfile.bl_idname, 'S',\n                    'PRESS', ctrl=True, alt=True\n                )\n                bpy.context.window_manager.keyconfigs.addon.keymaps.update()\n\n        layout.separator()\n        layout.operator(LaunchCreator.bl_idname, text=\"Create...\")\n        layout.operator(LaunchLoader.bl_idname, text=\"Load...\")\n        layout.operator(\n            LaunchPublisher.bl_idname,\n            text=\"Publish...\",\n            icon_value=pyblish_menu_icon_id,\n        )\n        layout.operator(LaunchManager.bl_idname, text=\"Manage...\")\n        layout.operator(LaunchLibrary.bl_idname, text=\"Library...\")\n        layout.separator()\n        layout.operator(SetFrameRange.bl_idname, text=\"Set Frame Range\")\n        layout.operator(SetResolution.bl_idname, text=\"Set Resolution\")\n        layout.operator(SetUnitScale.bl_idname, text=\"Set Unit Scale\")\n        layout.separator()\n        layout.operator(LaunchWorkFiles.bl_idname, text=\"Work Files...\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.TOPBAR_MT_avalon.draw","title":"<code>draw(context)</code>","text":"<p>Draw the menu in the UI.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def draw(self, context):\n    \"\"\"Draw the menu in the UI.\"\"\"\n\n    layout = self.layout\n\n    pcoll = PREVIEW_COLLECTIONS.get(\"avalon\")\n    if pcoll:\n        pyblish_menu_icon = pcoll[\"pyblish_menu_icon\"]\n        pyblish_menu_icon_id = pyblish_menu_icon.icon_id\n    else:\n        pyblish_menu_icon_id = 0\n\n    folder_path = get_current_folder_path()\n    task_name = get_current_task_name()\n    context_label = f\"{folder_path}, {task_name}\"\n    context_label_item = layout.row()\n    context_label_item.operator(\n        LaunchWorkFiles.bl_idname, text=context_label\n    )\n    context_label_item.enabled = False\n    project_name = get_current_project_name()\n    project_settings = get_project_settings(project_name)\n    if project_settings[\"core\"][\"tools\"][\"ayon_menu\"].get(\n        \"version_up_current_workfile\"):\n            layout.separator()\n            layout.operator(\n                VersionUpWorkfile.bl_idname,\n                text=\"Version Up Workfile\"\n            )\n            wm = bpy.context.window_manager\n            keyconfigs = wm.keyconfigs\n            keymap = keyconfigs.addon.keymaps.new(name='Window', space_type='EMPTY')\n            keymap.keymap_items.new(\n                VersionUpWorkfile.bl_idname, 'S',\n                'PRESS', ctrl=True, alt=True\n            )\n            bpy.context.window_manager.keyconfigs.addon.keymaps.update()\n\n    layout.separator()\n    layout.operator(LaunchCreator.bl_idname, text=\"Create...\")\n    layout.operator(LaunchLoader.bl_idname, text=\"Load...\")\n    layout.operator(\n        LaunchPublisher.bl_idname,\n        text=\"Publish...\",\n        icon_value=pyblish_menu_icon_id,\n    )\n    layout.operator(LaunchManager.bl_idname, text=\"Manage...\")\n    layout.operator(LaunchLibrary.bl_idname, text=\"Library...\")\n    layout.separator()\n    layout.operator(SetFrameRange.bl_idname, text=\"Set Frame Range\")\n    layout.operator(SetResolution.bl_idname, text=\"Set Resolution\")\n    layout.operator(SetUnitScale.bl_idname, text=\"Set Unit Scale\")\n    layout.separator()\n    layout.operator(LaunchWorkFiles.bl_idname, text=\"Work Files...\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.VersionUpWorkfile","title":"<code>VersionUpWorkfile</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Perform Incremental Save Workfile.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class VersionUpWorkfile(LaunchQtApp):\n    \"\"\"Perform Incremental Save Workfile.\"\"\"\n\n    bl_idname = \"wm.avalon_version_up_workfile\"\n    bl_label = \"Version Up Workfile\"\n\n    def execute(self, context):\n        version_up_current_workfile()\n        return {\"FINISHED\"}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.draw_avalon_menu","title":"<code>draw_avalon_menu(self, context)</code>","text":"<p>Draw the Avalon menu in the top bar.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def draw_avalon_menu(self, context):\n    \"\"\"Draw the Avalon menu in the top bar.\"\"\"\n\n    self.layout.menu(TOPBAR_MT_avalon.bl_idname)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.execute_function_in_main_thread","title":"<code>execute_function_in_main_thread(f)</code>","text":"<p>Decorator to move a function call into main thread items</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def execute_function_in_main_thread(f):\n    \"\"\"Decorator to move a function call into main thread items\"\"\"\n    def wrapper(*args, **kwargs):\n        mti = MainThreadItem(f, *args, **kwargs)\n        execute_in_main_thread(mti)\n    return wrapper\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.register","title":"<code>register()</code>","text":"<p>Register the operators and menu.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def register():\n    \"Register the operators and menu.\"\n\n    pcoll = bpy.utils.previews.new()\n    pyblish_icon_file = Path(__file__).parent / \"icons\" / \"pyblish-32x32.png\"\n    pcoll.load(\"pyblish_menu_icon\", str(pyblish_icon_file.absolute()), 'IMAGE')\n    PREVIEW_COLLECTIONS[\"avalon\"] = pcoll\n\n    BlenderApplication.get_app()\n    for cls in classes:\n        bpy.utils.register_class(cls)\n    bpy.types.TOPBAR_MT_editor_menus.append(draw_avalon_menu)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.unregister","title":"<code>unregister()</code>","text":"<p>Unregister the operators and menu.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def unregister():\n    \"\"\"Unregister the operators and menu.\"\"\"\n\n    pcoll = PREVIEW_COLLECTIONS.pop(\"avalon\")\n    bpy.utils.previews.remove(pcoll)\n    bpy.types.TOPBAR_MT_editor_menus.remove(draw_avalon_menu)\n    for cls in reversed(classes):\n        bpy.utils.unregister_class(cls)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost","title":"<code>BlenderHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>IPublishHost</code>, <code>ILoadHost</code></p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>class BlenderHost(HostBase, IWorkfileHost, IPublishHost, ILoadHost):\n    name = \"blender\"\n\n    def install(self):\n        \"\"\"Override install method from HostBase.\n        Install Blender host functionality.\"\"\"\n        install()\n\n    def get_containers(self) -&gt; Iterator:\n        \"\"\"List containers from active Blender scene.\"\"\"\n        return ls()\n\n    def get_workfile_extensions(self) -&gt; List[str]:\n        \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n        Get workfile possible extensions.\n\n        Returns:\n            List[str]: Workfile extensions.\n        \"\"\"\n        return file_extensions()\n\n    def save_workfile(self, dst_path: str = None):\n        \"\"\"Override save_workfile method from IWorkfileHost.\n        Save currently opened workfile.\n\n        Args:\n            dst_path (str): Where the current scene should be saved. Or use\n                current path if `None` is passed.\n        \"\"\"\n        save_file(dst_path if dst_path else bpy.data.filepath)\n\n    def open_workfile(self, filepath: str):\n        \"\"\"Override open_workfile method from IWorkfileHost.\n        Open workfile at specified filepath in the host.\n\n        Args:\n            filepath (str): Path to workfile.\n        \"\"\"\n        open_file(filepath)\n\n    def get_current_workfile(self) -&gt; str:\n        \"\"\"Override get_current_workfile method from IWorkfileHost.\n        Retrieve currently opened workfile path.\n\n        Returns:\n            str: Path to currently opened workfile.\n        \"\"\"\n        return current_file()\n\n    def workfile_has_unsaved_changes(self) -&gt; bool:\n        \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n        Returns True if opened workfile has no unsaved changes.\n\n        Returns:\n            bool: True if scene is saved and False if it has unsaved\n                modifications.\n        \"\"\"\n        return has_unsaved_changes()\n\n    def work_root(self, session) -&gt; str:\n        \"\"\"Override work_root method from IWorkfileHost.\n        Modify workdir per host.\n\n        Args:\n            session (dict): Session context data.\n\n        Returns:\n            str: Path to new workdir.\n        \"\"\"\n        return work_root(session)\n\n    def get_context_data(self) -&gt; dict:\n        \"\"\"Override abstract method from IPublishHost.\n        Get global data related to creation-publishing from workfile.\n\n        Returns:\n            dict: Context data stored using 'update_context_data'.\n        \"\"\"\n        property = bpy.context.scene.get(AVALON_PROPERTY)\n        if property:\n            return property.to_dict()\n        return {}\n\n    def update_context_data(self, data: dict, changes: dict):\n        \"\"\"Override abstract method from IPublishHost.\n        Store global context data to workfile.\n\n        Args:\n            data (dict): New data as are.\n            changes (dict): Only data that has been changed. Each value has\n                tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n        \"\"\"\n        bpy.context.scene[AVALON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_containers","title":"<code>get_containers()</code>","text":"<p>List containers from active Blender scene.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_containers(self) -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\"\"\"\n    return ls()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Override abstract method from IPublishHost. Get global data related to creation-publishing from workfile.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data stored using 'update_context_data'.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_context_data(self) -&gt; dict:\n    \"\"\"Override abstract method from IPublishHost.\n    Get global data related to creation-publishing from workfile.\n\n    Returns:\n        dict: Context data stored using 'update_context_data'.\n    \"\"\"\n    property = bpy.context.scene.get(AVALON_PROPERTY)\n    if property:\n        return property.to_dict()\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_current_workfile","title":"<code>get_current_workfile()</code>","text":"<p>Override get_current_workfile method from IWorkfileHost. Retrieve currently opened workfile path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to currently opened workfile.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_current_workfile(self) -&gt; str:\n    \"\"\"Override get_current_workfile method from IWorkfileHost.\n    Retrieve currently opened workfile path.\n\n    Returns:\n        str: Path to currently opened workfile.\n    \"\"\"\n    return current_file()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Override get_workfile_extensions method from IWorkfileHost. Get workfile possible extensions.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Workfile extensions.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_workfile_extensions(self) -&gt; List[str]:\n    \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n    Get workfile possible extensions.\n\n    Returns:\n        List[str]: Workfile extensions.\n    \"\"\"\n    return file_extensions()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.install","title":"<code>install()</code>","text":"<p>Override install method from HostBase. Install Blender host functionality.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Override install method from HostBase.\n    Install Blender host functionality.\"\"\"\n    install()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.open_workfile","title":"<code>open_workfile(filepath)</code>","text":"<p>Override open_workfile method from IWorkfileHost. Open workfile at specified filepath in the host.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to workfile.</p> required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def open_workfile(self, filepath: str):\n    \"\"\"Override open_workfile method from IWorkfileHost.\n    Open workfile at specified filepath in the host.\n\n    Args:\n        filepath (str): Path to workfile.\n    \"\"\"\n    open_file(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.save_workfile","title":"<code>save_workfile(dst_path=None)</code>","text":"<p>Override save_workfile method from IWorkfileHost. Save currently opened workfile.</p> <p>Parameters:</p> Name Type Description Default <code>dst_path</code> <code>str</code> <p>Where the current scene should be saved. Or use current path if <code>None</code> is passed.</p> <code>None</code> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def save_workfile(self, dst_path: str = None):\n    \"\"\"Override save_workfile method from IWorkfileHost.\n    Save currently opened workfile.\n\n    Args:\n        dst_path (str): Where the current scene should be saved. Or use\n            current path if `None` is passed.\n    \"\"\"\n    save_file(dst_path if dst_path else bpy.data.filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Override abstract method from IPublishHost. Store global context data to workfile.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>New data as are.</p> required <code>changes</code> <code>dict</code> <p>Only data that has been changed. Each value has tuple with '(, )' value. required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def update_context_data(self, data: dict, changes: dict):\n    \"\"\"Override abstract method from IPublishHost.\n    Store global context data to workfile.\n\n    Args:\n        data (dict): New data as are.\n        changes (dict): Only data that has been changed. Each value has\n            tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n    \"\"\"\n    bpy.context.scene[AVALON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.work_root","title":"<code>work_root(session)</code>","text":"<p>Override work_root method from IWorkfileHost. Modify workdir per host.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict</code> <p>Session context data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to new workdir.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def work_root(self, session) -&gt; str:\n    \"\"\"Override work_root method from IWorkfileHost.\n    Modify workdir per host.\n\n    Args:\n        session (dict): Session context data.\n\n    Returns:\n        str: Path to new workdir.\n    \"\"\"\n    return work_root(session)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.workfile_has_unsaved_changes","title":"<code>workfile_has_unsaved_changes()</code>","text":"<p>Override wokfile_has_unsaved_changes method from IWorkfileHost. Returns True if opened workfile has no unsaved changes.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if scene is saved and False if it has unsaved modifications.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def workfile_has_unsaved_changes(self) -&gt; bool:\n    \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n    Returns True if opened workfile has no unsaved changes.\n\n    Returns:\n        bool: True if scene is saved and False if it has unsaved\n            modifications.\n    \"\"\"\n    return has_unsaved_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.add_to_avalon_container","title":"<code>add_to_avalon_container(container)</code>","text":"<p>Add the container to the Avalon container.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def add_to_avalon_container(container: bpy.types.Collection):\n    \"\"\"Add the container to the Avalon container.\"\"\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n\n        # Link the container to the scene so it's easily visible to the artist\n        # and can be managed easily. Otherwise it's only found in \"Blender\n        # File\" view and it will be removed by Blenders garbage collection,\n        # unless you set a 'fake user'.\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    avalon_container.children.link(container)\n\n    # Disable Avalon containers for the view layers.\n    for view_layer in bpy.context.scene.view_layers:\n        for child in view_layer.layer_collection.children:\n            if child.collection == avalon_container:\n                child.exclude = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='CON')</code>","text":"<p>Bundle <code>nodes</code> into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>List</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>Dict</code> <p>Asset information</p> required <code>loader</code> <code>Optional[str]</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Type Description <code>Collection</code> <p>The container assembly</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def containerise(name: str,\n                 namespace: str,\n                 nodes: List,\n                 context: Dict,\n                 loader: Optional[str] = None,\n                 suffix: Optional[str] = \"CON\") -&gt; bpy.types.Collection:\n    \"\"\"Bundle `nodes` into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name: Name of resulting assembly\n        namespace: Namespace under which to host container\n        nodes: Long names of nodes to containerise\n        context: Asset information\n        loader: Name of loader used to produce this container.\n        suffix: Suffix of container, defaults to `_CON`.\n\n    Returns:\n        The container assembly\n\n    \"\"\"\n\n    node_name = f\"{context['folder']['name']}_{name}\"\n    if namespace:\n        node_name = f\"{namespace}:{node_name}\"\n    if suffix:\n        node_name = f\"{node_name}_{suffix}\"\n    container = bpy.data.collections.new(name=node_name)\n    # Link the children nodes\n    for obj in nodes:\n        container.objects.link(obj)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    }\n\n    metadata_update(container, data)\n    add_to_avalon_container(container)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.containerise_existing","title":"<code>containerise_existing(container, name, namespace, context, loader=None, suffix='CON')</code>","text":"<p>Imprint or update container with metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>Dict</code> <p>Asset information</p> required <code>loader</code> <code>Optional[str]</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Type Description <code>Collection</code> <p>The container assembly</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def containerise_existing(\n        container: bpy.types.Collection,\n        name: str,\n        namespace: str,\n        context: Dict,\n        loader: Optional[str] = None,\n        suffix: Optional[str] = \"CON\") -&gt; bpy.types.Collection:\n    \"\"\"Imprint or update container with metadata.\n\n    Arguments:\n        name: Name of resulting assembly\n        namespace: Namespace under which to host container\n        context: Asset information\n        loader: Name of loader used to produce this container.\n        suffix: Suffix of container, defaults to `_CON`.\n\n    Returns:\n        The container assembly\n    \"\"\"\n\n    node_name = container.name\n    if suffix:\n        node_name = f\"{node_name}_{suffix}\"\n    container.name = node_name\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    metadata_update(container, data)\n    add_to_avalon_container(container)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.get_frame_range","title":"<code>get_frame_range(task_entity=None)</code>","text":"<p>Get the task entity's frame range and handles</p> <p>Parameters:</p> Name Type Description Default <code>task_entity</code> <code>Optional[dict]</code> <p>Task Entity. When not provided defaults to current context task.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict[str, int], None]</code> <p>Union[Dict[str, int], None]: Dictionary with frame start, frame end, handle start, handle end.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_frame_range(task_entity=None) -&gt; Union[Dict[str, int], None]:\n    \"\"\"Get the task entity's frame range and handles\n\n    Args:\n        task_entity (Optional[dict]): Task Entity.\n            When not provided defaults to current context task.\n\n    Returns:\n        Union[Dict[str, int], None]: Dictionary with\n            frame start, frame end, handle start, handle end.\n    \"\"\"\n    # Set frame start/end\n    if task_entity is None:\n        task_entity = get_current_task_entity(fields={\"attrib\"})\n    task_attributes = task_entity[\"attrib\"]\n    frame_start = int(task_attributes[\"frameStart\"])\n    frame_end = int(task_attributes[\"frameEnd\"])\n    handle_start = int(task_attributes[\"handleStart\"])\n    handle_end = int(task_attributes[\"handleEnd\"])\n    frame_start_handle = frame_start - handle_start\n    frame_end_handle = frame_end + handle_end\n\n    return {\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"frameStartHandle\": frame_start_handle,\n        \"frameEndHandle\": frame_end_handle,\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.install","title":"<code>install()</code>","text":"<p>Install Blender configuration for Avalon.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install():\n    \"\"\"Install Blender configuration for Avalon.\"\"\"\n    sys.excepthook = pype_excepthook_handler\n\n    pyblish.api.register_host(\"blender\")\n    pyblish.api.register_plugin_path(str(PUBLISH_PATH))\n\n    register_loader_plugin_path(str(LOAD_PATH))\n    register_creator_plugin_path(str(CREATE_PATH))\n\n    lib.append_user_scripts()\n    lib.set_app_templates_path()\n\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"open\", on_open)\n\n    _register_callbacks()\n    _register_events()\n\n    if not IS_HEADLESS:\n        ops.register()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List containers from active Blender scene.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Blender; once loaded they are called containers.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def ls() -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\n\n    This is the host-equivalent of api.ls(), but instead of listing assets on\n    disk, it lists assets already loaded in Blender; once loaded they are\n    called containers.\n    \"\"\"\n    container_ids = {\n        AYON_CONTAINER_ID,\n        # Backwards compatibility\n        AVALON_CONTAINER_ID\n    }\n\n    for id_type in container_ids:\n        for container in lib.lsattr(\"id\", id_type):\n            yield parse_container(container)\n\n    # Compositor nodes are not in `bpy.data` that `lib.lsattr` looks in.\n    node_tree = bpy.context.scene.node_tree\n    if node_tree:\n        for node in node_tree.nodes:\n            if not node.get(AVALON_PROPERTY):\n                continue\n\n            if node.get(AVALON_PROPERTY).get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(node)\n\n    # Shader nodes are not available in a way that `lib.lsattr` can find.\n    for material in bpy.data.materials:\n        material_node_tree = material.node_tree\n        if not material_node_tree:\n            continue\n\n        for shader_node in material_node_tree.nodes:\n            if not shader_node.get(AVALON_PROPERTY):\n                continue\n\n            if shader_node.get(AVALON_PROPERTY).get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(shader_node)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.metadata_update","title":"<code>metadata_update(node, data)</code>","text":"<p>Imprint the node with metadata.</p> <p>Existing metadata will be updated.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def metadata_update(node: bpy.types.bpy_struct_meta_idprop, data: Dict):\n    \"\"\"Imprint the node with metadata.\n\n    Existing metadata will be updated.\n    \"\"\"\n\n    if not node.get(AVALON_PROPERTY):\n        node[AVALON_PROPERTY] = dict()\n    for key, value in data.items():\n        if value is None:\n            continue\n        node[AVALON_PROPERTY][key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.parse_container","title":"<code>parse_container(container, validate=True)</code>","text":"<p>Return the container node's full container data.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Collection</code> <p>A container node name.</p> required <code>validate</code> <code>bool</code> <p>turn the validation for the container on or off</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict</code> <p>The container schema data for this container node.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def parse_container(container: bpy.types.Collection,\n                    validate: bool = True) -&gt; Dict:\n    \"\"\"Return the container node's full container data.\n\n    Args:\n        container: A container node name.\n        validate: turn the validation for the container on or off\n\n    Returns:\n        The container schema data for this container node.\n\n    \"\"\"\n\n    data = lib.read(container)\n\n    # Append transient data\n    data[\"objectName\"] = container.name\n    data[\"node\"] = container  # store parsed object for easy access in loader\n\n    if validate:\n        schema.validate(data)\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.publish","title":"<code>publish()</code>","text":"<p>Shorthand to publish from within host.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def publish():\n    \"\"\"Shorthand to publish from within host.\"\"\"\n\n    return pyblish.util.publish()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall Blender configuration for Avalon.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def uninstall():\n    \"\"\"Uninstall Blender configuration for Avalon.\"\"\"\n    sys.excepthook = ORIGINAL_EXCEPTHOOK\n\n    pyblish.api.deregister_host(\"blender\")\n    pyblish.api.deregister_plugin_path(str(PUBLISH_PATH))\n\n    deregister_loader_plugin_path(str(LOAD_PATH))\n    deregister_creator_plugin_path(str(CREATE_PATH))\n\n    if not IS_HEADLESS:\n        ops.unregister()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html","title":"plugin","text":"<p>Shared functionality for pipeline plugins for Blender.</p>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator","title":"<code>BlenderCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Base class for Blender Creator plug-ins.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>class BlenderCreator(Creator):\n    \"\"\"Base class for Blender Creator plug-ins.\"\"\"\n    defaults = ['Main']\n\n    settings_category = \"blender\"\n    create_as_asset_group = False\n\n    @staticmethod\n    def cache_instance_data(shared_data):\n        \"\"\"Cache instances for Creators shared data.\n\n        Create `blender_cached_instances` key when needed in shared data and\n        fill it with all collected instances from the scene under its\n        respective creator identifiers.\n\n        If legacy instances are detected in the scene, create\n        `blender_cached_legacy_instances` key and fill it with\n        all legacy products from this family as a value.  # key or value?\n\n        Args:\n            shared_data(Dict[str, Any]): Shared data.\n\n        \"\"\"\n        if not shared_data.get('blender_cached_instances'):\n            cache = {}\n            cache_legacy = {}\n\n            avalon_instances = bpy.data.collections.get(AVALON_INSTANCES)\n            avalon_instance_objs = (\n                avalon_instances.objects if avalon_instances else []\n            )\n\n            for obj_or_col in itertools.chain(\n                    avalon_instance_objs,\n                    bpy.data.collections\n            ):\n                avalon_prop = obj_or_col.get(AVALON_PROPERTY, {})\n                if not avalon_prop:\n                    continue\n\n                if avalon_prop.get('id') not in {\n                    AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n                }:\n                    continue\n\n                creator_id = avalon_prop.get('creator_identifier')\n                if creator_id:\n                    # Creator instance\n                    cache.setdefault(creator_id, []).append(obj_or_col)\n                else:\n                    family = avalon_prop.get('family')\n                    if family:\n                        # Legacy creator instance\n                        cache_legacy.setdefault(family, []).append(obj_or_col)\n\n            shared_data[\"blender_cached_instances\"] = cache\n            shared_data[\"blender_cached_legacy_instances\"] = cache_legacy\n\n        return shared_data\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        \"\"\"Override abstract method from Creator.\n        Create new instance and store it.\n\n        Args:\n            product_name (str): Product name of created instance.\n            instance_data (dict): Instance base data.\n            pre_create_data (dict): Data based on pre creation attributes.\n                Those may affect how creator works.\n        \"\"\"\n        # Get Instance Container or create it if it does not exist\n        instances = bpy.data.collections.get(AVALON_INSTANCES)\n        if not instances:\n            instances = bpy.data.collections.new(name=AVALON_INSTANCES)\n            bpy.context.scene.collection.children.link(instances)\n\n        # Create asset group\n        folder_name = instance_data[\"folderPath\"].split(\"/\")[-1]\n\n        name = prepare_scene_name(folder_name, product_name)\n        if self.create_as_asset_group:\n            # Create instance as empty\n            instance_node = bpy.data.objects.new(name=name, object_data=None)\n            instance_node.empty_display_type = 'SINGLE_ARROW'\n            instances.objects.link(instance_node)\n        else:\n            # Create instance collection\n            instance_node = bpy.data.collections.new(name=name)\n            instances.children.link(instance_node)\n\n        self.set_instance_data(product_name, instance_data)\n\n        instance = CreatedInstance(\n            self.product_type, product_name, instance_data, self\n        )\n        instance.transient_data[\"instance_node\"] = instance_node\n        self._add_instance_to_context(instance)\n\n        imprint(instance_node, instance_data)\n\n        return instance_node\n\n    def collect_instances(self):\n        \"\"\"Override abstract method from BlenderCreator.\n        Collect existing instances related to this creator plugin.\"\"\"\n\n        # Cache instances in shared data\n        self.cache_instance_data(self.collection_shared_data)\n\n        # Get cached instances\n        cached_instances = self.collection_shared_data.get(\n            \"blender_cached_instances\"\n        )\n        if not cached_instances:\n            return\n\n        # Process only instances that were created by this creator\n        for instance_node in cached_instances.get(self.identifier, []):\n            property = instance_node.get(AVALON_PROPERTY)\n            # Create instance object from existing data\n            instance = CreatedInstance.from_existing(\n                instance_data=property.to_dict(),\n                creator=self\n            )\n            instance.transient_data[\"instance_node\"] = instance_node\n\n            # Add instance to create context\n            self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        \"\"\"Override abstract method from BlenderCreator.\n        Store changes of existing instances so they can be recollected.\n\n        Args:\n            update_list(List[UpdateData]): Changed instances\n                and their changes, as a list of tuples.\n        \"\"\"\n\n        for created_instance, changes in update_list:\n            data = created_instance.data_to_store()\n            node = created_instance.transient_data[\"instance_node\"]\n            if not node:\n                # We can't update if we don't know the node\n                self.log.error(\n                    f\"Unable to update instance {created_instance} \"\n                    f\"without instance node.\"\n                )\n                return\n\n            # Rename the instance node in the scene if product\n            #   or folder changed.\n            # Do not rename the instance if the family is workfile, as the\n            # workfile instance is included in the AVALON_CONTAINER collection.\n            if (\n                \"productName\" in changes.changed_keys\n                or \"folderPath\" in changes.changed_keys\n            ) and created_instance.product_type != \"workfile\":\n                folder_name = data[\"folderPath\"].split(\"/\")[-1]\n                name = prepare_scene_name(\n                    folder_name, data[\"productName\"]\n                )\n                node.name = name\n\n            imprint(node, data)\n\n    def remove_instances(self, instances: List[CreatedInstance]):\n\n        for instance in instances:\n            node = instance.transient_data[\"instance_node\"]\n\n            if isinstance(node, bpy.types.Collection):\n                for children in node.children_recursive:\n                    if isinstance(children, bpy.types.Collection):\n                        bpy.data.collections.remove(children)\n                    else:\n                        bpy.data.objects.remove(children)\n\n                bpy.data.collections.remove(node)\n            elif isinstance(node, bpy.types.Object):\n                bpy.data.objects.remove(node)\n\n            self._remove_instance_from_context(instance)\n\n    def set_instance_data(\n        self,\n        product_name: str,\n        instance_data: dict\n    ):\n        \"\"\"Fill instance data with required items.\n\n        Args:\n            product_name(str): Product name of created instance.\n            instance_data(dict): Instance base data.\n            instance_node(bpy.types.ID): Instance node in blender scene.\n        \"\"\"\n        if not instance_data:\n            instance_data = {}\n\n        instance_data.update(\n            {\n                \"id\": AVALON_INSTANCE_ID,\n                \"creator_identifier\": self.identifier,\n                \"productName\": product_name,\n            }\n        )\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\"use_selection\",\n                    label=\"Use selection\",\n                    default=True)\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>  <code>staticmethod</code>","text":"<p>Cache instances for Creators shared data.</p> <p>Create <code>blender_cached_instances</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>If legacy instances are detected in the scene, create <code>blender_cached_legacy_instances</code> key and fill it with all legacy products from this family as a value.  # key or value?</p> <p>Parameters:</p> Name Type Description Default <code>shared_data(Dict[str,</code> <code>Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>@staticmethod\ndef cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators shared data.\n\n    Create `blender_cached_instances` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    If legacy instances are detected in the scene, create\n    `blender_cached_legacy_instances` key and fill it with\n    all legacy products from this family as a value.  # key or value?\n\n    Args:\n        shared_data(Dict[str, Any]): Shared data.\n\n    \"\"\"\n    if not shared_data.get('blender_cached_instances'):\n        cache = {}\n        cache_legacy = {}\n\n        avalon_instances = bpy.data.collections.get(AVALON_INSTANCES)\n        avalon_instance_objs = (\n            avalon_instances.objects if avalon_instances else []\n        )\n\n        for obj_or_col in itertools.chain(\n                avalon_instance_objs,\n                bpy.data.collections\n        ):\n            avalon_prop = obj_or_col.get(AVALON_PROPERTY, {})\n            if not avalon_prop:\n                continue\n\n            if avalon_prop.get('id') not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                continue\n\n            creator_id = avalon_prop.get('creator_identifier')\n            if creator_id:\n                # Creator instance\n                cache.setdefault(creator_id, []).append(obj_or_col)\n            else:\n                family = avalon_prop.get('family')\n                if family:\n                    # Legacy creator instance\n                    cache_legacy.setdefault(family, []).append(obj_or_col)\n\n        shared_data[\"blender_cached_instances\"] = cache\n        shared_data[\"blender_cached_legacy_instances\"] = cache_legacy\n\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Override abstract method from BlenderCreator. Collect existing instances related to this creator plugin.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Override abstract method from BlenderCreator.\n    Collect existing instances related to this creator plugin.\"\"\"\n\n    # Cache instances in shared data\n    self.cache_instance_data(self.collection_shared_data)\n\n    # Get cached instances\n    cached_instances = self.collection_shared_data.get(\n        \"blender_cached_instances\"\n    )\n    if not cached_instances:\n        return\n\n    # Process only instances that were created by this creator\n    for instance_node in cached_instances.get(self.identifier, []):\n        property = instance_node.get(AVALON_PROPERTY)\n        # Create instance object from existing data\n        instance = CreatedInstance.from_existing(\n            instance_data=property.to_dict(),\n            creator=self\n        )\n        instance.transient_data[\"instance_node\"] = instance_node\n\n        # Add instance to create context\n        self._add_instance_to_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Override abstract method from Creator. Create new instance and store it.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Product name of created instance.</p> required <code>instance_data</code> <code>dict</code> <p>Instance base data.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data based on pre creation attributes. Those may affect how creator works.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def create(\n    self, product_name: str, instance_data: dict, pre_create_data: dict\n):\n    \"\"\"Override abstract method from Creator.\n    Create new instance and store it.\n\n    Args:\n        product_name (str): Product name of created instance.\n        instance_data (dict): Instance base data.\n        pre_create_data (dict): Data based on pre creation attributes.\n            Those may affect how creator works.\n    \"\"\"\n    # Get Instance Container or create it if it does not exist\n    instances = bpy.data.collections.get(AVALON_INSTANCES)\n    if not instances:\n        instances = bpy.data.collections.new(name=AVALON_INSTANCES)\n        bpy.context.scene.collection.children.link(instances)\n\n    # Create asset group\n    folder_name = instance_data[\"folderPath\"].split(\"/\")[-1]\n\n    name = prepare_scene_name(folder_name, product_name)\n    if self.create_as_asset_group:\n        # Create instance as empty\n        instance_node = bpy.data.objects.new(name=name, object_data=None)\n        instance_node.empty_display_type = 'SINGLE_ARROW'\n        instances.objects.link(instance_node)\n    else:\n        # Create instance collection\n        instance_node = bpy.data.collections.new(name=name)\n        instances.children.link(instance_node)\n\n    self.set_instance_data(product_name, instance_data)\n\n    instance = CreatedInstance(\n        self.product_type, product_name, instance_data, self\n    )\n    instance.transient_data[\"instance_node\"] = instance_node\n    self._add_instance_to_context(instance)\n\n    imprint(instance_node, instance_data)\n\n    return instance_node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.set_instance_data","title":"<code>set_instance_data(product_name, instance_data)</code>","text":"<p>Fill instance data with required items.</p> <p>Parameters:</p> Name Type Description Default <code>product_name(str)</code> <p>Product name of created instance.</p> required <code>instance_data(dict)</code> <p>Instance base data.</p> required <code>instance_node(bpy.types.ID)</code> <p>Instance node in blender scene.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def set_instance_data(\n    self,\n    product_name: str,\n    instance_data: dict\n):\n    \"\"\"Fill instance data with required items.\n\n    Args:\n        product_name(str): Product name of created instance.\n        instance_data(dict): Instance base data.\n        instance_node(bpy.types.ID): Instance node in blender scene.\n    \"\"\"\n    if not instance_data:\n        instance_data = {}\n\n    instance_data.update(\n        {\n            \"id\": AVALON_INSTANCE_ID,\n            \"creator_identifier\": self.identifier,\n            \"productName\": product_name,\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Override abstract method from BlenderCreator. Store changes of existing instances so they can be recollected.</p> <p>Parameters:</p> Name Type Description Default <code>update_list(List[UpdateData])</code> <p>Changed instances and their changes, as a list of tuples.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Override abstract method from BlenderCreator.\n    Store changes of existing instances so they can be recollected.\n\n    Args:\n        update_list(List[UpdateData]): Changed instances\n            and their changes, as a list of tuples.\n    \"\"\"\n\n    for created_instance, changes in update_list:\n        data = created_instance.data_to_store()\n        node = created_instance.transient_data[\"instance_node\"]\n        if not node:\n            # We can't update if we don't know the node\n            self.log.error(\n                f\"Unable to update instance {created_instance} \"\n                f\"without instance node.\"\n            )\n            return\n\n        # Rename the instance node in the scene if product\n        #   or folder changed.\n        # Do not rename the instance if the family is workfile, as the\n        # workfile instance is included in the AVALON_CONTAINER collection.\n        if (\n            \"productName\" in changes.changed_keys\n            or \"folderPath\" in changes.changed_keys\n        ) and created_instance.product_type != \"workfile\":\n            folder_name = data[\"folderPath\"].split(\"/\")[-1]\n            name = prepare_scene_name(\n                folder_name, data[\"productName\"]\n            )\n            node.name = name\n\n        imprint(node, data)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader","title":"<code>BlenderLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic AssetLoader for Blender</p> <p>This will implement the basic logic for linking/appending assets into another Blender scene.</p> <p>The <code>update</code> method should be implemented by a sub-class, because it's different for different types (e.g. model, rig, animation, etc.).</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>class BlenderLoader(LoaderPlugin):\n    \"\"\"A basic AssetLoader for Blender\n\n    This will implement the basic logic for linking/appending assets\n    into another Blender scene.\n\n    The `update` method should be implemented by a sub-class, because\n    it's different for different types (e.g. model, rig, animation,\n    etc.).\n    \"\"\"\n    settings_category = \"blender\"\n\n    @staticmethod\n    def _get_instance_empty(instance_name: str, nodes: List) -&gt; Optional[bpy.types.Object]:\n        \"\"\"Get the 'instance empty' that holds the collection instance.\"\"\"\n        for node in nodes:\n            if not isinstance(node, bpy.types.Object):\n                continue\n            if (node.type == 'EMPTY' and node.instance_type == 'COLLECTION'\n                    and node.instance_collection and node.name == instance_name):\n                return node\n        return None\n\n    @staticmethod\n    def _get_instance_collection(instance_name: str, nodes: List) -&gt; Optional[bpy.types.Collection]:\n        \"\"\"Get the 'instance collection' (container) for this asset.\"\"\"\n        for node in nodes:\n            if not isinstance(node, bpy.types.Collection):\n                continue\n            if node.name == instance_name:\n                return node\n        return None\n\n    @staticmethod\n    def _get_library_from_container(container: bpy.types.Collection) -&gt; bpy.types.Library:\n        \"\"\"Find the library file from the container.\n\n        It traverses the objects from this collection, checks if there is only\n        1 library from which the objects come from and returns the library.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        assert not container.children, \"Nested collections are not supported.\"\n        assert container.objects, \"The collection doesn't contain any objects.\"\n        libraries = set()\n        for obj in container.objects:\n            assert obj.library, f\"'{obj.name}' is not linked.\"\n            libraries.add(obj.library)\n\n        assert len(\n            libraries) == 1, \"'{container.name}' contains objects from more then 1 library.\"\n\n        return list(libraries)[0]\n\n    def process_asset(self,\n                      context: dict,\n                      name: str,\n                      namespace: Optional[str] = None,\n                      options: Optional[Dict] = None):\n        \"\"\"Must be implemented by a sub-class\"\"\"\n        raise NotImplementedError(\"Must be implemented by a sub-class\")\n\n    def load(self,\n             context: dict,\n             name: Optional[str] = None,\n             namespace: Optional[str] = None,\n             options: Optional[Dict] = None) -&gt; Optional[bpy.types.Collection]:\n        \"\"\" Run the loader on Blender main thread\"\"\"\n        mti = MainThreadItem(self._load, context, name, namespace, options)\n        execute_in_main_thread(mti)\n\n    def _load(self,\n              context: dict,\n              name: Optional[str] = None,\n              namespace: Optional[str] = None,\n              options: Optional[Dict] = None\n    ) -&gt; Optional[bpy.types.Collection]:\n        \"\"\"Load asset via database\n\n        Arguments:\n            context: Full parenthood of representation to load\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            options: Additional settings dictionary\n        \"\"\"\n        # TODO: make it possible to add the asset several times by\n        # just re-using the collection\n        filepath = self.filepath_from_context(context)\n        assert Path(filepath).exists(), f\"{filepath} doesn't exist.\"\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        unique_number = get_unique_number(\n            folder_name, product_name\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n        name = name or prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n\n        nodes = self.process_asset(\n            context=context,\n            name=name,\n            namespace=namespace,\n            options=options,\n        )\n\n        # Only containerise if anything was loaded by the Loader.\n        if not nodes:\n            return None\n\n        # Only containerise if it's not already a collection from a .blend file.\n        # representation = context[\"representation\"][\"name\"]\n        # if representation != \"blend\":\n        #     from ayon_blender.api.pipeline import containerise\n        #     return containerise(\n        #         name=name,\n        #         namespace=namespace,\n        #         nodes=nodes,\n        #         context=context,\n        #         loader=self.__class__.__name__,\n        #     )\n\n        # folder_name = context[\"folder\"][\"name\"]\n        # product_name = context[\"product\"][\"name\"]\n        # instance_name = prepare_scene_name(\n        #     folder_name, product_name, unique_number\n        # ) + '_CON'\n\n        # return self._get_instance_collection(instance_name, nodes)\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Must be implemented by a sub-class\"\"\"\n        raise NotImplementedError(\"Must be implemented by a sub-class\")\n\n    def update(self, container: Dict, context: Dict):\n        \"\"\" Run the update on Blender main thread\"\"\"\n        mti = MainThreadItem(self.exec_update, container, context)\n        execute_in_main_thread(mti)\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Must be implemented by a sub-class\"\"\"\n        raise NotImplementedError(\"Must be implemented by a sub-class\")\n\n    def remove(self, container: Dict) -&gt; bool:\n        \"\"\" Run the remove on Blender main thread\"\"\"\n        mti = MainThreadItem(self.exec_remove, container)\n        execute_in_main_thread(mti)\n\n    def switch(self, container, context):\n        # Support switch in scene inventory\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Must be implemented by a sub-class</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Must be implemented by a sub-class\"\"\"\n    raise NotImplementedError(\"Must be implemented by a sub-class\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Must be implemented by a sub-class</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Must be implemented by a sub-class\"\"\"\n    raise NotImplementedError(\"Must be implemented by a sub-class\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Run the loader on Blender main thread</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def load(self,\n         context: dict,\n         name: Optional[str] = None,\n         namespace: Optional[str] = None,\n         options: Optional[Dict] = None) -&gt; Optional[bpy.types.Collection]:\n    \"\"\" Run the loader on Blender main thread\"\"\"\n    mti = MainThreadItem(self._load, context, name, namespace, options)\n    execute_in_main_thread(mti)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Must be implemented by a sub-class</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def process_asset(self,\n                  context: dict,\n                  name: str,\n                  namespace: Optional[str] = None,\n                  options: Optional[Dict] = None):\n    \"\"\"Must be implemented by a sub-class\"\"\"\n    raise NotImplementedError(\"Must be implemented by a sub-class\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.remove","title":"<code>remove(container)</code>","text":"<p>Run the remove on Blender main thread</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def remove(self, container: Dict) -&gt; bool:\n    \"\"\" Run the remove on Blender main thread\"\"\"\n    mti = MainThreadItem(self.exec_remove, container)\n    execute_in_main_thread(mti)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.update","title":"<code>update(container, context)</code>","text":"<p>Run the update on Blender main thread</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def update(self, container: Dict, context: Dict):\n    \"\"\" Run the update on Blender main thread\"\"\"\n    mti = MainThreadItem(self.exec_update, container, context)\n    execute_in_main_thread(mti)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.create_blender_context","title":"<code>create_blender_context(active=None, selected=None, window=None)</code>","text":"<p>Create a new Blender context. If an object is passed as parameter, it is set as selected and active.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def create_blender_context(active: Optional[bpy.types.Object] = None,\n                           selected: Optional[bpy.types.Object] = None,\n                           window: Optional[bpy.types.Window] = None):\n    \"\"\"Create a new Blender context. If an object is passed as\n    parameter, it is set as selected and active.\n    \"\"\"\n\n    if not isinstance(selected, list):\n        selected = [selected]\n\n    override_context = bpy.context.copy()\n\n    windows = [window] if window else bpy.context.window_manager.windows\n\n    for win in windows:\n        for area in win.screen.areas:\n            if area.type == 'VIEW_3D':\n                for region in area.regions:\n                    if region.type == 'WINDOW':\n                        override_context['window'] = win\n                        override_context['screen'] = win.screen\n                        override_context['area'] = area\n                        override_context['region'] = region\n                        override_context['scene'] = bpy.context.scene\n                        override_context['active_object'] = active\n                        override_context['selected_objects'] = selected\n                        return override_context\n    raise Exception(\"Could not create a custom Blender context.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.deselect_all","title":"<code>deselect_all()</code>","text":"<p>Deselect all objects in the scene.</p> <p>Blender gives context error if trying to deselect object that it isn't in object mode.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def deselect_all():\n    \"\"\"Deselect all objects in the scene.\n\n    Blender gives context error if trying to deselect object that it isn't\n    in object mode.\n    \"\"\"\n    modes = []\n    active = bpy.context.view_layer.objects.active\n\n    for obj in bpy.data.objects:\n        if obj.mode != 'OBJECT':\n            modes.append((obj, obj.mode))\n            bpy.context.view_layer.objects.active = obj\n            context_override = create_blender_context(active=obj)\n            with bpy.context.temp_override(**context_override):\n                bpy.ops.object.mode_set(mode='OBJECT')\n\n    context_override = create_blender_context()\n    with bpy.context.temp_override(**context_override):\n        bpy.ops.object.select_all(action='DESELECT')\n\n    for p in modes:\n        bpy.context.view_layer.objects.active = p[0]\n        context_override = create_blender_context(active=p[0])\n        with bpy.context.temp_override(**context_override):\n            bpy.ops.object.mode_set(mode=p[1])\n\n    bpy.context.view_layer.objects.active = active\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.get_parent_collection","title":"<code>get_parent_collection(collection)</code>","text":"<p>Get the parent of the input collection</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def get_parent_collection(collection):\n    \"\"\"Get the parent of the input collection\"\"\"\n    check_list = [bpy.context.scene.collection]\n\n    for c in check_list:\n        if collection.name in c.children.keys():\n            return c\n        check_list.extend(c.children)\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.get_unique_number","title":"<code>get_unique_number(folder_name, product_name)</code>","text":"<p>Return a unique number based on the folder name.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def get_unique_number(\n    folder_name: str, product_name: str\n) -&gt; str:\n    \"\"\"Return a unique number based on the folder name.\"\"\"\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        return \"01\"\n    # Check the names of both object and collection containers\n    obj_asset_groups = avalon_container.objects\n    obj_group_names = {\n        c.name for c in obj_asset_groups\n        if c.type == 'EMPTY' and c.get(AVALON_PROPERTY)}\n    coll_asset_groups = avalon_container.children\n    coll_group_names = {\n        c.name for c in coll_asset_groups\n        if c.get(AVALON_PROPERTY)}\n    container_names = obj_group_names.union(coll_group_names)\n    count = 1\n    name = f\"{folder_name}_{count:0&gt;2}_{product_name}\"\n    while name in container_names:\n        count += 1\n        name = f\"{folder_name}_{count:0&gt;2}_{product_name}\"\n    return f\"{count:0&gt;2}\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.prepare_scene_name","title":"<code>prepare_scene_name(folder_name, product_name, namespace=None)</code>","text":"<p>Return a consistent name for an asset.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def prepare_scene_name(\n    folder_name: str, product_name: str, namespace: Optional[str] = None\n) -&gt; str:\n    \"\"\"Return a consistent name for an asset.\"\"\"\n    name = f\"{folder_name}\"\n    if namespace:\n        name = f\"{name}_{namespace}\"\n    name = f\"{name}_{product_name}\"\n\n    # Blender name for a collection or object cannot be longer than 63\n    # characters. If the name is longer, it will raise an error.\n    if len(name) &gt; 63:\n        raise ValueError(f\"Scene name '{name}' would be too long.\")\n\n    return name\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html","title":"render_lib","text":""},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_aov_separator","title":"<code>get_aov_separator(settings)</code>","text":"<p>Get aov separator from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_aov_separator(settings):\n    \"\"\"Get aov separator from blender settings.\"\"\"\n\n    aov_sep = (settings[\"blender\"]\n                       [\"RenderSettings\"]\n                       [\"aov_separator\"])\n\n    if aov_sep == \"dash\":\n        return \"-\"\n    elif aov_sep == \"underscore\":\n        return \"_\"\n    elif aov_sep == \"dot\":\n        return \".\"\n    else:\n        raise ValueError(f\"Invalid aov separator: {aov_sep}\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_compositing","title":"<code>get_compositing(settings)</code>","text":"<p>Get compositing from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_compositing(settings):\n    \"\"\"Get compositing from blender settings.\"\"\"\n\n    return (settings[\"blender\"]\n                    [\"RenderSettings\"]\n                    [\"compositing\"])\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_default_render_folder","title":"<code>get_default_render_folder(settings)</code>","text":"<p>Get default render folder from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_default_render_folder(settings):\n    \"\"\"Get default render folder from blender settings.\"\"\"\n\n    return (settings[\"blender\"]\n                    [\"RenderSettings\"]\n                    [\"default_render_image_folder\"])\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_image_format","title":"<code>get_image_format(settings)</code>","text":"<p>Get image format from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_image_format(settings):\n    \"\"\"Get image format from blender settings.\"\"\"\n\n    return (settings[\"blender\"]\n                    [\"RenderSettings\"]\n                    [\"image_format\"])\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_multilayer","title":"<code>get_multilayer(settings)</code>","text":"<p>Get multilayer from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_multilayer(settings):\n    \"\"\"Get multilayer from blender settings.\"\"\"\n\n    return (settings[\"blender\"]\n                    [\"RenderSettings\"]\n                    [\"multilayer_exr\"])\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_render_product","title":"<code>get_render_product(output_path, name, aov_sep, view_layers, multiexr=False)</code>","text":"<p>Generate the path to the render product. Blender interprets the <code>#</code> as the frame number, when it renders.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the blender scene.</p> required <code>render_folder</code> <code>str</code> <p>The render folder set in settings.</p> required <code>file_name</code> <code>str</code> <p>The name of the blender scene.</p> required <code>instance</code> <code>Instance</code> <p>The instance to publish.</p> required <code>ext</code> <code>str</code> <p>The image format to render.</p> required Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_render_product(output_path, name, aov_sep, view_layers, multiexr=False):\n    \"\"\"\n    Generate the path to the render product. Blender interprets the `#`\n    as the frame number, when it renders.\n\n    Args:\n        file_path (str): The path to the blender scene.\n        render_folder (str): The render folder set in settings.\n        file_name (str): The name of the blender scene.\n        instance (pyblish.api.Instance): The instance to publish.\n        ext (str): The image format to render.\n    \"\"\"\n    beauty_render_product = {}\n    if multiexr:\n        vl_name = \"_\"\n        beauty_render_product[vl_name] = []\n        output_dir = Path(output_path)\n        filepath = output_dir / name.lstrip(\"/\")\n        render_product = f\"{filepath}{aov_sep}beauty.####\"\n        beauty_render_product[vl_name].append(\n            (\"beauty\", os.path.normpath(render_product)))\n    else:\n        for view_layer in view_layers:\n            vl_name = view_layer.name\n            beauty_render_product[vl_name] = []\n            output_dir = Path(f\"{output_path}/{vl_name}\")\n            filepath = output_dir / name.lstrip(\"/\")\n            render_product = f\"{filepath}_{vl_name}{aov_sep}beauty.####\"\n            beauty_render_product[vl_name].append(\n                (\"beauty\", os.path.normpath(render_product)))\n\n    return beauty_render_product\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_renderer","title":"<code>get_renderer(settings)</code>","text":"<p>Get renderer from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_renderer(settings):\n    \"\"\"Get renderer from blender settings.\"\"\"\n\n    return (settings[\"blender\"]\n                    [\"RenderSettings\"]\n                    [\"renderer\"])\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html","title":"workio","text":"<p>Host API required for Work Files.</p>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.OpenFileCacher","title":"<code>OpenFileCacher</code>","text":"<p>Store information about opening file.</p> <p>When file is opening QApplcation events should not be processed.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>class OpenFileCacher:\n    \"\"\"Store information about opening file.\n\n    When file is opening QApplcation events should not be processed.\n    \"\"\"\n    opening_file = False\n\n    @classmethod\n    def post_load(cls):\n        cls.opening_file = False\n\n    @classmethod\n    def set_opening(cls):\n        cls.opening_file = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.current_file","title":"<code>current_file()</code>","text":"<p>Return the path of the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def current_file() -&gt; Optional[str]:\n    \"\"\"Return the path of the open scene file.\"\"\"\n\n    current_filepath = bpy.data.filepath\n    if Path(current_filepath).is_file():\n        return current_filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.file_extensions","title":"<code>file_extensions()</code>","text":"<p>Return the supported file extensions for Blender scene files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def file_extensions() -&gt; List[str]:\n    \"\"\"Return the supported file extensions for Blender scene files.\"\"\"\n\n    return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.has_unsaved_changes","title":"<code>has_unsaved_changes()</code>","text":"<p>Does the open scene file have unsaved changes?</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def has_unsaved_changes() -&gt; bool:\n    \"\"\"Does the open scene file have unsaved changes?\"\"\"\n\n    return bpy.data.is_dirty\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Open the scene file in Blender.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def open_file(filepath: str) -&gt; Optional[str]:\n    \"\"\"Open the scene file in Blender.\"\"\"\n    OpenFileCacher.set_opening()\n\n    preferences = bpy.context.preferences\n    load_ui = preferences.filepaths.use_load_ui\n    use_scripts = preferences.filepaths.use_scripts_auto_execute\n    result = bpy.ops.wm.open_mainfile(\n        filepath=filepath,\n        load_ui=load_ui,\n        use_scripts=use_scripts,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.save_file","title":"<code>save_file(filepath, copy=False)</code>","text":"<p>Save the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def save_file(filepath: str, copy: bool = False) -&gt; Optional[str]:\n    \"\"\"Save the open scene file.\"\"\"\n\n    preferences = bpy.context.preferences\n    compress = preferences.filepaths.use_file_compression\n    relative_remap = preferences.filepaths.use_relative_paths\n    result = bpy.ops.wm.save_as_mainfile(\n        filepath=filepath,\n        compress=compress,\n        relative_remap=relative_remap,\n        copy=copy,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.work_root","title":"<code>work_root(session)</code>","text":"<p>Return the default root to browse for work files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def work_root(session: dict) -&gt; str:\n    \"\"\"Return the default root to browse for work files.\"\"\"\n\n    work_dir = session[\"AYON_WORKDIR\"]\n    scene_dir = session.get(\"AVALON_SCENEDIR\")\n    if scene_dir:\n        return str(Path(work_dir, scene_dir))\n    return work_dir\n</code></pre>"},{"location":"autoapi/client/ayon_blender/blender_addon/index.html","title":"blender_addon","text":""},{"location":"autoapi/client/ayon_blender/blender_addon/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_blender/blender_addon/startup/init.html","title":"init","text":""},{"location":"autoapi/client/ayon_blender/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_add_run_python_script_arg.html","title":"pre_add_run_python_script_arg","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_add_run_python_script_arg.html#client.ayon_blender.hooks.pre_add_run_python_script_arg.AddPythonScriptToLaunchArgs","title":"<code>AddPythonScriptToLaunchArgs</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Add python script to be executed before Blender launch.</p> Source code in <code>client/ayon_blender/hooks/pre_add_run_python_script_arg.py</code> <pre><code>class AddPythonScriptToLaunchArgs(PreLaunchHook):\n    \"\"\"Add python script to be executed before Blender launch.\"\"\"\n\n    # Append after file argument\n    order = 15\n    app_groups = {\"blender\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        if not self.launch_context.data.get(\"python_scripts\"):\n            return\n\n        # Add path to workfile to arguments\n        for python_script_path in self.launch_context.data[\"python_scripts\"]:\n            self.log.info(\n                f\"Adding python script {python_script_path} to launch\"\n            )\n            # Test script path exists\n            python_script_path = Path(python_script_path)\n            if not python_script_path.exists():\n                self.log.warning(\n                    f\"Python script {python_script_path} doesn't exist. \"\n                    \"Skipped...\"\n                )\n                continue\n\n            if \"--\" in self.launch_context.launch_args:\n                # Insert before separator\n                separator_index = self.launch_context.launch_args.index(\"--\")\n                self.launch_context.launch_args.insert(\n                    separator_index,\n                    \"-P\",\n                )\n                self.launch_context.launch_args.insert(\n                    separator_index + 1,\n                    python_script_path.as_posix(),\n                )\n            else:\n                self.launch_context.launch_args.extend(\n                    [\"-P\", python_script_path.as_posix()]\n                )\n\n        # Ensure separator\n        if \"--\" not in self.launch_context.launch_args:\n            self.launch_context.launch_args.append(\"--\")\n\n        self.launch_context.launch_args.extend(\n            [*self.launch_context.data.get(\"script_args\", [])]\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html","title":"pre_pyside_install","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender","title":"<code>InstallPySideToBlender</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Install Qt binding to blender's python packages.</p> <p>Prelaunch hook does 2 things: 1.) Blender's python packages are pushed to the beginning of PYTHONPATH. 2.) Check if blender has installed PySide2 and will try to install if not.</p> <p>For pipeline implementation is required to have Qt binding installed in blender's python packages.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>class InstallPySideToBlender(PreLaunchHook):\n    \"\"\"Install Qt binding to blender's python packages.\n\n    Prelaunch hook does 2 things:\n    1.) Blender's python packages are pushed to the beginning of PYTHONPATH.\n    2.) Check if blender has installed PySide2 and will try to install if not.\n\n    For pipeline implementation is required to have Qt binding installed in\n    blender's python packages.\n    \"\"\"\n\n    app_groups = {\"blender\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Prelaunch hook is not crucial\n        try:\n            self.inner_execute()\n        except Exception:\n            self.log.warning(\n                \"Processing of {} crashed.\".format(self.__class__.__name__),\n                exc_info=True\n            )\n\n    def inner_execute(self):\n        # Get blender's python directory\n        version_regex = re.compile(r\"^([2-4])\\.[0-9]+$\")\n\n        platform = system().lower()\n        executable = self.launch_context.executable.executable_path\n        expected_executable = \"blender\"\n        if platform == \"windows\":\n            expected_executable += \".exe\"\n\n        if os.path.basename(executable).lower() != expected_executable:\n            self.log.info((\n                f\"Executable does not lead to {expected_executable} file.\"\n                \"Can't determine blender's python to check/install\"\n                \" Qt binding.\"\n            ))\n            return\n\n        versions_dir = os.path.dirname(executable)\n        if platform == \"darwin\":\n            versions_dir = os.path.join(\n                os.path.dirname(versions_dir), \"Resources\"\n            )\n        version_subfolders = []\n        for dir_entry in os.scandir(versions_dir):\n            if dir_entry.is_dir() and version_regex.match(dir_entry.name):\n                version_subfolders.append(dir_entry.name)\n\n        if not version_subfolders:\n            self.log.info(\n                \"Didn't find version subfolder next to Blender executable\"\n            )\n            return\n\n        if len(version_subfolders) &gt; 1:\n            self.log.info((\n                \"Found more than one version subfolder next\"\n                \" to blender executable. {}\"\n            ).format(\", \".join([\n                '\"./{}\"'.format(name)\n                for name in version_subfolders\n            ])))\n            return\n\n        version_subfolder = version_subfolders[0]\n        before_blender_4 = False\n        if int(version_regex.match(version_subfolder).group(1)) &lt; 4:\n            before_blender_4 = True\n        # Blender 4 has Python 3.11 which does not support 'PySide2'\n        # QUESTION could we always install PySide6?\n        qt_binding = \"PySide2\" if before_blender_4 else \"PySide6\"\n        # Use PySide6 6.6.3 because 6.7.0 had a bug\n        #   - 'QTextEdit' can't be added to 'QBoxLayout'\n        qt_binding_version = None if before_blender_4 else \"6.6.3\"\n\n        python_dir = os.path.join(versions_dir, version_subfolder, \"python\")\n        python_lib = os.path.join(python_dir, \"lib\")\n        python_version = \"python\"\n\n        if platform != \"windows\":\n            for dir_entry in os.scandir(python_lib):\n                if dir_entry.is_dir() and dir_entry.name.startswith(\"python\"):\n                    python_lib = dir_entry.path\n                    python_version = dir_entry.name\n                    break\n\n        # Change PYTHONPATH to contain blender's packages as first\n        python_paths = [\n            python_lib,\n            os.path.join(python_lib, \"site-packages\"),\n        ]\n        python_path = self.launch_context.env.get(\"PYTHONPATH\") or \"\"\n        for path in python_path.split(os.pathsep):\n            if path:\n                python_paths.append(path)\n\n        self.launch_context.env[\"PYTHONPATH\"] = os.pathsep.join(python_paths)\n\n        # Get blender's python executable\n        python_bin = os.path.join(python_dir, \"bin\")\n        if platform == \"windows\":\n            python_executable = os.path.join(python_bin, \"python.exe\")\n        else:\n            python_executable = os.path.join(python_bin, python_version)\n            # Check for python with enabled 'pymalloc'\n            if not os.path.exists(python_executable):\n                python_executable += \"m\"\n\n        if not os.path.exists(python_executable):\n            self.log.warning(\n                \"Couldn't find python executable for blender. {}\".format(\n                    executable\n                )\n            )\n            return\n\n        # Check if PySide2 is installed and skip if yes\n        if self.is_pyside_installed(python_executable, qt_binding):\n            self.log.debug(\"Blender has already installed PySide2.\")\n            return\n\n        # Install PySide2 in blender's python\n        if platform == \"windows\":\n            result = self.install_pyside_windows(\n                python_executable,\n                qt_binding,\n                qt_binding_version,\n                before_blender_4,\n            )\n        else:\n            result = self.install_pyside(\n                python_executable,\n                qt_binding,\n                qt_binding_version,\n            )\n\n        if result:\n            self.log.info(\n                f\"Successfully installed {qt_binding} module to blender.\"\n            )\n        else:\n            self.log.warning(\n                f\"Failed to install {qt_binding} module to blender.\"\n            )\n\n    def install_pyside_windows(\n        self,\n        python_executable,\n        qt_binding,\n        qt_binding_version,\n        before_blender_4,\n    ):\n        \"\"\"Install PySide2 python module to blender's python.\n\n        Installation requires administration rights that's why it is required\n        to use \"pywin32\" module which can execute command's and ask for\n        administration rights.\n        \"\"\"\n        try:\n            import win32con\n            import win32process\n            import win32event\n            import pywintypes\n            from win32comext.shell.shell import ShellExecuteEx\n            from win32comext.shell import shellcon\n        except Exception:\n            self.log.warning(\"Couldn't import \\\"pywin32\\\" modules\")\n            return\n\n        if qt_binding_version:\n            qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide2 and argument\n            #   \"--ignore-installed\" is to force install module to blender's\n            #   site-packages and make sure it is binary compatible\n            fake_exe = \"fake.exe\"\n            site_packages_prefix = os.path.dirname(\n                os.path.dirname(python_executable)\n            )\n            args = [\n                fake_exe,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"--ignore-installed\",\n                qt_binding,\n            ]\n            if not before_blender_4:\n                # Define prefix for site package\n                # Python in blender 4.x is installing packages in AppData and\n                #   not in blender's directory.\n                args.extend([\"--prefix\", site_packages_prefix])\n\n            parameters = (\n                subprocess.list2cmdline(args)\n                .lstrip(fake_exe)\n                .lstrip(\" \")\n            )\n\n            # Execute command and ask for administrator's rights\n            process_info = ShellExecuteEx(\n                nShow=win32con.SW_SHOWNORMAL,\n                fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n                lpVerb=\"runas\",\n                lpFile=python_executable,\n                lpParameters=parameters,\n                lpDirectory=os.path.dirname(python_executable)\n            )\n            process_handle = process_info[\"hProcess\"]\n            win32event.WaitForSingleObject(process_handle, win32event.INFINITE)\n            returncode = win32process.GetExitCodeProcess(process_handle)\n            return returncode == 0\n        except pywintypes.error:\n            pass\n\n    def install_pyside(\n        self,\n        python_executable,\n        qt_binding,\n        qt_binding_version,\n    ):\n        \"\"\"Install Qt binding python module to blender's python.\"\"\"\n        if qt_binding_version:\n            qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install qt binding and argument\n            #   \"--ignore-installed\" is to force install module to blender's\n            #   site-packages and make sure it is binary compatible\n            # TODO find out if blender 4.x on linux/darwin does install\n            #   qt binding to correct place.\n            args = [\n                python_executable,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"--ignore-installed\",\n                qt_binding,\n            ]\n            process = subprocess.Popen(\n                args, stdout=subprocess.PIPE, universal_newlines=True\n            )\n            process.communicate()\n            return process.returncode == 0\n        except PermissionError:\n            self.log.warning(\n                \"Permission denied with command:\"\n                \"\\\"{}\\\".\".format(\" \".join(args))\n            )\n        except OSError as error:\n            self.log.warning(f\"OS error has occurred: \\\"{error}\\\".\")\n        except subprocess.SubprocessError:\n            pass\n\n    def is_pyside_installed(self, python_executable, qt_binding):\n        \"\"\"Check if PySide2 module is in blender's pip list.\n\n        Check that PySide2 is installed directly in blender's site-packages.\n        It is possible that it is installed in user's site-packages but that\n        may be incompatible with blender's python.\n        \"\"\"\n\n        qt_binding_low = qt_binding.lower()\n        # Get pip list from blender's python executable\n        args = [python_executable, \"-m\", \"pip\", \"list\"]\n        process = subprocess.Popen(args, stdout=subprocess.PIPE)\n        stdout, _ = process.communicate()\n        lines = stdout.decode().split(os.linesep)\n        # Second line contain dashes that define maximum length of module name.\n        #   Second column of dashes define maximum length of module version.\n        package_dashes, *_ = lines[1].split(\" \")\n        package_len = len(package_dashes)\n\n        # Got through printed lines starting at line 3\n        for idx in range(2, len(lines)):\n            line = lines[idx]\n            if not line:\n                continue\n            package_name = line[0:package_len].strip()\n            if package_name.lower() == qt_binding_low:\n                return True\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender.install_pyside","title":"<code>install_pyside(python_executable, qt_binding, qt_binding_version)</code>","text":"<p>Install Qt binding python module to blender's python.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>def install_pyside(\n    self,\n    python_executable,\n    qt_binding,\n    qt_binding_version,\n):\n    \"\"\"Install Qt binding python module to blender's python.\"\"\"\n    if qt_binding_version:\n        qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n    try:\n        # Parameters\n        # - use \"-m pip\" as module pip to install qt binding and argument\n        #   \"--ignore-installed\" is to force install module to blender's\n        #   site-packages and make sure it is binary compatible\n        # TODO find out if blender 4.x on linux/darwin does install\n        #   qt binding to correct place.\n        args = [\n            python_executable,\n            \"-m\",\n            \"pip\",\n            \"install\",\n            \"--ignore-installed\",\n            qt_binding,\n        ]\n        process = subprocess.Popen(\n            args, stdout=subprocess.PIPE, universal_newlines=True\n        )\n        process.communicate()\n        return process.returncode == 0\n    except PermissionError:\n        self.log.warning(\n            \"Permission denied with command:\"\n            \"\\\"{}\\\".\".format(\" \".join(args))\n        )\n    except OSError as error:\n        self.log.warning(f\"OS error has occurred: \\\"{error}\\\".\")\n    except subprocess.SubprocessError:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender.install_pyside_windows","title":"<code>install_pyside_windows(python_executable, qt_binding, qt_binding_version, before_blender_4)</code>","text":"<p>Install PySide2 python module to blender's python.</p> <p>Installation requires administration rights that's why it is required to use \"pywin32\" module which can execute command's and ask for administration rights.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>def install_pyside_windows(\n    self,\n    python_executable,\n    qt_binding,\n    qt_binding_version,\n    before_blender_4,\n):\n    \"\"\"Install PySide2 python module to blender's python.\n\n    Installation requires administration rights that's why it is required\n    to use \"pywin32\" module which can execute command's and ask for\n    administration rights.\n    \"\"\"\n    try:\n        import win32con\n        import win32process\n        import win32event\n        import pywintypes\n        from win32comext.shell.shell import ShellExecuteEx\n        from win32comext.shell import shellcon\n    except Exception:\n        self.log.warning(\"Couldn't import \\\"pywin32\\\" modules\")\n        return\n\n    if qt_binding_version:\n        qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n\n    try:\n        # Parameters\n        # - use \"-m pip\" as module pip to install PySide2 and argument\n        #   \"--ignore-installed\" is to force install module to blender's\n        #   site-packages and make sure it is binary compatible\n        fake_exe = \"fake.exe\"\n        site_packages_prefix = os.path.dirname(\n            os.path.dirname(python_executable)\n        )\n        args = [\n            fake_exe,\n            \"-m\",\n            \"pip\",\n            \"install\",\n            \"--ignore-installed\",\n            qt_binding,\n        ]\n        if not before_blender_4:\n            # Define prefix for site package\n            # Python in blender 4.x is installing packages in AppData and\n            #   not in blender's directory.\n            args.extend([\"--prefix\", site_packages_prefix])\n\n        parameters = (\n            subprocess.list2cmdline(args)\n            .lstrip(fake_exe)\n            .lstrip(\" \")\n        )\n\n        # Execute command and ask for administrator's rights\n        process_info = ShellExecuteEx(\n            nShow=win32con.SW_SHOWNORMAL,\n            fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n            lpVerb=\"runas\",\n            lpFile=python_executable,\n            lpParameters=parameters,\n            lpDirectory=os.path.dirname(python_executable)\n        )\n        process_handle = process_info[\"hProcess\"]\n        win32event.WaitForSingleObject(process_handle, win32event.INFINITE)\n        returncode = win32process.GetExitCodeProcess(process_handle)\n        return returncode == 0\n    except pywintypes.error:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender.is_pyside_installed","title":"<code>is_pyside_installed(python_executable, qt_binding)</code>","text":"<p>Check if PySide2 module is in blender's pip list.</p> <p>Check that PySide2 is installed directly in blender's site-packages. It is possible that it is installed in user's site-packages but that may be incompatible with blender's python.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>def is_pyside_installed(self, python_executable, qt_binding):\n    \"\"\"Check if PySide2 module is in blender's pip list.\n\n    Check that PySide2 is installed directly in blender's site-packages.\n    It is possible that it is installed in user's site-packages but that\n    may be incompatible with blender's python.\n    \"\"\"\n\n    qt_binding_low = qt_binding.lower()\n    # Get pip list from blender's python executable\n    args = [python_executable, \"-m\", \"pip\", \"list\"]\n    process = subprocess.Popen(args, stdout=subprocess.PIPE)\n    stdout, _ = process.communicate()\n    lines = stdout.decode().split(os.linesep)\n    # Second line contain dashes that define maximum length of module name.\n    #   Second column of dashes define maximum length of module version.\n    package_dashes, *_ = lines[1].split(\" \")\n    package_len = len(package_dashes)\n\n    # Got through printed lines starting at line 3\n    for idx in range(2, len(lines)):\n        line = lines[idx]\n        if not line:\n            continue\n        package_name = line[0:package_len].strip()\n        if package_name.lower() == qt_binding_low:\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_windows_console.html","title":"pre_windows_console","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_windows_console.html#client.ayon_blender.hooks.pre_windows_console.BlenderConsoleWindows","title":"<code>BlenderConsoleWindows</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Foundry applications have specific way how to launch them.</p> <p>Blender is executed \"like\" python process so it is required to pass <code>CREATE_NEW_CONSOLE</code> flag on windows to trigger creation of new console. At the same time the newly created console won't create it's own stdout and stderr handlers so they should not be redirected to DEVNULL.</p> Source code in <code>client/ayon_blender/hooks/pre_windows_console.py</code> <pre><code>class BlenderConsoleWindows(PreLaunchHook):\n    \"\"\"Foundry applications have specific way how to launch them.\n\n    Blender is executed \"like\" python process so it is required to pass\n    `CREATE_NEW_CONSOLE` flag on windows to trigger creation of new console.\n    At the same time the newly created console won't create it's own stdout\n    and stderr handlers so they should not be redirected to DEVNULL.\n    \"\"\"\n\n    # Should be as last hook because must change launch arguments to string\n    order = 1000\n    app_groups = {\"blender\"}\n    platforms = {\"windows\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Change `creationflags` to CREATE_NEW_CONSOLE\n        # - on Windows will blender create new window using it's console\n        # Set `stdout` and `stderr` to None so new created console does not\n        #   have redirected output to DEVNULL in build\n        self.launch_context.kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE,\n            \"stdout\": None,\n            \"stderr\": None\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_blender/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html","title":"convert_legacy","text":"<p>Converter for legacy Houdini products.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html#client.ayon_blender.plugins.create.convert_legacy.BlenderLegacyConvertor","title":"<code>BlenderLegacyConvertor</code>","text":"<p>               Bases: <code>ProductConvertorPlugin</code></p> <p>Find and convert any legacy products in the scene.</p> <p>This Converter will find all legacy products in the scene and will transform them to the current system. Since the old products doesn't retain any information about their original creators, the only mapping we can do is based on their product types.</p> <p>Its limitation is that you can have multiple creators creating product of the same product type and there is no way to handle it. This code should nevertheless cover all creators that came with OpenPype.</p> Source code in <code>client/ayon_blender/plugins/create/convert_legacy.py</code> <pre><code>class BlenderLegacyConvertor(ProductConvertorPlugin):\n    \"\"\"Find and convert any legacy products in the scene.\n\n    This Converter will find all legacy products in the scene and will\n    transform them to the current system. Since the old products doesn't\n    retain any information about their original creators, the only mapping\n    we can do is based on their product types.\n\n    Its limitation is that you can have multiple creators creating product\n    of the same product type and there is no way to handle it. This code\n    should nevertheless cover all creators that came with OpenPype.\n\n    \"\"\"\n    identifier = \"io.openpype.creators.blender.legacy\"\n    product_type_to_id = {\n        \"action\": \"io.openpype.creators.blender.action\",\n        \"camera\": \"io.openpype.creators.blender.camera\",\n        \"animation\": \"io.openpype.creators.blender.animation\",\n        \"blendScene\": \"io.openpype.creators.blender.blendscene\",\n        \"layout\": \"io.openpype.creators.blender.layout\",\n        \"model\": \"io.openpype.creators.blender.model\",\n        \"pointcache\": \"io.openpype.creators.blender.pointcache\",\n        \"render\": \"io.openpype.creators.blender.render\",\n        \"review\": \"io.openpype.creators.blender.review\",\n        \"rig\": \"io.openpype.creators.blender.rig\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        super(BlenderLegacyConvertor, self).__init__(*args, **kwargs)\n        self.legacy_instances = {}\n\n    def find_instances(self):\n        \"\"\"Find legacy products in the scene.\n\n        Legacy products are the ones that doesn't have `creator_identifier`\n        parameter on them.\n\n        This is using cached entries done in\n        :py:meth:`~BlenderCreator.cache_instance_data()`\n\n        \"\"\"\n        self.legacy_instances = self.collection_shared_data.get(\n            \"blender_cached_legacy_instances\")\n        if not self.legacy_instances:\n            return\n        self.add_convertor_item(\n            \"Found {} incompatible product{}\".format(\n                len(self.legacy_instances),\n                \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n            )\n        )\n\n    def convert(self):\n        \"\"\"Convert all legacy products to current.\n\n        It is enough to add `creator_identifier` and `instance_node`.\n\n        \"\"\"\n        if not self.legacy_instances:\n            return\n\n        for product_type, instance_nodes in self.legacy_instances.items():\n            if product_type in self.product_type_to_id:\n                for instance_node in instance_nodes:\n                    creator_identifier = self.product_type_to_id[product_type]\n                    self.log.info(\n                        \"Converting {} to {}\".format(instance_node.name,\n                                                     creator_identifier)\n                    )\n                    imprint(instance_node, data={\n                        \"creator_identifier\": creator_identifier\n                    })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html#client.ayon_blender.plugins.create.convert_legacy.BlenderLegacyConvertor.convert","title":"<code>convert()</code>","text":"<p>Convert all legacy products to current.</p> <p>It is enough to add <code>creator_identifier</code> and <code>instance_node</code>.</p> Source code in <code>client/ayon_blender/plugins/create/convert_legacy.py</code> <pre><code>def convert(self):\n    \"\"\"Convert all legacy products to current.\n\n    It is enough to add `creator_identifier` and `instance_node`.\n\n    \"\"\"\n    if not self.legacy_instances:\n        return\n\n    for product_type, instance_nodes in self.legacy_instances.items():\n        if product_type in self.product_type_to_id:\n            for instance_node in instance_nodes:\n                creator_identifier = self.product_type_to_id[product_type]\n                self.log.info(\n                    \"Converting {} to {}\".format(instance_node.name,\n                                                 creator_identifier)\n                )\n                imprint(instance_node, data={\n                    \"creator_identifier\": creator_identifier\n                })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html#client.ayon_blender.plugins.create.convert_legacy.BlenderLegacyConvertor.find_instances","title":"<code>find_instances()</code>","text":"<p>Find legacy products in the scene.</p> <p>Legacy products are the ones that doesn't have <code>creator_identifier</code> parameter on them.</p> <p>This is using cached entries done in :py:meth:<code>~BlenderCreator.cache_instance_data()</code></p> Source code in <code>client/ayon_blender/plugins/create/convert_legacy.py</code> <pre><code>def find_instances(self):\n    \"\"\"Find legacy products in the scene.\n\n    Legacy products are the ones that doesn't have `creator_identifier`\n    parameter on them.\n\n    This is using cached entries done in\n    :py:meth:`~BlenderCreator.cache_instance_data()`\n\n    \"\"\"\n    self.legacy_instances = self.collection_shared_data.get(\n        \"blender_cached_legacy_instances\")\n    if not self.legacy_instances:\n        return\n    self.add_convertor_item(\n        \"Found {} incompatible product{}\".format(\n            len(self.legacy_instances),\n            \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_action.html","title":"create_action","text":"<p>Create an animation asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_action.html#client.ayon_blender.plugins.create.create_action.CreateAction","title":"<code>CreateAction</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Action output for character rigs.</p> Source code in <code>client/ayon_blender/plugins/create/create_action.py</code> <pre><code>class CreateAction(plugin.BlenderCreator):\n    \"\"\"Action output for character rigs.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.action\"\n    label = \"Action\"\n    product_type = \"action\"\n    icon = \"male\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        # Get instance name\n        name = plugin.prepare_scene_name(\n            instance_data[\"folderPath\"], product_name\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            for obj in lib.get_selection():\n                if (obj.animation_data is not None\n                        and obj.animation_data.action is not None):\n\n                    empty_obj = bpy.data.objects.new(name=name,\n                                                     object_data=None)\n                    empty_obj.animation_data_create()\n                    empty_obj.animation_data.action = obj.animation_data.action\n                    empty_obj.animation_data.action.name = name\n                    collection.objects.link(empty_obj)\n\n        return collection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_animation.html","title":"create_animation","text":"<p>Create an animation asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_animation.html#client.ayon_blender.plugins.create.create_animation.CreateAnimation","title":"<code>CreateAnimation</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Animation output for character rigs.</p> Source code in <code>client/ayon_blender/plugins/create/create_animation.py</code> <pre><code>class CreateAnimation(plugin.BlenderCreator):\n    \"\"\"Animation output for character rigs.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.animation\"\n    label = \"Animation\"\n    product_type = \"animation\"\n    icon = \"male\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            selected = lib.get_selection()\n            for obj in selected:\n                collection.objects.link(obj)\n        elif pre_create_data.get(\"asset_group\"):\n            # Use for Load Blend automated creation of animation instances\n            # upon loading rig files\n            obj = pre_create_data.get(\"asset_group\")\n            collection.objects.link(obj)\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context,\n                                          step=False)\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_blendScene.html","title":"create_blendScene","text":"<p>Create a Blender scene asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_blendScene.html#client.ayon_blender.plugins.create.create_blendScene.CreateBlendScene","title":"<code>CreateBlendScene</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Generic group of assets.</p> Source code in <code>client/ayon_blender/plugins/create/create_blendScene.py</code> <pre><code>class CreateBlendScene(plugin.BlenderCreator):\n    \"\"\"Generic group of assets.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.blendscene\"\n    label = \"Blender Scene\"\n    product_type = \"blendScene\"\n    icon = \"cubes\"\n\n    maintain_selection = False\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n\n        instance_node = super().create(product_name,\n                                       instance_data,\n                                       pre_create_data)\n\n        if pre_create_data.get(\"use_selection\"):\n            selection = lib.get_selection(include_collections=True)\n            for data in selection:\n                if isinstance(data, bpy.types.Collection):\n                    instance_node.children.link(data)\n                elif isinstance(data, bpy.types.Object):\n                    instance_node.objects.link(data)\n\n        return instance_node\n\n    def remove_instances(self, instances):\n\n        for instance in instances:\n            node = instance.transient_data[\"instance_node\"]\n            bpy.data.collections.remove(node)\n\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_camera.html","title":"create_camera","text":"<p>Create a camera asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_camera.html#client.ayon_blender.plugins.create.create_camera.CreateCamera","title":"<code>CreateCamera</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Polygonal static geometry.</p> Source code in <code>client/ayon_blender/plugins/create/create_camera.py</code> <pre><code>class CreateCamera(plugin.BlenderCreator):\n    \"\"\"Polygonal static geometry.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.camera\"\n    label = \"Camera\"\n    product_type = \"camera\"\n    icon = \"video-camera\"\n\n    create_as_asset_group = True\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n\n        asset_group = super().create(product_name,\n                                     instance_data,\n                                     pre_create_data)\n\n        bpy.context.view_layer.objects.active = asset_group\n        if pre_create_data.get(\"use_selection\"):\n            for obj in lib.get_selection():\n                obj.parent = asset_group\n        else:\n            plugin.deselect_all()\n            camera = bpy.data.cameras.new(product_name)\n            camera_obj = bpy.data.objects.new(product_name, camera)\n\n            instances = bpy.data.collections.get(AVALON_INSTANCES)\n            instances.objects.link(camera_obj)\n\n            bpy.context.view_layer.objects.active = asset_group\n            camera_obj.parent = asset_group\n\n        return asset_group\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_layout.html","title":"create_layout","text":"<p>Create a layout asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_layout.html#client.ayon_blender.plugins.create.create_layout.CreateLayout","title":"<code>CreateLayout</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Layout output for character rigs.</p> Source code in <code>client/ayon_blender/plugins/create/create_layout.py</code> <pre><code>class CreateLayout(plugin.BlenderCreator):\n    \"\"\"Layout output for character rigs.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.layout\"\n    label = \"Layout\"\n    product_type = \"layout\"\n    icon = \"cubes\"\n\n    create_as_asset_group = True\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n\n        asset_group = super().create(product_name,\n                                     instance_data,\n                                     pre_create_data)\n\n        # Add selected objects to instance\n        if pre_create_data.get(\"use_selection\"):\n            bpy.context.view_layer.objects.active = asset_group\n            for obj in lib.get_selection():\n                obj.parent = asset_group\n\n        return asset_group\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_model.html","title":"create_model","text":"<p>Create a model asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_model.html#client.ayon_blender.plugins.create.create_model.CreateModel","title":"<code>CreateModel</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Polygonal static geometry.</p> Source code in <code>client/ayon_blender/plugins/create/create_model.py</code> <pre><code>class CreateModel(plugin.BlenderCreator):\n    \"\"\"Polygonal static geometry.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.model\"\n    label = \"Model\"\n    product_type = \"model\"\n    icon = \"cube\"\n\n    create_as_asset_group = True\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        asset_group = super().create(product_name,\n                                     instance_data,\n                                     pre_create_data)\n\n        # Add selected objects to instance\n        if pre_create_data.get(\"use_selection\"):\n            bpy.context.view_layer.objects.active = asset_group\n            for obj in lib.get_selection():\n                obj.parent = asset_group\n\n        return asset_group\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_pointcache.html","title":"create_pointcache","text":"<p>Create a pointcache asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_pointcache.html#client.ayon_blender.plugins.create.create_pointcache.CreatePointcache","title":"<code>CreatePointcache</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Polygonal static geometry.</p> Source code in <code>client/ayon_blender/plugins/create/create_pointcache.py</code> <pre><code>class CreatePointcache(plugin.BlenderCreator):\n    \"\"\"Polygonal static geometry.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.pointcache\"\n    label = \"Point Cache\"\n    product_type = \"pointcache\"\n    icon = \"gears\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            objects = lib.get_selection()\n            for obj in objects:\n                collection.objects.link(obj)\n                if obj.type == 'EMPTY':\n                    objects.extend(obj.children)\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context,\n                                          step=False)\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_render.html","title":"create_render","text":"<p>Create render.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_render.html#client.ayon_blender.plugins.create.create_render.CreateRenderlayer","title":"<code>CreateRenderlayer</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Single baked camera.</p> Source code in <code>client/ayon_blender/plugins/create/create_render.py</code> <pre><code>class CreateRenderlayer(plugin.BlenderCreator):\n    \"\"\"Single baked camera.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.render\"\n    label = \"Render\"\n    product_type = \"renderlayer\"\n    icon = \"eye\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        try:\n            # Run parent create method\n            collection = super().create(\n                product_name, instance_data, pre_create_data\n            )\n\n            prepare_rendering(collection)\n        except Exception:\n            # Remove the instance if there was an error\n            bpy.data.collections.remove(collection)\n            raise\n\n        # TODO: this is undesiderable, but it's the only way to be sure that\n        # the file is saved before the render starts.\n        # Blender, by design, doesn't set the file as dirty if modifications\n        # happen by script. So, when creating the instance and setting the\n        # render settings, the file is not marked as dirty. This means that\n        # there is the risk of sending to deadline a file without the right\n        # settings. Even the validator to check that the file is saved will\n        # detect the file as saved, even if it isn't. The only solution for\n        # now it is to force the file to be saved.\n        if not bpy.data.filepath:\n            version_up_current_workfile()\n        else:\n            filepath = version_up(bpy.data.filepath)\n            save_file(filepath, copy=False)\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_review.html","title":"create_review","text":"<p>Create review.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_review.html#client.ayon_blender.plugins.create.create_review.CreateReview","title":"<code>CreateReview</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Single baked camera.</p> Source code in <code>client/ayon_blender/plugins/create/create_review.py</code> <pre><code>class CreateReview(plugin.BlenderCreator):\n    \"\"\"Single baked camera.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.review\"\n    label = \"Review\"\n    product_type = \"review\"\n    icon = \"video-camera\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            selected = lib.get_selection()\n            for obj in selected:\n                collection.objects.link(obj)\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_rig.html","title":"create_rig","text":"<p>Create a rig asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_rig.html#client.ayon_blender.plugins.create.create_rig.CreateRig","title":"<code>CreateRig</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Artist-friendly rig with controls to direct motion.</p> Source code in <code>client/ayon_blender/plugins/create/create_rig.py</code> <pre><code>class CreateRig(plugin.BlenderCreator):\n    \"\"\"Artist-friendly rig with controls to direct motion.\"\"\"\n\n    identifier = \"io.openpype.creators.blender.rig\"\n    label = \"Rig\"\n    product_type = \"rig\"\n    icon = \"wheelchair\"\n\n    create_as_asset_group = True\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        asset_group = super().create(product_name,\n                                     instance_data,\n                                     pre_create_data)\n\n        # Add selected objects to instance\n        if pre_create_data.get(\"use_selection\"):\n            bpy.context.view_layer.objects.active = asset_group\n            for obj in lib.get_selection():\n                obj.parent = asset_group\n\n        return asset_group\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_usd.html","title":"create_usd","text":"<p>Create a USD Export.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_usd.html#client.ayon_blender.plugins.create.create_usd.CreateUSD","title":"<code>CreateUSD</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Create USD Export</p> Source code in <code>client/ayon_blender/plugins/create/create_usd.py</code> <pre><code>class CreateUSD(plugin.BlenderCreator):\n    \"\"\"Create USD Export\"\"\"\n\n    identifier = \"io.openpype.creators.blender.usd\"\n    name = \"usdMain\"\n    label = \"USD\"\n    product_type = \"usd\"\n    icon = \"gears\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            objects = lib.get_selection()\n            for obj in objects:\n                collection.objects.link(obj)\n                if obj.type == 'EMPTY':\n                    objects.extend(obj.children)\n\n        return collection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_blender/plugins/create/create_workfile.html#client.ayon_blender.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>BlenderCreator</code>, <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> <p>The workfile instance stores its data on the <code>AVALON_CONTAINERS</code> collection as custom attributes, because unlike other instances it doesn't have an instance node of its own.</p> Source code in <code>client/ayon_blender/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(BlenderCreator, AutoCreator):\n    \"\"\"Workfile auto-creator.\n\n    The workfile instance stores its data on the `AVALON_CONTAINERS` collection\n    as custom attributes, because unlike other instances it doesn't have an\n    instance node of its own.\n\n    \"\"\"\n    identifier = \"io.openpype.creators.blender.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    def create(self):\n        \"\"\"Create workfile instances.\"\"\"\n        workfile_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ),\n            None,\n        )\n\n        project_entity = self.create_context.get_current_project_entity()\n        project_name = project_entity[\"name\"]\n        folder_entity = self.create_context.get_current_folder_entity()\n        folder_path = folder_entity[\"path\"]\n        task_entity = self.create_context.get_current_task_entity()\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        if not workfile_instance:\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                task_name,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": task_name,\n            }\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    task_name,\n                    host_name,\n                    workfile_instance,\n                )\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            workfile_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(workfile_instance)\n\n        elif (\n            workfile_instance[\"folderPath\"]  != folder_path\n            or workfile_instance[\"task\"] != task_name\n        ):\n            # Update instance context if it's different\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n            )\n\n            workfile_instance[\"folderPath\"] = folder_path\n            workfile_instance[\"task\"] = task_name\n            workfile_instance[\"productName\"] = product_name\n\n        instance_node = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not instance_node:\n            instance_node = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        workfile_instance.transient_data[\"instance_node\"] = instance_node\n\n    def collect_instances(self):\n\n        instance_node = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not instance_node:\n            return\n\n        property = instance_node.get(AVALON_PROPERTY)\n        if not property:\n            return\n\n        # Create instance object from existing data\n        instance = CreatedInstance.from_existing(\n            instance_data=property.to_dict(),\n            creator=self\n        )\n        instance.transient_data[\"instance_node\"] = instance_node\n\n        # Add instance to create context\n        self._add_instance_to_context(instance)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            node = instance.transient_data[\"instance_node\"]\n            del node[AVALON_PROPERTY]\n\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_workfile.html#client.ayon_blender.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create()</code>","text":"<p>Create workfile instances.</p> Source code in <code>client/ayon_blender/plugins/create/create_workfile.py</code> <pre><code>def create(self):\n    \"\"\"Create workfile instances.\"\"\"\n    workfile_instance = next(\n        (\n            instance for instance in self.create_context.instances\n            if instance.creator_identifier == self.identifier\n        ),\n        None,\n    )\n\n    project_entity = self.create_context.get_current_project_entity()\n    project_name = project_entity[\"name\"]\n    folder_entity = self.create_context.get_current_folder_entity()\n    folder_path = folder_entity[\"path\"]\n    task_entity = self.create_context.get_current_task_entity()\n    task_name = task_entity[\"name\"]\n    host_name = self.create_context.host_name\n\n    if not workfile_instance:\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            task_name,\n            host_name,\n        )\n        data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": task_name,\n        }\n        data.update(\n            self.get_dynamic_data(\n                project_name,\n                folder_entity,\n                task_entity,\n                task_name,\n                host_name,\n                workfile_instance,\n            )\n        )\n        self.log.info(\"Auto-creating workfile instance...\")\n        workfile_instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self._add_instance_to_context(workfile_instance)\n\n    elif (\n        workfile_instance[\"folderPath\"]  != folder_path\n        or workfile_instance[\"task\"] != task_name\n    ):\n        # Update instance context if it's different\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            self.default_variant,\n            host_name,\n        )\n\n        workfile_instance[\"folderPath\"] = folder_path\n        workfile_instance[\"task\"] = task_name\n        workfile_instance[\"productName\"] = product_name\n\n    instance_node = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not instance_node:\n        instance_node = bpy.data.collections.new(name=AVALON_CONTAINERS)\n    workfile_instance.transient_data[\"instance_node\"] = instance_node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/import_workfile.html","title":"import_workfile","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/import_workfile.html#client.ayon_blender.plugins.load.import_workfile.AppendBlendLoader","title":"<code>AppendBlendLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Append workfile in Blender (unmanaged)</p> Warning <p>The loaded content will be unmanaged and is not visible in the scene inventory. It's purely intended to merge content into your scene so you could also use it as a new base.</p> Source code in <code>client/ayon_blender/plugins/load/import_workfile.py</code> <pre><code>class AppendBlendLoader(plugin.BlenderLoader):\n    \"\"\"Append workfile in Blender (unmanaged)\n\n    Warning:\n        The loaded content will be unmanaged and is *not* visible in the\n        scene inventory. It's purely intended to merge content into your scene\n        so you could also use it as a new base.\n    \"\"\"\n\n    representations = {\"blend\"}\n    product_types = {\"workfile\"}\n\n    label = \"Append Workfile\"\n    order = 9\n    icon = \"arrow-circle-down\"\n    color = \"#775555\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        path = self.filepath_from_context(context)\n        append_workfile(context, path, False)\n\n        # We do not containerize imported content, it remains unmanaged\n        return\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/import_workfile.html#client.ayon_blender.plugins.load.import_workfile.ImportBlendLoader","title":"<code>ImportBlendLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Import workfile in the current Blender scene (unmanaged)</p> Warning <p>The loaded content will be unmanaged and is not visible in the scene inventory. It's purely intended to merge content into your scene so you could also use it as a new base.</p> Source code in <code>client/ayon_blender/plugins/load/import_workfile.py</code> <pre><code>class ImportBlendLoader(plugin.BlenderLoader):\n    \"\"\"Import workfile in the current Blender scene (unmanaged)\n\n    Warning:\n        The loaded content will be unmanaged and is *not* visible in the\n        scene inventory. It's purely intended to merge content into your scene\n        so you could also use it as a new base.\n    \"\"\"\n\n    representations = {\"blend\"}\n    product_types = {\"workfile\"}\n\n    label = \"Import Workfile\"\n    order = 9\n    icon = \"arrow-circle-down\"\n    color = \"#775555\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        path = self.filepath_from_context(context)\n        append_workfile(context, path, True)\n\n        # We do not containerize imported content, it remains unmanaged\n        return\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html","title":"load_action","text":"<p>Load an action in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader","title":"<code>BlendActionLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load action from a .blend file.</p> Warning <p>Loading the same asset more then once is not properly supported at the moment.</p> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>class BlendActionLoader(plugin.BlenderLoader):\n    \"\"\"Load action from a .blend file.\n\n    Warning:\n        Loading the same asset more then once is not properly supported at the\n        moment.\n    \"\"\"\n\n    product_types = {\"action\"}\n    representations = {\"blend\"}\n\n    label = \"Link Action\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        lib_container = plugin.prepare_scene_name(folder_name, product_name)\n        container_name = plugin.prepare_scene_name(\n            folder_name, product_name, namespace\n        )\n\n        container = bpy.data.collections.new(lib_container)\n        container.name = container_name\n        containerise_existing(\n            container,\n            name,\n            namespace,\n            context,\n            self.__class__.__name__,\n        )\n\n        container_metadata = container.get(AVALON_PROPERTY)\n\n        container_metadata[\"libpath\"] = libpath\n        container_metadata[\"lib_container\"] = lib_container\n\n        relative = bpy.context.preferences.filepaths.use_relative_paths\n        with bpy.data.libraries.load(\n            libpath, link=True, relative=relative\n        ) as (_, data_to):\n            data_to.collections = [lib_container]\n\n        collection = bpy.context.scene.collection\n\n        collection.children.link(bpy.data.collections[lib_container])\n\n        animation_container = collection.children[lib_container].make_local()\n\n        objects_list = []\n\n        # Link meshes first, then armatures.\n        # The armature is unparented for all the non-local meshes,\n        # when it is made local.\n        for obj in animation_container.objects:\n\n            obj = obj.make_local()\n\n            anim_data = obj.animation_data\n\n            if anim_data is not None and anim_data.action is not None:\n\n                anim_data.action.make_local()\n\n            if not obj.get(AVALON_PROPERTY):\n\n                obj[AVALON_PROPERTY] = dict()\n\n            avalon_info = obj[AVALON_PROPERTY]\n            avalon_info.update({\"container_name\": container_name})\n\n            objects_list.append(obj)\n\n        animation_container.pop(AVALON_PROPERTY)\n\n        # Save the list of objects in the metadata container\n        container_metadata[\"objects\"] = objects_list\n\n        bpy.ops.object.select_all(action='DESELECT')\n\n        nodes = list(container.objects)\n        nodes.append(container)\n        self[:] = nodes\n        return nodes\n\n    def update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        collection = bpy.data.collections.get(\n            container[\"objectName\"]\n        )\n\n        libpath = Path(get_representation_path(repre_entity))\n        extension = libpath.suffix.lower()\n\n        logger.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert collection, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert not (collection.children), (\n            \"Nested collections are not supported.\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in plugin.VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        collection_metadata = collection.get(AVALON_PROPERTY)\n\n        collection_libpath = collection_metadata[\"libpath\"]\n        normalized_collection_libpath = (\n            str(Path(bpy.path.abspath(collection_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        logger.debug(\n            \"normalized_collection_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_collection_libpath,\n            normalized_libpath,\n        )\n        if normalized_collection_libpath == normalized_libpath:\n            logger.info(\"Library already loaded, not updating...\")\n            return\n\n        strips = []\n\n        for obj in list(collection_metadata[\"objects\"]):\n            # Get all the strips that use the action\n            arm_objs = [\n                arm for arm in bpy.data.objects if arm.type == 'ARMATURE']\n\n            for armature_obj in arm_objs:\n                if armature_obj.animation_data is not None:\n                    for track in armature_obj.animation_data.nla_tracks:\n                        for strip in track.strips:\n                            if strip.action == obj.animation_data.action:\n                                strips.append(strip)\n\n            bpy.data.actions.remove(obj.animation_data.action)\n            bpy.data.objects.remove(obj)\n\n        lib_container = collection_metadata[\"lib_container\"]\n\n        bpy.data.collections.remove(bpy.data.collections[lib_container])\n\n        relative = bpy.context.preferences.filepaths.use_relative_paths\n        with bpy.data.libraries.load(\n            str(libpath), link=True, relative=relative\n        ) as (_, data_to):\n            data_to.collections = [lib_container]\n\n        scene = bpy.context.scene\n\n        scene.collection.children.link(bpy.data.collections[lib_container])\n\n        anim_container = scene.collection.children[lib_container].make_local()\n\n        objects_list = []\n\n        # Link meshes first, then armatures.\n        # The armature is unparented for all the non-local meshes,\n        # when it is made local.\n        for obj in anim_container.objects:\n\n            obj = obj.make_local()\n\n            anim_data = obj.animation_data\n\n            if anim_data is not None and anim_data.action is not None:\n\n                anim_data.action.make_local()\n\n                for strip in strips:\n\n                    strip.action = anim_data.action\n                    strip.action_frame_end = anim_data.action.frame_range[1]\n\n            if not obj.get(AVALON_PROPERTY):\n\n                obj[AVALON_PROPERTY] = dict()\n\n            avalon_info = obj[AVALON_PROPERTY]\n            avalon_info.update({\"container_name\": collection.name})\n\n            objects_list.append(obj)\n\n        anim_container.pop(AVALON_PROPERTY)\n\n        # Save the list of objects in the metadata container\n        collection_metadata[\"objects\"] = objects_list\n        collection_metadata[\"libpath\"] = str(libpath)\n        collection_metadata[\"representation\"] = repre_entity[\"id\"]\n        collection_metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n        bpy.ops.object.select_all(action='DESELECT')\n\n    def remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (openpype:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n\n        collection = bpy.data.collections.get(\n            container[\"objectName\"]\n        )\n        if not collection:\n            return False\n        assert not (collection.children), (\n            \"Nested collections are not supported.\"\n        )\n\n        collection_metadata = collection.get(AVALON_PROPERTY)\n        objects = collection_metadata[\"objects\"]\n        lib_container = collection_metadata[\"lib_container\"]\n\n        for obj in list(objects):\n            # Get all the strips that use the action\n            arm_objs = [\n                arm for arm in bpy.data.objects if arm.type == 'ARMATURE']\n\n            for armature_obj in arm_objs:\n                if armature_obj.animation_data is not None:\n                    for track in armature_obj.animation_data.nla_tracks:\n                        for strip in track.strips:\n                            if strip.action == obj.animation_data.action:\n                                track.strips.remove(strip)\n\n            bpy.data.actions.remove(obj.animation_data.action)\n            bpy.data.objects.remove(obj)\n\n        bpy.data.collections.remove(bpy.data.collections[lib_container])\n        bpy.data.collections.remove(collection)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n    lib_container = plugin.prepare_scene_name(folder_name, product_name)\n    container_name = plugin.prepare_scene_name(\n        folder_name, product_name, namespace\n    )\n\n    container = bpy.data.collections.new(lib_container)\n    container.name = container_name\n    containerise_existing(\n        container,\n        name,\n        namespace,\n        context,\n        self.__class__.__name__,\n    )\n\n    container_metadata = container.get(AVALON_PROPERTY)\n\n    container_metadata[\"libpath\"] = libpath\n    container_metadata[\"lib_container\"] = lib_container\n\n    relative = bpy.context.preferences.filepaths.use_relative_paths\n    with bpy.data.libraries.load(\n        libpath, link=True, relative=relative\n    ) as (_, data_to):\n        data_to.collections = [lib_container]\n\n    collection = bpy.context.scene.collection\n\n    collection.children.link(bpy.data.collections[lib_container])\n\n    animation_container = collection.children[lib_container].make_local()\n\n    objects_list = []\n\n    # Link meshes first, then armatures.\n    # The armature is unparented for all the non-local meshes,\n    # when it is made local.\n    for obj in animation_container.objects:\n\n        obj = obj.make_local()\n\n        anim_data = obj.animation_data\n\n        if anim_data is not None and anim_data.action is not None:\n\n            anim_data.action.make_local()\n\n        if not obj.get(AVALON_PROPERTY):\n\n            obj[AVALON_PROPERTY] = dict()\n\n        avalon_info = obj[AVALON_PROPERTY]\n        avalon_info.update({\"container_name\": container_name})\n\n        objects_list.append(obj)\n\n    animation_container.pop(AVALON_PROPERTY)\n\n    # Save the list of objects in the metadata container\n    container_metadata[\"objects\"] = objects_list\n\n    bpy.ops.object.select_all(action='DESELECT')\n\n    nodes = list(container.objects)\n    nodes.append(container)\n    self[:] = nodes\n    return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>def remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (openpype:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n\n    collection = bpy.data.collections.get(\n        container[\"objectName\"]\n    )\n    if not collection:\n        return False\n    assert not (collection.children), (\n        \"Nested collections are not supported.\"\n    )\n\n    collection_metadata = collection.get(AVALON_PROPERTY)\n    objects = collection_metadata[\"objects\"]\n    lib_container = collection_metadata[\"lib_container\"]\n\n    for obj in list(objects):\n        # Get all the strips that use the action\n        arm_objs = [\n            arm for arm in bpy.data.objects if arm.type == 'ARMATURE']\n\n        for armature_obj in arm_objs:\n            if armature_obj.animation_data is not None:\n                for track in armature_obj.animation_data.nla_tracks:\n                    for strip in track.strips:\n                        if strip.action == obj.animation_data.action:\n                            track.strips.remove(strip)\n\n        bpy.data.actions.remove(obj.animation_data.action)\n        bpy.data.objects.remove(obj)\n\n    bpy.data.collections.remove(bpy.data.collections[lib_container])\n    bpy.data.collections.remove(collection)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>def update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    collection = bpy.data.collections.get(\n        container[\"objectName\"]\n    )\n\n    libpath = Path(get_representation_path(repre_entity))\n    extension = libpath.suffix.lower()\n\n    logger.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert collection, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert not (collection.children), (\n        \"Nested collections are not supported.\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in plugin.VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    collection_metadata = collection.get(AVALON_PROPERTY)\n\n    collection_libpath = collection_metadata[\"libpath\"]\n    normalized_collection_libpath = (\n        str(Path(bpy.path.abspath(collection_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    logger.debug(\n        \"normalized_collection_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_collection_libpath,\n        normalized_libpath,\n    )\n    if normalized_collection_libpath == normalized_libpath:\n        logger.info(\"Library already loaded, not updating...\")\n        return\n\n    strips = []\n\n    for obj in list(collection_metadata[\"objects\"]):\n        # Get all the strips that use the action\n        arm_objs = [\n            arm for arm in bpy.data.objects if arm.type == 'ARMATURE']\n\n        for armature_obj in arm_objs:\n            if armature_obj.animation_data is not None:\n                for track in armature_obj.animation_data.nla_tracks:\n                    for strip in track.strips:\n                        if strip.action == obj.animation_data.action:\n                            strips.append(strip)\n\n        bpy.data.actions.remove(obj.animation_data.action)\n        bpy.data.objects.remove(obj)\n\n    lib_container = collection_metadata[\"lib_container\"]\n\n    bpy.data.collections.remove(bpy.data.collections[lib_container])\n\n    relative = bpy.context.preferences.filepaths.use_relative_paths\n    with bpy.data.libraries.load(\n        str(libpath), link=True, relative=relative\n    ) as (_, data_to):\n        data_to.collections = [lib_container]\n\n    scene = bpy.context.scene\n\n    scene.collection.children.link(bpy.data.collections[lib_container])\n\n    anim_container = scene.collection.children[lib_container].make_local()\n\n    objects_list = []\n\n    # Link meshes first, then armatures.\n    # The armature is unparented for all the non-local meshes,\n    # when it is made local.\n    for obj in anim_container.objects:\n\n        obj = obj.make_local()\n\n        anim_data = obj.animation_data\n\n        if anim_data is not None and anim_data.action is not None:\n\n            anim_data.action.make_local()\n\n            for strip in strips:\n\n                strip.action = anim_data.action\n                strip.action_frame_end = anim_data.action.frame_range[1]\n\n        if not obj.get(AVALON_PROPERTY):\n\n            obj[AVALON_PROPERTY] = dict()\n\n        avalon_info = obj[AVALON_PROPERTY]\n        avalon_info.update({\"container_name\": collection.name})\n\n        objects_list.append(obj)\n\n    anim_container.pop(AVALON_PROPERTY)\n\n    # Save the list of objects in the metadata container\n    collection_metadata[\"objects\"] = objects_list\n    collection_metadata[\"libpath\"] = str(libpath)\n    collection_metadata[\"representation\"] = repre_entity[\"id\"]\n    collection_metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    bpy.ops.object.select_all(action='DESELECT')\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_animation.html","title":"load_animation","text":"<p>Load an animation in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_animation.html#client.ayon_blender.plugins.load.load_animation.BlendAnimationLoader","title":"<code>BlendAnimationLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load animations from a .blend file.</p> Warning <p>Loading the same asset more then once is not properly supported at the moment.</p> Source code in <code>client/ayon_blender/plugins/load/load_animation.py</code> <pre><code>class BlendAnimationLoader(plugin.BlenderLoader):\n    \"\"\"Load animations from a .blend file.\n\n    Warning:\n        Loading the same asset more then once is not properly supported at the\n        moment.\n    \"\"\"\n\n    product_types = {\"animation\"}\n    representations = {\"blend\"}\n\n    label = \"Link Animation\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n\n        with bpy.data.libraries.load(\n            libpath, link=True, relative=False\n        ) as (data_from, data_to):\n            data_to.objects = data_from.objects\n            data_to.actions = data_from.actions\n\n        container = data_to.objects[0]\n\n        assert container, \"No asset group found\"\n\n        target_namespace = container.get(AVALON_PROPERTY).get('namespace', namespace)\n\n        action = data_to.actions[0].make_local().copy()\n\n        for obj in bpy.data.objects:\n            if obj.get(AVALON_PROPERTY) and obj.get(AVALON_PROPERTY).get(\n                    'namespace', namespace) == target_namespace:\n                if obj.children[0]:\n                    if not obj.children[0].animation_data:\n                        obj.children[0].animation_data_create()\n                    obj.children[0].animation_data.action = action\n                break\n\n        bpy.data.objects.remove(container)\n\n        filename = bpy.path.basename(libpath)\n        # Blender has a limit of 63 characters for any data name.\n        # If the filename is longer, it will be truncated.\n        if len(filename) &gt; 63:\n            filename = filename[:63]\n        library = bpy.data.libraries.get(filename)\n        bpy.data.libraries.remove(library)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_animation.html#client.ayon_blender.plugins.load.load_animation.BlendAnimationLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_animation.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n\n    with bpy.data.libraries.load(\n        libpath, link=True, relative=False\n    ) as (data_from, data_to):\n        data_to.objects = data_from.objects\n        data_to.actions = data_from.actions\n\n    container = data_to.objects[0]\n\n    assert container, \"No asset group found\"\n\n    target_namespace = container.get(AVALON_PROPERTY).get('namespace', namespace)\n\n    action = data_to.actions[0].make_local().copy()\n\n    for obj in bpy.data.objects:\n        if obj.get(AVALON_PROPERTY) and obj.get(AVALON_PROPERTY).get(\n                'namespace', namespace) == target_namespace:\n            if obj.children[0]:\n                if not obj.children[0].animation_data:\n                    obj.children[0].animation_data_create()\n                obj.children[0].animation_data.action = action\n            break\n\n    bpy.data.objects.remove(container)\n\n    filename = bpy.path.basename(libpath)\n    # Blender has a limit of 63 characters for any data name.\n    # If the filename is longer, it will be truncated.\n    if len(filename) &gt; 63:\n        filename = filename[:63]\n    library = bpy.data.libraries.get(filename)\n    bpy.data.libraries.remove(library)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html","title":"load_audio","text":"<p>Load audio in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader","title":"<code>AudioLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load audio in Blender.</p> Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>class AudioLoader(plugin.BlenderLoader):\n    \"\"\"Load audio in Blender.\"\"\"\n\n    product_types = {\"audio\"}\n    representations = {\"wav\"}\n\n    label = \"Load Audio\"\n    icon = \"volume-up\"\n    color = \"orange\"\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not avalon_container:\n            avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(avalon_container)\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        avalon_container.objects.link(asset_group)\n\n        # Blender needs the Sequence Editor in the current window, to be able\n        # to load the audio. We take one of the areas in the window, save its\n        # type, and switch to the Sequence Editor. After loading the audio,\n        # we switch back to the previous area.\n        window_manager = bpy.context.window_manager\n        old_type = window_manager.windows[-1].screen.areas[0].type\n        window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n        # We override the context to load the audio in the sequence editor.\n        oc = bpy.context.copy()\n        oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n        with bpy.context.temp_override(**oc):\n            bpy.ops.sequencer.sound_strip_add(filepath=libpath, frame_start=1)\n\n        window_manager.windows[-1].screen.areas[0].type = old_type\n\n        p = Path(libpath)\n        audio = p.name\n\n        asset_group[AVALON_PROPERTY] = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"audio\": audio,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        objects = []\n        self[:] = objects\n        return [objects]\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update an audio strip in the sequence editor.\n\n        Arguments:\n            container (openpype:container-1.0): Container to update,\n                from `host.ls()`.\n            representation (openpype:representation-1.0): Representation to\n                update, from `host.ls()`.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(get_representation_path(repre_entity))\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n\n        metadata = asset_group.get(AVALON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        old_audio = container[\"audio\"]\n        p = Path(libpath)\n        new_audio = p.name\n\n        # Blender needs the Sequence Editor in the current window, to be able\n        # to update the audio. We take one of the areas in the window, save its\n        # type, and switch to the Sequence Editor. After updating the audio,\n        # we switch back to the previous area.\n        window_manager = bpy.context.window_manager\n        old_type = window_manager.windows[-1].screen.areas[0].type\n        window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n        # We override the context to load the audio in the sequence editor.\n        oc = bpy.context.copy()\n        oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n        with bpy.context.temp_override(**oc):\n            # We deselect all sequencer strips, and then select the one we\n            # need to remove.\n            bpy.ops.sequencer.select_all(action='DESELECT')\n            scene = bpy.context.scene\n            scene.sequence_editor.sequences_all[old_audio].select = True\n\n            bpy.ops.sequencer.delete()\n            bpy.data.sounds.remove(bpy.data.sounds[old_audio])\n\n            bpy.ops.sequencer.sound_strip_add(\n                filepath=str(libpath), frame_start=1)\n\n        window_manager.windows[-1].screen.areas[0].type = old_type\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"parent\"] = repre_entity[\"versionId\"]\n        metadata[\"audio\"] = new_audio\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an audio strip from the sequence editor and the container.\n\n        Arguments:\n            container (openpype:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        audio = container[\"audio\"]\n\n        # Blender needs the Sequence Editor in the current window, to be able\n        # to remove the audio. We take one of the areas in the window, save its\n        # type, and switch to the Sequence Editor. After removing the audio,\n        # we switch back to the previous area.\n        window_manager = bpy.context.window_manager\n        old_type = window_manager.windows[-1].screen.areas[0].type\n        window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n        # We override the context to load the audio in the sequence editor.\n        oc = bpy.context.copy()\n        oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n        with bpy.context.temp_override(**oc):\n            # We deselect all sequencer strips, and then select the one we\n            # need to remove.\n            bpy.ops.sequencer.select_all(action='DESELECT')\n            scene = bpy.context.scene\n            scene.sequence_editor.sequences_all[audio].select = True\n            bpy.ops.sequencer.delete()\n\n        window_manager.windows[-1].screen.areas[0].type = old_type\n\n        bpy.data.sounds.remove(bpy.data.sounds[audio])\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an audio strip from the sequence editor and the container.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an audio strip from the sequence editor and the container.\n\n    Arguments:\n        container (openpype:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    audio = container[\"audio\"]\n\n    # Blender needs the Sequence Editor in the current window, to be able\n    # to remove the audio. We take one of the areas in the window, save its\n    # type, and switch to the Sequence Editor. After removing the audio,\n    # we switch back to the previous area.\n    window_manager = bpy.context.window_manager\n    old_type = window_manager.windows[-1].screen.areas[0].type\n    window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n    # We override the context to load the audio in the sequence editor.\n    oc = bpy.context.copy()\n    oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n    with bpy.context.temp_override(**oc):\n        # We deselect all sequencer strips, and then select the one we\n        # need to remove.\n        bpy.ops.sequencer.select_all(action='DESELECT')\n        scene = bpy.context.scene\n        scene.sequence_editor.sequences_all[audio].select = True\n        bpy.ops.sequencer.delete()\n\n    window_manager.windows[-1].screen.areas[0].type = old_type\n\n    bpy.data.sounds.remove(bpy.data.sounds[audio])\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update an audio strip in the sequence editor.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to update, from <code>host.ls()</code>.</p> required <code>representation</code> <code>openpype</code> <p>representation-1.0): Representation to update, from <code>host.ls()</code>.</p> required Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update an audio strip in the sequence editor.\n\n    Arguments:\n        container (openpype:container-1.0): Container to update,\n            from `host.ls()`.\n        representation (openpype:representation-1.0): Representation to\n            update, from `host.ls()`.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(get_representation_path(repre_entity))\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n\n    metadata = asset_group.get(AVALON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    old_audio = container[\"audio\"]\n    p = Path(libpath)\n    new_audio = p.name\n\n    # Blender needs the Sequence Editor in the current window, to be able\n    # to update the audio. We take one of the areas in the window, save its\n    # type, and switch to the Sequence Editor. After updating the audio,\n    # we switch back to the previous area.\n    window_manager = bpy.context.window_manager\n    old_type = window_manager.windows[-1].screen.areas[0].type\n    window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n    # We override the context to load the audio in the sequence editor.\n    oc = bpy.context.copy()\n    oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n    with bpy.context.temp_override(**oc):\n        # We deselect all sequencer strips, and then select the one we\n        # need to remove.\n        bpy.ops.sequencer.select_all(action='DESELECT')\n        scene = bpy.context.scene\n        scene.sequence_editor.sequences_all[old_audio].select = True\n\n        bpy.ops.sequencer.delete()\n        bpy.data.sounds.remove(bpy.data.sounds[old_audio])\n\n        bpy.ops.sequencer.sound_strip_add(\n            filepath=str(libpath), frame_start=1)\n\n    window_manager.windows[-1].screen.areas[0].type = old_type\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"parent\"] = repre_entity[\"versionId\"]\n    metadata[\"audio\"] = new_audio\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    avalon_container.objects.link(asset_group)\n\n    # Blender needs the Sequence Editor in the current window, to be able\n    # to load the audio. We take one of the areas in the window, save its\n    # type, and switch to the Sequence Editor. After loading the audio,\n    # we switch back to the previous area.\n    window_manager = bpy.context.window_manager\n    old_type = window_manager.windows[-1].screen.areas[0].type\n    window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n    # We override the context to load the audio in the sequence editor.\n    oc = bpy.context.copy()\n    oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n    with bpy.context.temp_override(**oc):\n        bpy.ops.sequencer.sound_strip_add(filepath=libpath, frame_start=1)\n\n    window_manager.windows[-1].screen.areas[0].type = old_type\n\n    p = Path(libpath)\n    audio = p.name\n\n    asset_group[AVALON_PROPERTY] = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"audio\": audio,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    objects = []\n    self[:] = objects\n    return [objects]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html","title":"load_blend","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader","title":"<code>BlendLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load assets from a .blend file.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>class BlendLoader(plugin.BlenderLoader):\n    \"\"\"Load assets from a .blend file.\"\"\"\n\n    product_types = {\"model\", \"rig\", \"layout\", \"camera\"}\n    representations = {\"blend\"}\n\n    label = \"Append Blend\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    @staticmethod\n    def _get_asset_container(objects):\n        empties = [obj for obj in objects if obj.type == 'EMPTY']\n\n        for empty in empties:\n            if empty.get(AVALON_PROPERTY) and empty.parent is None:\n                return empty\n\n        return None\n\n    @staticmethod\n    def get_all_container_parents(asset_group):\n        parent_containers = []\n        parent = asset_group.parent\n        while parent:\n            if parent.get(AVALON_PROPERTY):\n                parent_containers.append(parent)\n            parent = parent.parent\n\n        return parent_containers\n\n    def _post_process_layout(self, container, asset, representation):\n        rigs = [\n            obj for obj in container.children_recursive\n            if (\n                obj.type == 'EMPTY' and\n                obj.get(AVALON_PROPERTY) and\n                obj.get(AVALON_PROPERTY).get('family') == 'rig'\n            )\n        ]\n        if not rigs:\n            return\n\n        # Create animation instances for each rig\n        creator_identifier = \"io.openpype.creators.blender.animation\"\n        host = registered_host()\n        create_context = CreateContext(host)\n\n        for rig in rigs:\n            create_context.create(\n                creator_identifier=creator_identifier,\n                variant=rig.name.split(':')[-1],\n                pre_create_data={\n                    \"use_selection\": False,\n                    \"asset_group\": rig\n                }\n            )\n\n    def _process_data(self, libpath, group_name):\n        # Append all the data from the .blend file\n        with bpy.data.libraries.load(\n            libpath, link=False, relative=False\n        ) as (data_from, data_to):\n            for attr in dir(data_to):\n                setattr(data_to, attr, getattr(data_from, attr))\n\n        members = []\n\n        # Rename the object to add the asset name\n        for attr in dir(data_to):\n            for data in getattr(data_to, attr):\n                data.name = f\"{group_name}:{data.name}\"\n                members.append(data)\n\n        container = self._get_asset_container(data_to.objects)\n        assert container, \"No asset group found\"\n\n        container.name = group_name\n        container.empty_display_type = 'SINGLE_ARROW'\n\n        # Link the collection to the scene\n        bpy.context.scene.collection.objects.link(container)\n\n        # Link all the container children to the collection\n        for obj in container.children_recursive:\n            bpy.context.scene.collection.objects.link(obj)\n\n        # Remove the library from the blend file\n        filepath = bpy.path.basename(libpath)\n        # Blender has a limit of 63 characters for any data name.\n        # If the filepath is longer, it will be truncated.\n        if len(filepath) &gt; 63:\n            filepath = filepath[:63]\n        library = bpy.data.libraries.get(filepath)\n        bpy.data.libraries.remove(library)\n\n        return container, members\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        try:\n            product_type = context[\"product\"][\"productType\"]\n        except ValueError:\n            product_type = \"model\"\n\n        representation = context[\"representation\"][\"id\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not avalon_container:\n            avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(avalon_container)\n\n        container, members = self._process_data(libpath, group_name)\n\n        if product_type == \"layout\":\n            self._post_process_layout(container, folder_name, representation)\n\n        avalon_container.objects.link(container)\n\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        container[AVALON_PROPERTY] = data\n\n        objects = [\n            obj for obj in bpy.data.objects\n            if obj.name.startswith(f\"{group_name}:\")\n        ]\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"\n        Update the loaded asset.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(group_name)\n        libpath = Path(get_representation_path(repre_entity)).as_posix()\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n\n        transform = asset_group.matrix_basis.copy()\n        old_data = dict(asset_group.get(AVALON_PROPERTY))\n        old_members = old_data.get(\"members\", [])\n        parent = asset_group.parent\n\n        actions = {}\n        objects_with_anim = [\n            obj for obj in asset_group.children_recursive\n            if obj.animation_data]\n        for obj in objects_with_anim:\n            # Check if the object has an action and, if so, add it to a dict\n            # so we can restore it later. Save and restore the action only\n            # if it wasn't originally loaded from the current asset.\n            if obj.animation_data.action not in old_members:\n                actions[obj.name] = obj.animation_data.action\n\n        self.exec_remove(container)\n\n        asset_group, members = self._process_data(libpath, group_name)\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        avalon_container.objects.link(asset_group)\n\n        asset_group.matrix_basis = transform\n        asset_group.parent = parent\n\n        # Restore the actions\n        for obj in asset_group.children_recursive:\n            if obj.name in actions:\n                if not obj.animation_data:\n                    obj.animation_data_create()\n                obj.animation_data.action = actions[obj.name]\n\n        # Restore the old data, but reset members, as they don't exist anymore\n        # This avoids a crash, because the memory addresses of those members\n        # are not valid anymore\n        old_data[\"members\"] = []\n        asset_group[AVALON_PROPERTY] = old_data\n\n        new_data = {\n            \"libpath\": libpath,\n            \"representation\": repre_entity[\"id\"],\n            \"parent\": repre_entity[\"versionId\"],\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        imprint(asset_group, new_data)\n\n        # We need to update all the parent container members\n        parent_containers = self.get_all_container_parents(asset_group)\n\n        for parent_container in parent_containers:\n            parent_members = parent_container[AVALON_PROPERTY][\"members\"]\n            parent_container[AVALON_PROPERTY][\"members\"] = (\n                parent_members + members)\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"\n        Remove an existing container from a Blender scene.\n        \"\"\"\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(group_name)\n\n        attrs = [\n            attr for attr in dir(bpy.data)\n            if isinstance(\n                getattr(bpy.data, attr),\n                bpy.types.bpy_prop_collection\n            )\n        ]\n\n        members = asset_group.get(AVALON_PROPERTY).get(\"members\", [])\n\n        # We need to update all the parent container members\n        parent_containers = self.get_all_container_parents(asset_group)\n\n        for parent in parent_containers:\n            parent.get(AVALON_PROPERTY)[\"members\"] = list(filter(\n                lambda i: i not in members,\n                parent.get(AVALON_PROPERTY).get(\"members\", [])))\n\n        for attr in attrs:\n            for data in getattr(bpy.data, attr):\n                if data in members:\n                    # Skip the asset group\n                    if data == asset_group:\n                        continue\n                    getattr(bpy.data, attr).remove(data)\n\n        bpy.data.objects.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"\n    Remove an existing container from a Blender scene.\n    \"\"\"\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(group_name)\n\n    attrs = [\n        attr for attr in dir(bpy.data)\n        if isinstance(\n            getattr(bpy.data, attr),\n            bpy.types.bpy_prop_collection\n        )\n    ]\n\n    members = asset_group.get(AVALON_PROPERTY).get(\"members\", [])\n\n    # We need to update all the parent container members\n    parent_containers = self.get_all_container_parents(asset_group)\n\n    for parent in parent_containers:\n        parent.get(AVALON_PROPERTY)[\"members\"] = list(filter(\n            lambda i: i not in members,\n            parent.get(AVALON_PROPERTY).get(\"members\", [])))\n\n    for attr in attrs:\n        for data in getattr(bpy.data, attr):\n            if data in members:\n                # Skip the asset group\n                if data == asset_group:\n                    continue\n                getattr(bpy.data, attr).remove(data)\n\n    bpy.data.objects.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"\n    Update the loaded asset.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(group_name)\n    libpath = Path(get_representation_path(repre_entity)).as_posix()\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n\n    transform = asset_group.matrix_basis.copy()\n    old_data = dict(asset_group.get(AVALON_PROPERTY))\n    old_members = old_data.get(\"members\", [])\n    parent = asset_group.parent\n\n    actions = {}\n    objects_with_anim = [\n        obj for obj in asset_group.children_recursive\n        if obj.animation_data]\n    for obj in objects_with_anim:\n        # Check if the object has an action and, if so, add it to a dict\n        # so we can restore it later. Save and restore the action only\n        # if it wasn't originally loaded from the current asset.\n        if obj.animation_data.action not in old_members:\n            actions[obj.name] = obj.animation_data.action\n\n    self.exec_remove(container)\n\n    asset_group, members = self._process_data(libpath, group_name)\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    avalon_container.objects.link(asset_group)\n\n    asset_group.matrix_basis = transform\n    asset_group.parent = parent\n\n    # Restore the actions\n    for obj in asset_group.children_recursive:\n        if obj.name in actions:\n            if not obj.animation_data:\n                obj.animation_data_create()\n            obj.animation_data.action = actions[obj.name]\n\n    # Restore the old data, but reset members, as they don't exist anymore\n    # This avoids a crash, because the memory addresses of those members\n    # are not valid anymore\n    old_data[\"members\"] = []\n    asset_group[AVALON_PROPERTY] = old_data\n\n    new_data = {\n        \"libpath\": libpath,\n        \"representation\": repre_entity[\"id\"],\n        \"parent\": repre_entity[\"versionId\"],\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    imprint(asset_group, new_data)\n\n    # We need to update all the parent container members\n    parent_containers = self.get_all_container_parents(asset_group)\n\n    for parent_container in parent_containers:\n        parent_members = parent_container[AVALON_PROPERTY][\"members\"]\n        parent_container[AVALON_PROPERTY][\"members\"] = (\n            parent_members + members)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    try:\n        product_type = context[\"product\"][\"productType\"]\n    except ValueError:\n        product_type = \"model\"\n\n    representation = context[\"representation\"][\"id\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    container, members = self._process_data(libpath, group_name)\n\n    if product_type == \"layout\":\n        self._post_process_layout(container, folder_name, representation)\n\n    avalon_container.objects.link(container)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    container[AVALON_PROPERTY] = data\n\n    objects = [\n        obj for obj in bpy.data.objects\n        if obj.name.startswith(f\"{group_name}:\")\n    ]\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html","title":"load_blendscene","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader","title":"<code>BlendSceneLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load assets from a .blend file.</p> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>class BlendSceneLoader(plugin.BlenderLoader):\n    \"\"\"Load assets from a .blend file.\"\"\"\n\n    product_types = {\"blendScene\"}\n    representations = {\"blend\"}\n\n    label = \"Append Blend\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    @staticmethod\n    def _get_asset_container(collections):\n        for coll in collections:\n            parents = [c for c in collections if c.user_of_id(coll)]\n            if coll.get(AVALON_PROPERTY) and not parents:\n                return coll\n\n        return None\n\n    def _process_data(self, libpath, group_name, product_type):\n        # Append all the data from the .blend file\n        with bpy.data.libraries.load(\n            libpath, link=False, relative=False\n        ) as (data_from, data_to):\n            for attr in dir(data_to):\n                setattr(data_to, attr, getattr(data_from, attr))\n\n        members = []\n\n        # Rename the object to add the asset name\n        for attr in dir(data_to):\n            for data in getattr(data_to, attr):\n                data.name = f\"{group_name}:{data.name}\"\n                members.append(data)\n\n        container = self._get_asset_container(\n            data_to.collections)\n        assert container, \"No asset group found\"\n\n        container.name = group_name\n\n        # Link the group to the scene\n        bpy.context.scene.collection.children.link(container)\n\n        # Remove the library from the blend file\n        filepath = bpy.path.basename(libpath)\n        # Blender has a limit of 63 characters for any data name.\n        # If the filepath is longer, it will be truncated.\n        if len(filepath) &gt; 63:\n            filepath = filepath[:63]\n        library = bpy.data.libraries.get(filepath)\n        bpy.data.libraries.remove(library)\n\n        return container, members\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        try:\n            product_type = context[\"product\"][\"productType\"]\n        except ValueError:\n            product_type = \"model\"\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not avalon_container:\n            avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(avalon_container)\n\n        container, members = self._process_data(\n            libpath, group_name, product_type\n        )\n\n        avalon_container.children.link(container)\n\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        container[AVALON_PROPERTY] = data\n\n        objects = [\n            obj for obj in bpy.data.objects\n            if obj.name.startswith(f\"{group_name}:\")\n        ]\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"\n        Update the loaded asset.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.collections.get(group_name)\n        libpath = Path(get_representation_path(repre_entity)).as_posix()\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n\n        # Get the parents of the members of the asset group, so we can\n        # re-link them after the update.\n        # Also gets the transform for each object to reapply after the update.\n        collection_parents = {}\n        member_transforms = {}\n        members = asset_group.get(AVALON_PROPERTY).get(\"members\", [])\n        loaded_collections = {c for c in bpy.data.collections if c in members}\n        loaded_collections.add(bpy.data.collections.get(AVALON_CONTAINERS))\n        for member in members:\n            if isinstance(member, bpy.types.Object):\n                member_parents = set(member.users_collection)\n                member_transforms[member.name] = member.matrix_basis.copy()\n            elif isinstance(member, bpy.types.Collection):\n                member_parents = {\n                    c for c in bpy.data.collections if c.user_of_id(member)}\n            else:\n                continue\n\n            member_parents = member_parents.difference(loaded_collections)\n            if member_parents:\n                collection_parents[member.name] = list(member_parents)\n\n        old_data = dict(asset_group.get(AVALON_PROPERTY))\n\n        self.exec_remove(container)\n\n        product_type = container.get(\"productType\")\n        if product_type is None:\n            product_type = container[\"family\"]\n        asset_group, members = self._process_data(\n            libpath, group_name, product_type\n        )\n\n        for member in members:\n            if member.name in collection_parents:\n                for parent in collection_parents[member.name]:\n                    if isinstance(member, bpy.types.Object):\n                        parent.objects.link(member)\n                    elif isinstance(member, bpy.types.Collection):\n                        parent.children.link(member)\n            if member.name in member_transforms and isinstance(\n                member, bpy.types.Object\n            ):\n                member.matrix_basis = member_transforms[member.name]\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        avalon_container.children.link(asset_group)\n\n        # Restore the old data, but reset members, as they don't exist anymore\n        # This avoids a crash, because the memory addresses of those members\n        # are not valid anymore\n        old_data[\"members\"] = []\n        asset_group[AVALON_PROPERTY] = old_data\n\n        new_data = {\n            \"libpath\": libpath,\n            \"representation\": repre_entity[\"id\"],\n            \"parent\": repre_entity[\"versionId\"],\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        imprint(asset_group, new_data)\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"\n        Remove an existing container from a Blender scene.\n        \"\"\"\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.collections.get(group_name)\n\n        members = set(asset_group.get(AVALON_PROPERTY).get(\"members\", []))\n\n        if members:\n            for attr_name in dir(bpy.data):\n                attr = getattr(bpy.data, attr_name)\n                if not isinstance(attr, bpy.types.bpy_prop_collection):\n                    continue\n\n                # ensure to make a list copy because we\n                # we remove members as we iterate\n                for data in list(attr):\n                    if data not in members or data == asset_group:\n                        continue\n\n                    attr.remove(data)\n\n        bpy.data.collections.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"\n    Remove an existing container from a Blender scene.\n    \"\"\"\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.collections.get(group_name)\n\n    members = set(asset_group.get(AVALON_PROPERTY).get(\"members\", []))\n\n    if members:\n        for attr_name in dir(bpy.data):\n            attr = getattr(bpy.data, attr_name)\n            if not isinstance(attr, bpy.types.bpy_prop_collection):\n                continue\n\n            # ensure to make a list copy because we\n            # we remove members as we iterate\n            for data in list(attr):\n                if data not in members or data == asset_group:\n                    continue\n\n                attr.remove(data)\n\n    bpy.data.collections.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"\n    Update the loaded asset.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.collections.get(group_name)\n    libpath = Path(get_representation_path(repre_entity)).as_posix()\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n\n    # Get the parents of the members of the asset group, so we can\n    # re-link them after the update.\n    # Also gets the transform for each object to reapply after the update.\n    collection_parents = {}\n    member_transforms = {}\n    members = asset_group.get(AVALON_PROPERTY).get(\"members\", [])\n    loaded_collections = {c for c in bpy.data.collections if c in members}\n    loaded_collections.add(bpy.data.collections.get(AVALON_CONTAINERS))\n    for member in members:\n        if isinstance(member, bpy.types.Object):\n            member_parents = set(member.users_collection)\n            member_transforms[member.name] = member.matrix_basis.copy()\n        elif isinstance(member, bpy.types.Collection):\n            member_parents = {\n                c for c in bpy.data.collections if c.user_of_id(member)}\n        else:\n            continue\n\n        member_parents = member_parents.difference(loaded_collections)\n        if member_parents:\n            collection_parents[member.name] = list(member_parents)\n\n    old_data = dict(asset_group.get(AVALON_PROPERTY))\n\n    self.exec_remove(container)\n\n    product_type = container.get(\"productType\")\n    if product_type is None:\n        product_type = container[\"family\"]\n    asset_group, members = self._process_data(\n        libpath, group_name, product_type\n    )\n\n    for member in members:\n        if member.name in collection_parents:\n            for parent in collection_parents[member.name]:\n                if isinstance(member, bpy.types.Object):\n                    parent.objects.link(member)\n                elif isinstance(member, bpy.types.Collection):\n                    parent.children.link(member)\n        if member.name in member_transforms and isinstance(\n            member, bpy.types.Object\n        ):\n            member.matrix_basis = member_transforms[member.name]\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    avalon_container.children.link(asset_group)\n\n    # Restore the old data, but reset members, as they don't exist anymore\n    # This avoids a crash, because the memory addresses of those members\n    # are not valid anymore\n    old_data[\"members\"] = []\n    asset_group[AVALON_PROPERTY] = old_data\n\n    new_data = {\n        \"libpath\": libpath,\n        \"representation\": repre_entity[\"id\"],\n        \"parent\": repre_entity[\"versionId\"],\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    imprint(asset_group, new_data)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    try:\n        product_type = context[\"product\"][\"productType\"]\n    except ValueError:\n        product_type = \"model\"\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    container, members = self._process_data(\n        libpath, group_name, product_type\n    )\n\n    avalon_container.children.link(container)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    container[AVALON_PROPERTY] = data\n\n    objects = [\n        obj for obj in bpy.data.objects\n        if obj.name.startswith(f\"{group_name}:\")\n    ]\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html","title":"load_cache","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader","title":"<code>CacheModelLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load cache models.</p> <p>Stores the imported asset in a collection named after the asset.</p> Note <p>At least for now it only supports Alembic files.</p> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>class CacheModelLoader(plugin.BlenderLoader):\n    \"\"\"Load cache models.\n\n    Stores the imported asset in a collection named after the asset.\n\n    Note:\n        At least for now it only supports Alembic files.\n    \"\"\"\n    product_types = {\"model\", \"pointcache\", \"animation\", \"usd\"}\n    representations = {\"abc\", \"usd\"}\n\n    label = \"Load Cache\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _update_transform_cache_path(self, asset_group, libpath, prev_filename):\n        \"\"\"search and update path in the transform cache modifier\n        If there is no transform cache modifier, it will create one\n        to update the filepath of the alembic.\n        \"\"\"\n        bpy.ops.cachefile.open(filepath=libpath.as_posix())\n        for obj in asset_group.children:\n            asset_name = obj.name.rsplit(\":\", 1)[-1]\n            names = [modifier.name for modifier in obj.modifiers\n                     if modifier.type == \"MESH_SEQUENCE_CACHE\"]\n            file_list = [file for file in bpy.data.cache_files\n                         if file.name.startswith(prev_filename)]\n            if names:\n                for name in names:\n                    obj.modifiers.remove(obj.modifiers.get(name))\n            if file_list:\n                bpy.data.batch_remove(file_list)\n\n            obj.modifiers.new(name='MeshSequenceCache', type='MESH_SEQUENCE_CACHE')\n\n            modifiers = lib.get_cache_modifiers(obj)\n            for asset_name, modifier_list in modifiers.items():\n                for modifier in modifier_list:\n                    if modifier.type == \"MESH_SEQUENCE_CACHE\":\n                        modifier.cache_file = bpy.data.cache_files[-1]\n                        cache_file_name = os.path.basename(libpath.as_posix())\n                        modifier.cache_file.name = cache_file_name\n                        modifier.cache_file.filepath = libpath.as_posix()\n                        modifier.cache_file.scale = 1.0\n                        for object_path in modifier.cache_file.object_paths:\n                            base_object_name = os.path.basename(object_path.path)\n                            asset_name = asset_name.rsplit(\":\", 1)[-1]\n                            if base_object_name.endswith(asset_name):\n                                modifier.object_path = object_path.path\n                        bpy.context.evaluated_depsgraph_get()\n\n        return libpath\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n        empties = []\n\n        for obj in objects:\n            if obj.type == 'MESH':\n                for material_slot in list(obj.material_slots):\n                    bpy.data.materials.remove(material_slot.material)\n                bpy.data.meshes.remove(obj.data)\n            elif obj.type == 'EMPTY':\n                objects.extend(obj.children)\n                empties.append(obj)\n\n        for empty in empties:\n            bpy.data.objects.remove(empty)\n\n    def _process(self, libpath, asset_group, group_name):\n        plugin.deselect_all()\n\n        relative = bpy.context.preferences.filepaths.use_relative_paths\n\n        if any(libpath.lower().endswith(ext)\n               for ext in [\".usd\", \".usda\", \".usdc\"]):\n            # USD\n            bpy.ops.wm.usd_import(\n                filepath=libpath,\n                relative_path=relative\n            )\n\n        else:\n            # Alembic\n            bpy.ops.wm.alembic_import(\n                filepath=libpath,\n                relative_path=relative\n            )\n\n        objects = lib.get_selection()\n\n        for obj in objects:\n            # reparent top object to asset_group\n            if not obj.parent:\n                obj.parent = asset_group\n\n            # Unlink the object from all collections\n            collections = obj.users_collection\n            for collection in collections:\n                collection.objects.unlink(obj)\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != 'EMPTY':\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n                for material_slot in obj.material_slots:\n                    name_mat = material_slot.material.name\n                    material_slot.material.name = f\"{group_name}:{name_mat}\"\n\n            if not obj.get(AVALON_PROPERTY):\n                obj[AVALON_PROPERTY] = {}\n\n            avalon_info = obj[AVALON_PROPERTY]\n            avalon_info.update({\"container_name\": group_name})\n\n        plugin.deselect_all()\n\n        return objects\n\n    def _link_objects(self, objects, collection, containers, asset_group):\n        # Link the imported objects to any collection where the asset group is\n        # linked to, except the AVALON_CONTAINERS collection\n        group_collections = [\n            collection\n            for collection in asset_group.users_collection\n            if collection != containers]\n\n        for obj in objects:\n            for collection in group_collections:\n                collection.objects.link(obj)\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        containers = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not containers:\n            containers = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(containers)\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        asset_group.empty_display_type = 'SINGLE_ARROW'\n        containers.objects.link(asset_group)\n\n        objects = self._process(libpath, asset_group, group_name)\n\n        # Link the asset group to the active collection\n        collection = bpy.context.view_layer.active_layer_collection.collection\n        collection.objects.link(asset_group)\n\n        self._link_objects(objects, asset_group, containers, asset_group)\n\n        product_type = context[\"product\"][\"productType\"]\n        asset_group[AVALON_PROPERTY] = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": product_type,\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(get_representation_path(repre_entity))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in plugin.VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AVALON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        if any(str(libpath).lower().endswith(ext)\n               for ext in [\".usd\", \".usda\", \".usdc\"]):\n            mat = asset_group.matrix_basis.copy()\n            self._remove(asset_group)\n\n            objects = self._process(str(libpath), asset_group, object_name)\n\n            containers = bpy.data.collections.get(AVALON_CONTAINERS)\n            self._link_objects(objects, asset_group, containers, asset_group)\n\n            asset_group.matrix_basis = mat\n        else:\n            prev_filename = os.path.basename(container[\"libpath\"])\n            libpath = self._update_transform_cache_path(asset_group, libpath, prev_filename)\n\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (openpype:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (openpype:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(get_representation_path(repre_entity))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in plugin.VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AVALON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    if any(str(libpath).lower().endswith(ext)\n           for ext in [\".usd\", \".usda\", \".usdc\"]):\n        mat = asset_group.matrix_basis.copy()\n        self._remove(asset_group)\n\n        objects = self._process(str(libpath), asset_group, object_name)\n\n        containers = bpy.data.collections.get(AVALON_CONTAINERS)\n        self._link_objects(objects, asset_group, containers, asset_group)\n\n        asset_group.matrix_basis = mat\n    else:\n        prev_filename = os.path.basename(container[\"libpath\"])\n        libpath = self._update_transform_cache_path(asset_group, libpath, prev_filename)\n\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    containers = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not containers:\n        containers = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(containers)\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    asset_group.empty_display_type = 'SINGLE_ARROW'\n    containers.objects.link(asset_group)\n\n    objects = self._process(libpath, asset_group, group_name)\n\n    # Link the asset group to the active collection\n    collection = bpy.context.view_layer.active_layer_collection.collection\n    collection.objects.link(asset_group)\n\n    self._link_objects(objects, asset_group, containers, asset_group)\n\n    product_type = context[\"product\"][\"productType\"]\n    asset_group[AVALON_PROPERTY] = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": product_type,\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html","title":"load_camera_abc","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader","title":"<code>AbcCameraLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load a camera from Alembic file.</p> <p>Stores the imported asset in an empty named after the asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>class AbcCameraLoader(plugin.BlenderLoader):\n    \"\"\"Load a camera from Alembic file.\n\n    Stores the imported asset in an empty named after the asset.\n    \"\"\"\n\n    product_types = {\"camera\"}\n    representations = {\"abc\"}\n\n    label = \"Load Camera (ABC)\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            if obj.type == \"CAMERA\":\n                bpy.data.cameras.remove(obj.data)\n            elif obj.type == \"EMPTY\":\n                objects.extend(obj.children)\n                bpy.data.objects.remove(obj)\n\n    def _process(self, libpath, asset_group, group_name):\n        plugin.deselect_all()\n\n        # Force the creation of the transform cache even if the camera\n        # doesn't have an animation. We use the cache to update the camera.\n        bpy.ops.wm.alembic_import(\n            filepath=libpath, always_add_cache_reader=True)\n\n        objects = lib.get_selection()\n\n        for obj in objects:\n            obj.parent = asset_group\n\n        for obj in objects:\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != \"EMPTY\":\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n            if not obj.get(AVALON_PROPERTY):\n                obj[AVALON_PROPERTY] = dict()\n\n            avalon_info = obj[AVALON_PROPERTY]\n            avalon_info.update({\"container_name\": group_name})\n\n        plugin.deselect_all()\n\n        return objects\n\n    def process_asset(\n        self,\n        context: dict,\n        name: str,\n        namespace: Optional[str] = None,\n        options: Optional[Dict] = None,\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not avalon_container:\n            avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(avalon_container)\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        avalon_container.objects.link(asset_group)\n\n        self._process(libpath, asset_group, group_name)\n\n        objects = []\n        nodes = list(asset_group.children)\n\n        for obj in nodes:\n            objects.append(obj)\n            nodes.extend(list(obj.children))\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AVALON_PROPERTY] = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or \"\",\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(get_representation_path(repre_entity))\n        prev_filename = os.path.basename(container[\"libpath\"])\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\")\n        assert libpath, (\n            f\"No existing library file found for {container['objectName']}\")\n        assert libpath.is_file(), f\"The file doesn't exist: {libpath}\"\n        assert extension in plugin.VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\")\n\n        metadata = asset_group.get(AVALON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = str(\n            Path(bpy.path.abspath(group_libpath)).resolve())\n        normalized_libpath = str(\n            Path(bpy.path.abspath(str(libpath))).resolve())\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        bpy.ops.cachefile.open(filepath=libpath.as_posix())\n        for obj in asset_group.children:\n            asset_name = obj.name.rsplit(\":\", 1)[-1]\n            names = [constraint.name for constraint in obj.constraints\n                     if constraint.type == \"TRANSFORM_CACHE\"]\n            file_list = [file for file in bpy.data.cache_files\n                        if file.name.startswith(prev_filename)]\n            if names:\n                for name in names:\n                    obj.constraints.remove(obj.constraints.get(name))\n            if file_list:\n                bpy.data.batch_remove(file_list)\n\n            constraint = obj.constraints.new(\"TRANSFORM_CACHE\")\n            constraint.cache_file = bpy.data.cache_files[-1]\n            constraint.cache_file.name = os.path.basename(libpath)\n            constraint.cache_file.filepath = libpath.as_posix()\n            constraint.cache_file.scale = 1.0\n            bpy.context.evaluated_depsgraph_get()\n\n            for object_path in constraint.cache_file.object_paths:\n                base_object_name = os.path.basename(object_path.path)\n                if base_object_name.startswith(asset_name):\n                    constraint.object_path = object_path.path\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (openpype:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (openpype:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(get_representation_path(repre_entity))\n    prev_filename = os.path.basename(container[\"libpath\"])\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\")\n    assert libpath, (\n        f\"No existing library file found for {container['objectName']}\")\n    assert libpath.is_file(), f\"The file doesn't exist: {libpath}\"\n    assert extension in plugin.VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\")\n\n    metadata = asset_group.get(AVALON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = str(\n        Path(bpy.path.abspath(group_libpath)).resolve())\n    normalized_libpath = str(\n        Path(bpy.path.abspath(str(libpath))).resolve())\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    bpy.ops.cachefile.open(filepath=libpath.as_posix())\n    for obj in asset_group.children:\n        asset_name = obj.name.rsplit(\":\", 1)[-1]\n        names = [constraint.name for constraint in obj.constraints\n                 if constraint.type == \"TRANSFORM_CACHE\"]\n        file_list = [file for file in bpy.data.cache_files\n                    if file.name.startswith(prev_filename)]\n        if names:\n            for name in names:\n                obj.constraints.remove(obj.constraints.get(name))\n        if file_list:\n            bpy.data.batch_remove(file_list)\n\n        constraint = obj.constraints.new(\"TRANSFORM_CACHE\")\n        constraint.cache_file = bpy.data.cache_files[-1]\n        constraint.cache_file.name = os.path.basename(libpath)\n        constraint.cache_file.filepath = libpath.as_posix()\n        constraint.cache_file.scale = 1.0\n        bpy.context.evaluated_depsgraph_get()\n\n        for object_path in constraint.cache_file.object_paths:\n            base_object_name = os.path.basename(object_path.path)\n            if base_object_name.startswith(asset_name):\n                constraint.object_path = object_path.path\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>def process_asset(\n    self,\n    context: dict,\n    name: str,\n    namespace: Optional[str] = None,\n    options: Optional[Dict] = None,\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    avalon_container.objects.link(asset_group)\n\n    self._process(libpath, asset_group, group_name)\n\n    objects = []\n    nodes = list(asset_group.children)\n\n    for obj in nodes:\n        objects.append(obj)\n        nodes.extend(list(obj.children))\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AVALON_PROPERTY] = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or \"\",\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html","title":"load_camera_fbx","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader","title":"<code>FbxCameraLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load a camera from FBX.</p> <p>Stores the imported asset in an empty named after the asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>class FbxCameraLoader(plugin.BlenderLoader):\n    \"\"\"Load a camera from FBX.\n\n    Stores the imported asset in an empty named after the asset.\n    \"\"\"\n\n    product_types = {\"camera\"}\n    representations = {\"fbx\"}\n\n    label = \"Load Camera (FBX)\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            if obj.type == 'CAMERA':\n                bpy.data.cameras.remove(obj.data)\n            elif obj.type == 'EMPTY':\n                objects.extend(obj.children)\n                bpy.data.objects.remove(obj)\n\n    def _process(self, libpath, asset_group, group_name):\n        plugin.deselect_all()\n\n        collection = bpy.context.view_layer.active_layer_collection.collection\n\n        bpy.ops.import_scene.fbx(filepath=libpath)\n\n        parent = bpy.context.scene.collection\n\n        objects = lib.get_selection()\n\n        for obj in objects:\n            obj.parent = asset_group\n\n        for obj in objects:\n            parent.objects.link(obj)\n            collection.objects.unlink(obj)\n\n        for obj in objects:\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != 'EMPTY':\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n            if not obj.get(AVALON_PROPERTY):\n                obj[AVALON_PROPERTY] = dict()\n\n            avalon_info = obj[AVALON_PROPERTY]\n            avalon_info.update({\"container_name\": group_name})\n\n        plugin.deselect_all()\n\n        return objects\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not avalon_container:\n            avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(avalon_container)\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        avalon_container.objects.link(asset_group)\n\n        self._process(libpath, asset_group, group_name)\n\n        objects = []\n        nodes = list(asset_group.children)\n\n        for obj in nodes:\n            objects.append(obj)\n            nodes.extend(list(obj.children))\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AVALON_PROPERTY] = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(get_representation_path(repre_entity))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in plugin.VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AVALON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        mat = asset_group.matrix_basis.copy()\n\n        self._remove(asset_group)\n        self._process(str(libpath), asset_group, object_name)\n\n        asset_group.matrix_basis = mat\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (openpype:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (openpype:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(get_representation_path(repre_entity))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in plugin.VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AVALON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    mat = asset_group.matrix_basis.copy()\n\n    self._remove(asset_group)\n    self._process(str(libpath), asset_group, object_name)\n\n    asset_group.matrix_basis = mat\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    avalon_container.objects.link(asset_group)\n\n    self._process(libpath, asset_group, group_name)\n\n    objects = []\n    nodes = list(asset_group.children)\n\n    for obj in nodes:\n        objects.append(obj)\n        nodes.extend(list(obj.children))\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AVALON_PROPERTY] = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html","title":"load_fbx","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader","title":"<code>FbxModelLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load FBX models.</p> <p>Stores the imported asset in an empty named after the asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>class FbxModelLoader(plugin.BlenderLoader):\n    \"\"\"Load FBX models.\n\n    Stores the imported asset in an empty named after the asset.\n    \"\"\"\n\n    product_types = {\"model\", \"rig\"}\n    representations = {\"fbx\"}\n\n    label = \"Load FBX\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            if obj.type == 'MESH':\n                for material_slot in list(obj.material_slots):\n                    if material_slot.material:\n                        bpy.data.materials.remove(material_slot.material)\n                bpy.data.meshes.remove(obj.data)\n            elif obj.type == 'ARMATURE':\n                objects.extend(obj.children)\n                bpy.data.armatures.remove(obj.data)\n            elif obj.type == 'CURVE':\n                bpy.data.curves.remove(obj.data)\n            elif obj.type == 'EMPTY':\n                objects.extend(obj.children)\n                bpy.data.objects.remove(obj)\n\n    def _process(self, libpath, asset_group, group_name, action):\n        plugin.deselect_all()\n\n        collection = bpy.context.view_layer.active_layer_collection.collection\n\n        bpy.ops.import_scene.fbx(filepath=libpath)\n\n        parent = bpy.context.scene.collection\n\n        imported = lib.get_selection()\n\n        empties = [obj for obj in imported if obj.type == 'EMPTY']\n\n        container = None\n\n        for empty in empties:\n            if not empty.parent:\n                container = empty\n                break\n\n        assert container, \"No asset group found\"\n\n        # Children must be linked before parents,\n        # otherwise the hierarchy will break\n        objects = []\n        nodes = list(container.children)\n\n        for obj in nodes:\n            obj.parent = asset_group\n\n        bpy.data.objects.remove(container)\n\n        for obj in nodes:\n            objects.append(obj)\n            nodes.extend(list(obj.children))\n\n        objects.reverse()\n\n        for obj in objects:\n            parent.objects.link(obj)\n            collection.objects.unlink(obj)\n\n        for obj in objects:\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != 'EMPTY':\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n            if obj.type == 'MESH':\n                for material_slot in obj.material_slots:\n                    name_mat = material_slot.material.name\n                    material_slot.material.name = f\"{group_name}:{name_mat}\"\n            elif obj.type == 'ARMATURE':\n                anim_data = obj.animation_data\n                if action is not None:\n                    anim_data.action = action\n                elif anim_data.action is not None:\n                    name_action = anim_data.action.name\n                    anim_data.action.name = f\"{group_name}:{name_action}\"\n\n            if not obj.get(AVALON_PROPERTY):\n                obj[AVALON_PROPERTY] = dict()\n\n            avalon_info = obj[AVALON_PROPERTY]\n            avalon_info.update({\"container_name\": group_name})\n\n        plugin.deselect_all()\n\n        return objects\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not avalon_container:\n            avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(avalon_container)\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        avalon_container.objects.link(asset_group)\n\n        objects = self._process(libpath, asset_group, group_name, None)\n\n        objects = []\n        nodes = list(asset_group.children)\n\n        for obj in nodes:\n            objects.append(obj)\n            nodes.extend(list(obj.children))\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AVALON_PROPERTY] = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(get_representation_path(repre_entity))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in plugin.VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AVALON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        # Get the armature of the rig\n        objects = asset_group.children\n        armatures = [obj for obj in objects if obj.type == 'ARMATURE']\n        action = None\n\n        if armatures:\n            armature = armatures[0]\n\n            if armature.animation_data and armature.animation_data.action:\n                action = armature.animation_data.action\n\n        mat = asset_group.matrix_basis.copy()\n        self._remove(asset_group)\n\n        self._process(str(libpath), asset_group, object_name, action)\n\n        asset_group.matrix_basis = mat\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (openpype:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (openpype:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(get_representation_path(repre_entity))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in plugin.VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AVALON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    # Get the armature of the rig\n    objects = asset_group.children\n    armatures = [obj for obj in objects if obj.type == 'ARMATURE']\n    action = None\n\n    if armatures:\n        armature = armatures[0]\n\n        if armature.animation_data and armature.animation_data.action:\n            action = armature.animation_data.action\n\n    mat = asset_group.matrix_basis.copy()\n    self._remove(asset_group)\n\n    self._process(str(libpath), asset_group, object_name, action)\n\n    asset_group.matrix_basis = mat\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    avalon_container.objects.link(asset_group)\n\n    objects = self._process(libpath, asset_group, group_name, None)\n\n    objects = []\n    nodes = list(asset_group.children)\n\n    for obj in nodes:\n        objects.append(obj)\n        nodes.extend(list(obj.children))\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AVALON_PROPERTY] = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html","title":"load_image_compositor","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor","title":"<code>LoadImageCompositor</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load media to the compositor.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>class LoadImageCompositor(plugin.BlenderLoader):\n    \"\"\"Load media to the compositor.\"\"\"\n\n    product_types = {\"render\", \"image\", \"plate\"}\n    representations = {\"*\"}\n\n    label = \"Load in Compositor\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        path = self.filepath_from_context(context)\n\n        # Enable nodes to ensure they can be loaded\n        if not bpy.context.scene.use_nodes:\n            self.log.info(\"Enabling 'use nodes' for Compositor\")\n            bpy.context.scene.use_nodes = True\n\n        # Load the image in data\n        image = bpy.data.images.load(path, check_existing=True)\n\n        # Get the current scene's compositor node tree\n        node_tree = bpy.context.scene.node_tree\n\n        # Create a new image node\n        img_comp_node = node_tree.nodes.new(type='CompositorNodeImage')\n        img_comp_node.image = image\n        self.set_source_and_colorspace(context, img_comp_node)\n\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n        lib.imprint(img_comp_node, data)\n\n        return [img_comp_node]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove the image comp node\"\"\"\n        img_comp_node = container[\"node\"]\n        image: Optional[bpy.types.Image] = img_comp_node.image\n\n        # Delete the compositor node\n        bpy.context.scene.node_tree.nodes.remove(img_comp_node)\n\n        # Delete the image if it remains unused\n        self.remove_image_if_unused(image)\n\n        return True\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the image comp node to new context version.\"\"\"\n        path = self.filepath_from_context(context)\n        img_comp_node = container[\"node\"]\n\n        old_image: Optional[bpy.types.Image] = img_comp_node.image\n\n        new_image = bpy.data.images.load(path, check_existing=True)\n        img_comp_node.image = new_image\n\n        self.set_source_and_colorspace(context, img_comp_node)\n        self.remove_image_if_unused(old_image)\n\n        # Update representation id\n        lib.imprint(img_comp_node, {\n            \"representation\": context[\"representation\"][\"id\"],\n            \"project_name\": context[\"project\"][\"name\"],\n        })\n\n    def set_source_and_colorspace(\n        self,\n        context: dict,\n        image_comp_node: bpy.types.CompositorNodeImage\n    ):\n        \"\"\"\n        Set the image source (e.g. SEQUENCE or FILE), set the duration for\n        a sequence and set colorspace if representation has colorspace data.\n        \"\"\"\n\n        image = image_comp_node.image\n        representation: dict = context[\"representation\"]\n\n        # Set image source\n        source = \"FILE\"  # Single image file\n        if representation[\"context\"].get(\"udim\"):\n            source = \"UDIM\"\n        elif representation[\"context\"].get(\"frame\"):\n            source = \"SEQUENCE\"\n        else:\n            ext = os.path.splitext(image.filepath)[-1]\n            if ext in VIDEO_EXTENSIONS:\n                source = \"MOVIE\"\n\n        image.source = source\n\n        # Set duration on the compositor node if sequence is used\n        if source in {\"SEQUENCE\", \"MOVIE\"}:\n            version_attrib: dict = context[\"version\"][\"attrib\"]\n            frame_start = version_attrib.get(\"frameStart\", 0)\n            frame_end = version_attrib.get(\"frameEnd\", 0)\n            handle_start = version_attrib.get(\"handleStart\", 0)\n            handle_end = version_attrib.get(\"handleEnd\", 0)\n            frame_start_handle = frame_start - handle_start\n            frame_end_handle = frame_end + handle_end\n            duration: int = frame_end_handle - frame_start_handle + 1\n            image_comp_node.frame_duration = duration\n            if source == \"SEQUENCE\":\n                image_comp_node.frame_start = frame_start_handle\n                image_comp_node.frame_offset = frame_start_handle - 1\n            else:\n                image_comp_node.frame_start = frame_start_handle\n                image_comp_node.frame_offset = 0\n\n        # Set colorspace if representation has colorspace data\n        colorspace_data = representation.get(\"data\", {}).get(\n            \"colorspaceData\", {})\n        if colorspace_data:\n            colorspace: str = colorspace_data[\"colorspace\"]\n            if colorspace:\n                image.colorspace_settings.name = colorspace\n\n    def remove_image_if_unused(self, image: bpy.types.Image):\n        if image and not image.users:\n            self.log.debug(\"Removing unused image: %s\", image.name)\n            bpy.data.images.remove(image)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove the image comp node</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove the image comp node\"\"\"\n    img_comp_node = container[\"node\"]\n    image: Optional[bpy.types.Image] = img_comp_node.image\n\n    # Delete the compositor node\n    bpy.context.scene.node_tree.nodes.remove(img_comp_node)\n\n    # Delete the image if it remains unused\n    self.remove_image_if_unused(image)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the image comp node to new context version.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the image comp node to new context version.\"\"\"\n    path = self.filepath_from_context(context)\n    img_comp_node = container[\"node\"]\n\n    old_image: Optional[bpy.types.Image] = img_comp_node.image\n\n    new_image = bpy.data.images.load(path, check_existing=True)\n    img_comp_node.image = new_image\n\n    self.set_source_and_colorspace(context, img_comp_node)\n    self.remove_image_if_unused(old_image)\n\n    # Update representation id\n    lib.imprint(img_comp_node, {\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    path = self.filepath_from_context(context)\n\n    # Enable nodes to ensure they can be loaded\n    if not bpy.context.scene.use_nodes:\n        self.log.info(\"Enabling 'use nodes' for Compositor\")\n        bpy.context.scene.use_nodes = True\n\n    # Load the image in data\n    image = bpy.data.images.load(path, check_existing=True)\n\n    # Get the current scene's compositor node tree\n    node_tree = bpy.context.scene.node_tree\n\n    # Create a new image node\n    img_comp_node = node_tree.nodes.new(type='CompositorNodeImage')\n    img_comp_node.image = image\n    self.set_source_and_colorspace(context, img_comp_node)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n    lib.imprint(img_comp_node, data)\n\n    return [img_comp_node]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.set_source_and_colorspace","title":"<code>set_source_and_colorspace(context, image_comp_node)</code>","text":"<p>Set the image source (e.g. SEQUENCE or FILE), set the duration for a sequence and set colorspace if representation has colorspace data.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def set_source_and_colorspace(\n    self,\n    context: dict,\n    image_comp_node: bpy.types.CompositorNodeImage\n):\n    \"\"\"\n    Set the image source (e.g. SEQUENCE or FILE), set the duration for\n    a sequence and set colorspace if representation has colorspace data.\n    \"\"\"\n\n    image = image_comp_node.image\n    representation: dict = context[\"representation\"]\n\n    # Set image source\n    source = \"FILE\"  # Single image file\n    if representation[\"context\"].get(\"udim\"):\n        source = \"UDIM\"\n    elif representation[\"context\"].get(\"frame\"):\n        source = \"SEQUENCE\"\n    else:\n        ext = os.path.splitext(image.filepath)[-1]\n        if ext in VIDEO_EXTENSIONS:\n            source = \"MOVIE\"\n\n    image.source = source\n\n    # Set duration on the compositor node if sequence is used\n    if source in {\"SEQUENCE\", \"MOVIE\"}:\n        version_attrib: dict = context[\"version\"][\"attrib\"]\n        frame_start = version_attrib.get(\"frameStart\", 0)\n        frame_end = version_attrib.get(\"frameEnd\", 0)\n        handle_start = version_attrib.get(\"handleStart\", 0)\n        handle_end = version_attrib.get(\"handleEnd\", 0)\n        frame_start_handle = frame_start - handle_start\n        frame_end_handle = frame_end + handle_end\n        duration: int = frame_end_handle - frame_start_handle + 1\n        image_comp_node.frame_duration = duration\n        if source == \"SEQUENCE\":\n            image_comp_node.frame_start = frame_start_handle\n            image_comp_node.frame_offset = frame_start_handle - 1\n        else:\n            image_comp_node.frame_start = frame_start_handle\n            image_comp_node.frame_offset = 0\n\n    # Set colorspace if representation has colorspace data\n    colorspace_data = representation.get(\"data\", {}).get(\n        \"colorspaceData\", {})\n    if colorspace_data:\n        colorspace: str = colorspace_data[\"colorspace\"]\n        if colorspace:\n            image.colorspace_settings.name = colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html","title":"load_image_shader","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor","title":"<code>LoadImageShaderEditor</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load a product to the Shader Editor for selected mesh in Blender.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>class LoadImageShaderEditor(plugin.BlenderLoader):\n    \"\"\"Load a product to the Shader Editor for selected mesh in Blender.\"\"\"\n\n    product_types = {\"render\", \"image\", \"plate\"}\n    representations = {\"*\"}\n\n    label = \"Load to Shader Editor\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    CREATE_NEW = \"create_new\"\n\n    @classmethod\n    def get_options(cls, contexts):\n\n        selected_object = cls.get_selected_object()\n        if not selected_object:\n            return []\n\n        slot_materials = [\n            (i, material) for i, material\n            in enumerate(selected_object.data.materials)\n            # Ignore empty material slots\n            if material is not None\n        ]\n        items = [\n            {\"value\": i, \"label\": material.name}\n            for i, material in slot_materials\n        ]\n        items.append(\n            {\"value\": cls.CREATE_NEW, \"label\": \"New Material\"}\n        )\n        return [\n            EnumDef(\n                \"material_slot\",\n                label=\"Material Slot\",\n                items=items,\n                default=items[0][\"value\"]\n            )\n        ]\n\n    @staticmethod\n    def get_selected_object():\n        selected_objects = lib.get_selection()\n        for obj in selected_objects:\n            if obj.type in {'MESH', 'SURFACE'}:\n                return obj\n\n    def process_asset(\n            self, context: dict, name: str, namespace: Optional[str] = None,\n            options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        # In the current objects selection, I get the first one that is a\n        # MESH or a SURFACE.\n        # TODO: We tend to avoid acting on 'user selection' so that the loaders\n        #  can run completely automatically, without user interaction or popups\n        #  So we may want to investigate different approaches to this.\n        cur_obj = self.get_selected_object()\n        if cur_obj is None:\n            self.log.info(\n                \"Load in Shader Editor: The process (image load) was \"\n                \"cancelled, because no object (mesh or surface) was selected \"\n                \"in Blender.\")\n            self.display_warning(\n                \"You did not select any object in Blender.\\n\"\n                \"So this process is cancelled.\")\n            return []\n\n        # If the currently selected object has one or more materials, let's use\n        # the first one. If it has no material, let's create a new one.\n        material_slot = options.get(\"material_slot\")\n        if material_slot is None:\n            # Get first slot with a material\n            material_slot = next(\n                (\n                    i for i, material in enumerate(cur_obj.data.materials)\n                    # Ignore empty material slots\n                    if material is not None\n                ), None\n            )\n        if material_slot is None or material_slot == self.CREATE_NEW:\n            # Create a new material\n            current_material = bpy.data.materials.new(name=\"material\")\n            current_material.use_nodes = True\n            cur_obj.data.materials.append(current_material)\n        else:\n            current_material = cur_obj.data.materials[material_slot]\n            current_material.use_nodes = True\n\n        nodes = current_material.node_tree.nodes\n\n        # Create an \"Image Texture\" node. It will appear in the Shader Editor\n        # (which appears when you are in the \"Shading\" workspace tab), when you\n        # select the \"Object\" filter (among this choice: Object, World,\n        # Line Style).\n        image_texture_node = nodes.new(type='ShaderNodeTexImage')\n\n        # Load the image in data\n        path = self.filepath_from_context(context)\n        image = bpy.data.images.load(path)\n        image_texture_node.image = image\n\n        self.set_colorspace(context, image_texture_node)\n\n        data = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n        }\n        lib.imprint(image_texture_node, data)\n\n        return [image_texture_node]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove the Image Texture node.\"\"\"\n\n        image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n        image: Optional[bpy.types.Image] = image_texture_node.image\n\n        # Delete the node\n        image_texture_node.id_data.nodes.remove(image_texture_node)\n\n        # Delete the image if it remains unused\n        self.remove_image_if_unused(image)\n\n        return True\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the Image Texture node to new context version.\"\"\"\n\n        path = self.filepath_from_context(context)\n        image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n\n        old_image: Optional[bpy.types.Image] = image_texture_node.image\n\n        new_image = bpy.data.images.load(path)\n        image_texture_node.image = new_image\n\n        self.set_colorspace(context, image_texture_node)\n        self.remove_image_if_unused(old_image)\n\n        # Update representation id\n        lib.imprint(image_texture_node, {\n            \"representation\": context[\"representation\"][\"id\"]\n        })\n\n    def set_colorspace(\n            self,\n            context: dict,\n            image_texture_node: bpy.types.ShaderNodeTexImage\n    ):\n        \"\"\"\n        Set colorspace if representation has colorspace data.\n        \"\"\"\n\n        image = image_texture_node.image\n        representation: dict = context[\"representation\"]\n\n        colorspace_data = representation.get(\"data\", {}).get(\n            \"colorspaceData\", {})\n        if colorspace_data:\n            colorspace: str = colorspace_data[\"colorspace\"]\n            if colorspace:\n                image.colorspace_settings.name = colorspace\n\n    def remove_image_if_unused(self, image: bpy.types.Image):\n        if image and not image.users:\n            self.log.debug(\"Removing unused image: %s\", image.name)\n            bpy.data.images.remove(image)\n\n    def display_warning(self, message):\n        loader_gui_window = host_tools.get_tool_by_name(\"loader\")\n\n        QtWidgets.QMessageBox.warning(\n            loader_gui_window,\n            \"Warning\",\n            message,\n            buttons=QtWidgets.QMessageBox.Ok,\n            defaultButton=QtWidgets.QMessageBox.Ok)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove the Image Texture node.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove the Image Texture node.\"\"\"\n\n    image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n    image: Optional[bpy.types.Image] = image_texture_node.image\n\n    # Delete the node\n    image_texture_node.id_data.nodes.remove(image_texture_node)\n\n    # Delete the image if it remains unused\n    self.remove_image_if_unused(image)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the Image Texture node to new context version.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the Image Texture node to new context version.\"\"\"\n\n    path = self.filepath_from_context(context)\n    image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n\n    old_image: Optional[bpy.types.Image] = image_texture_node.image\n\n    new_image = bpy.data.images.load(path)\n    image_texture_node.image = new_image\n\n    self.set_colorspace(context, image_texture_node)\n    self.remove_image_if_unused(old_image)\n\n    # Update representation id\n    lib.imprint(image_texture_node, {\n        \"representation\": context[\"representation\"][\"id\"]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    # In the current objects selection, I get the first one that is a\n    # MESH or a SURFACE.\n    # TODO: We tend to avoid acting on 'user selection' so that the loaders\n    #  can run completely automatically, without user interaction or popups\n    #  So we may want to investigate different approaches to this.\n    cur_obj = self.get_selected_object()\n    if cur_obj is None:\n        self.log.info(\n            \"Load in Shader Editor: The process (image load) was \"\n            \"cancelled, because no object (mesh or surface) was selected \"\n            \"in Blender.\")\n        self.display_warning(\n            \"You did not select any object in Blender.\\n\"\n            \"So this process is cancelled.\")\n        return []\n\n    # If the currently selected object has one or more materials, let's use\n    # the first one. If it has no material, let's create a new one.\n    material_slot = options.get(\"material_slot\")\n    if material_slot is None:\n        # Get first slot with a material\n        material_slot = next(\n            (\n                i for i, material in enumerate(cur_obj.data.materials)\n                # Ignore empty material slots\n                if material is not None\n            ), None\n        )\n    if material_slot is None or material_slot == self.CREATE_NEW:\n        # Create a new material\n        current_material = bpy.data.materials.new(name=\"material\")\n        current_material.use_nodes = True\n        cur_obj.data.materials.append(current_material)\n    else:\n        current_material = cur_obj.data.materials[material_slot]\n        current_material.use_nodes = True\n\n    nodes = current_material.node_tree.nodes\n\n    # Create an \"Image Texture\" node. It will appear in the Shader Editor\n    # (which appears when you are in the \"Shading\" workspace tab), when you\n    # select the \"Object\" filter (among this choice: Object, World,\n    # Line Style).\n    image_texture_node = nodes.new(type='ShaderNodeTexImage')\n\n    # Load the image in data\n    path = self.filepath_from_context(context)\n    image = bpy.data.images.load(path)\n    image_texture_node.image = image\n\n    self.set_colorspace(context, image_texture_node)\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n    }\n    lib.imprint(image_texture_node, data)\n\n    return [image_texture_node]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.set_colorspace","title":"<code>set_colorspace(context, image_texture_node)</code>","text":"<p>Set colorspace if representation has colorspace data.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def set_colorspace(\n        self,\n        context: dict,\n        image_texture_node: bpy.types.ShaderNodeTexImage\n):\n    \"\"\"\n    Set colorspace if representation has colorspace data.\n    \"\"\"\n\n    image = image_texture_node.image\n    representation: dict = context[\"representation\"]\n\n    colorspace_data = representation.get(\"data\", {}).get(\n        \"colorspaceData\", {})\n    if colorspace_data:\n        colorspace: str = colorspace_data[\"colorspace\"]\n        if colorspace:\n            image.colorspace_settings.name = colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html","title":"load_layout_json","text":"<p>Load a layout in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader","title":"<code>JsonLayoutLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load layout published from Unreal.</p> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>class JsonLayoutLoader(plugin.BlenderLoader):\n    \"\"\"Load layout published from Unreal.\"\"\"\n\n    product_types = {\"layout\"}\n    representations = {\"json\"}\n\n    label = \"Load Layout\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    animation_creator_name = \"CreateAnimation\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            remove_container(obj.get(AVALON_PROPERTY))\n\n    def _remove_animation_instances(self, asset_group):\n        instances = bpy.data.collections.get(AVALON_INSTANCES)\n        if instances:\n            for obj in list(asset_group.children):\n                anim_collection = instances.children.get(\n                    obj.name + \"_animation\")\n                if anim_collection:\n                    bpy.data.collections.remove(anim_collection)\n\n    def _get_loader(self, loaders, product_type):\n        name = \"\"\n        if product_type == 'rig':\n            name = \"BlendRigLoader\"\n        elif product_type == 'model':\n            name = \"BlendModelLoader\"\n\n        if name == \"\":\n            return None\n\n        for loader in loaders:\n            if loader.__name__ == name:\n                return loader\n\n        return None\n\n    def _process(self, libpath, asset, asset_group, actions):\n        plugin.deselect_all()\n\n        with open(libpath, \"r\") as fp:\n            data = json.load(fp)\n\n        all_loaders = discover_loader_plugins()\n\n        for element in data:\n            reference = element.get('reference')\n            product_type = element.get(\"product_type\")\n            if product_type is None:\n                product_type = element.get(\"family\")\n\n            loaders = loaders_from_representation(all_loaders, reference)\n            loader = self._get_loader(loaders, product_type)\n\n            if not loader:\n                continue\n\n            instance_name = element.get('instance_name')\n\n            action = None\n\n            if actions:\n                action = actions.get(instance_name, None)\n\n            options = {\n                'parent': asset_group,\n                'transform': element.get('transform'),\n                'action': action,\n                'create_animation': True if product_type == 'rig' else False,\n                'animation_asset': asset\n            }\n\n            if element.get('animation'):\n                options['animation_file'] = str(Path(libpath).with_suffix(\n                    '')) + \".\" + element.get('animation')\n\n            # This should return the loaded asset, but the load call will be\n            # added to the queue to run in the Blender main thread, so\n            # at this time it will not return anything. The assets will be\n            # loaded in the next Blender cycle, so we use the options to\n            # set the transform, parent and assign the action, if there is one.\n            load_container(\n                loader,\n                reference,\n                namespace=instance_name,\n                options=options\n            )\n\n        # Camera creation when loading a layout is not necessary for now,\n        # but the code is worth keeping in case we need it in the future.\n        # # Create the camera asset and the camera instance\n        # creator_plugin = get_legacy_creator_by_name(\"CreateCamera\")\n        # if not creator_plugin:\n        #     raise ValueError(\"Creator plugin \\\"CreateCamera\\\" was \"\n        #                      \"not found.\")\n\n        # TODO: Refactor legacy create usage to new style creators\n        # legacy_create(\n        #     creator_plugin,\n        #     name=\"camera\",\n        #     # name=f\"{unique_number}_{product[name]}_animation\",\n        #     asset=asset,\n        #     options={\"useSelection\": False}\n        #     # data={\"dependencies\": context[\"representation\"][\"id\"]}\n        # )\n\n    def process_asset(self,\n                      context: dict,\n                      name: str,\n                      namespace: Optional[str] = None,\n                      options: Optional[Dict] = None):\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n        if not avalon_container:\n            avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n            bpy.context.scene.collection.children.link(avalon_container)\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        asset_group.empty_display_type = 'SINGLE_ARROW'\n        avalon_container.objects.link(asset_group)\n\n        self._process(libpath, asset_name, asset_group, None)\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AVALON_PROPERTY] = {\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"project_name\": context[\"project\"][\"name\"],\n            \"objectName\": group_name,\n        }\n\n        self[:] = asset_group.children\n        return asset_group.children\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(get_representation_path(repre_entity))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in plugin.VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AVALON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        actions = {}\n\n        for obj in asset_group.children:\n            obj_meta = obj.get(AVALON_PROPERTY)\n            product_type = obj_meta.get(\"productType\")\n            if product_type is None:\n                product_type = obj_meta.get(\"family\")\n            if product_type == \"rig\":\n                rig = None\n                for child in obj.children:\n                    if child.type == 'ARMATURE':\n                        rig = child\n                        break\n                if not rig:\n                    raise Exception(\"No armature in the rig asset group.\")\n                if rig.animation_data and rig.animation_data.action:\n                    namespace = obj_meta.get('namespace')\n                    actions[namespace] = rig.animation_data.action\n\n        mat = asset_group.matrix_basis.copy()\n\n        self._remove_animation_instances(asset_group)\n\n        self._remove(asset_group)\n\n        self._process(str(libpath), asset_group, actions)\n\n        asset_group.matrix_basis = mat\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (openpype:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove_animation_instances(asset_group)\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>openpype</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (openpype:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove_animation_instances(asset_group)\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(get_representation_path(repre_entity))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in plugin.VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AVALON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    actions = {}\n\n    for obj in asset_group.children:\n        obj_meta = obj.get(AVALON_PROPERTY)\n        product_type = obj_meta.get(\"productType\")\n        if product_type is None:\n            product_type = obj_meta.get(\"family\")\n        if product_type == \"rig\":\n            rig = None\n            for child in obj.children:\n                if child.type == 'ARMATURE':\n                    rig = child\n                    break\n            if not rig:\n                raise Exception(\"No armature in the rig asset group.\")\n            if rig.animation_data and rig.animation_data.action:\n                namespace = obj_meta.get('namespace')\n                actions[namespace] = rig.animation_data.action\n\n    mat = asset_group.matrix_basis.copy()\n\n    self._remove_animation_instances(asset_group)\n\n    self._remove(asset_group)\n\n    self._process(str(libpath), asset_group, actions)\n\n    asset_group.matrix_basis = mat\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>def process_asset(self,\n                  context: dict,\n                  name: str,\n                  namespace: Optional[str] = None,\n                  options: Optional[Dict] = None):\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if not avalon_container:\n        avalon_container = bpy.data.collections.new(name=AVALON_CONTAINERS)\n        bpy.context.scene.collection.children.link(avalon_container)\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    asset_group.empty_display_type = 'SINGLE_ARROW'\n    avalon_container.objects.link(asset_group)\n\n    self._process(libpath, asset_name, asset_group, None)\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AVALON_PROPERTY] = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"project_name\": context[\"project\"][\"name\"],\n        \"objectName\": group_name,\n    }\n\n    self[:] = asset_group.children\n    return asset_group.children\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_look.html","title":"load_look","text":"<p>Load a model asset in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_look.html#client.ayon_blender.plugins.load.load_look.BlendLookLoader","title":"<code>BlendLookLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load models from a .blend file.</p> <p>Because they come from a .blend file we can simply link the collection that contains the model. There is no further need to 'containerise' it.</p> Source code in <code>client/ayon_blender/plugins/load/load_look.py</code> <pre><code>class BlendLookLoader(plugin.BlenderLoader):\n    \"\"\"Load models from a .blend file.\n\n    Because they come from a .blend file we can simply link the collection that\n    contains the model. There is no further need to 'containerise' it.\n    \"\"\"\n\n    product_types = {\"look\"}\n    representations = {\"json\"}\n\n    label = \"Load Look\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def get_all_children(self, obj):\n        children = list(obj.children)\n\n        for child in children:\n            children.extend(child.children)\n\n        return children\n\n    def _process(self, libpath, container_name, objects):\n        with open(libpath, \"r\") as fp:\n            data = json.load(fp)\n\n        path = os.path.dirname(libpath)\n        materials_path = f\"{path}/resources\"\n\n        materials = []\n\n        for entry in data:\n            file = entry.get('fbx_filename')\n            if file is None:\n                continue\n\n            bpy.ops.import_scene.fbx(filepath=f\"{materials_path}/{file}\")\n\n            mesh = [o for o in bpy.context.scene.objects if o.select_get()][0]\n            material = mesh.data.materials[0]\n            material.name = f\"{material.name}:{container_name}\"\n\n            texture_file = entry.get('tga_filename')\n            if texture_file:\n                node_tree = material.node_tree\n                pbsdf = node_tree.nodes['Principled BSDF']\n                base_color = pbsdf.inputs[0]\n                tex_node = base_color.links[0].from_node\n                tex_node.image.filepath = f\"{materials_path}/{texture_file}\"\n\n            materials.append(material)\n\n            for obj in objects:\n                for child in self.get_all_children(obj):\n                    mesh_name = child.name.split(':')[0]\n                    if mesh_name == material.name.split(':')[0]:\n                        child.data.materials.clear()\n                        child.data.materials.append(material)\n                        break\n\n            bpy.data.objects.remove(mesh)\n\n        return materials, objects\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        lib_container = plugin.prepare_scene_name(\n            folder_name, product_name\n        )\n        unique_number = plugin.get_unique_number(\n            folder_name, product_name\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n        container_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n\n        container = bpy.data.collections.new(lib_container)\n        container.name = container_name\n        containerise_existing(\n            container,\n            name,\n            namespace,\n            context,\n            self.__class__.__name__,\n        )\n\n        metadata = container.get(AVALON_PROPERTY)\n\n        metadata[\"libpath\"] = libpath\n        metadata[\"lib_container\"] = lib_container\n\n        selected = [o for o in bpy.context.scene.objects if o.select_get()]\n\n        materials, objects = self._process(libpath, container_name, selected)\n\n        # Save the list of imported materials in the metadata container\n        metadata[\"objects\"] = objects\n        metadata[\"materials\"] = materials\n\n        metadata[\"parent\"] = context[\"representation\"][\"versionId\"]\n        metadata[\"product_type\"] = context[\"product\"][\"productType\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n        nodes = list(container.objects)\n        nodes.append(container)\n        self[:] = nodes\n        return nodes\n\n    def update(self, container: Dict, context: Dict):\n        collection = bpy.data.collections.get(container[\"objectName\"])\n        repre_entity = context[\"representation\"]\n        libpath = Path(get_representation_path(repre_entity))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert collection, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert not (collection.children), (\n            \"Nested collections are not supported.\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in plugin.VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        collection_metadata = collection.get(AVALON_PROPERTY)\n        collection_libpath = collection_metadata[\"libpath\"]\n\n        normalized_collection_libpath = (\n            str(Path(bpy.path.abspath(collection_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_collection_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_collection_libpath,\n            normalized_libpath,\n        )\n        if normalized_collection_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        for obj in collection_metadata['objects']:\n            for child in self.get_all_children(obj):\n                child.data.materials.clear()\n\n        for material in collection_metadata['materials']:\n            bpy.data.materials.remove(material)\n\n        namespace = collection_metadata['namespace']\n        name = collection_metadata['name']\n\n        container_name = f\"{namespace}_{name}\"\n\n        materials, objects = self._process(\n            libpath, container_name, collection_metadata['objects'])\n\n        collection_metadata[\"objects\"] = objects\n        collection_metadata[\"materials\"] = materials\n        collection_metadata[\"libpath\"] = str(libpath)\n        collection_metadata[\"representation\"] = repre_entity[\"id\"]\n        collection_metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def remove(self, container: Dict) -&gt; bool:\n        collection = bpy.data.collections.get(container[\"objectName\"])\n        if not collection:\n            return False\n\n        collection_metadata = collection.get(AVALON_PROPERTY)\n\n        for obj in collection_metadata['objects']:\n            for child in self.get_all_children(obj):\n                child.data.materials.clear()\n\n        for material in collection_metadata['materials']:\n            bpy.data.materials.remove(material)\n\n        bpy.data.collections.remove(collection)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_look.html#client.ayon_blender.plugins.load.load_look.BlendLookLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_look.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    lib_container = plugin.prepare_scene_name(\n        folder_name, product_name\n    )\n    unique_number = plugin.get_unique_number(\n        folder_name, product_name\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n    container_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n\n    container = bpy.data.collections.new(lib_container)\n    container.name = container_name\n    containerise_existing(\n        container,\n        name,\n        namespace,\n        context,\n        self.__class__.__name__,\n    )\n\n    metadata = container.get(AVALON_PROPERTY)\n\n    metadata[\"libpath\"] = libpath\n    metadata[\"lib_container\"] = lib_container\n\n    selected = [o for o in bpy.context.scene.objects if o.select_get()]\n\n    materials, objects = self._process(libpath, container_name, selected)\n\n    # Save the list of imported materials in the metadata container\n    metadata[\"objects\"] = objects\n    metadata[\"materials\"] = materials\n\n    metadata[\"parent\"] = context[\"representation\"][\"versionId\"]\n    metadata[\"product_type\"] = context[\"product\"][\"productType\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    nodes = list(container.objects)\n    nodes.append(container)\n    self[:] = nodes\n    return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_current_file.html#client.ayon_blender.plugins.publish.collect_current_file.CollectBlenderCurrentFile","title":"<code>CollectBlenderCurrentFile</code>","text":"<p>               Bases: <code>BlenderContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_blender/plugins/publish/collect_current_file.py</code> <pre><code>class CollectBlenderCurrentFile(plugin.BlenderContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Blender Current File\"\n    hosts = [\"blender\"]\n\n    def process(self, context):\n        \"\"\"Inject the current working file\"\"\"\n        current_file = workio.current_file()\n        context.data[\"currentFile\"] = current_file\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_current_file.html#client.ayon_blender.plugins.publish.collect_current_file.CollectBlenderCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_blender/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file\"\"\"\n    current_file = workio.current_file()\n    context.data[\"currentFile\"] = current_file\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_file_dependencies.html","title":"collect_file_dependencies","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_file_dependencies.html#client.ayon_blender.plugins.publish.collect_file_dependencies.CollectFileDependencies","title":"<code>CollectFileDependencies</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Gather all files referenced in this scene.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_file_dependencies.py</code> <pre><code>class CollectFileDependencies(pyblish.api.ContextPlugin):\n    \"\"\"Gather all files referenced in this scene.\"\"\"\n\n    label = \"Collect File Dependencies\"\n    order = pyblish.api.CollectorOrder - 0.49\n    hosts = [\"blender\"]\n    families = [\"render\"]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if not used for deadline submission anyway\n        settings = project_settings[\"deadline\"][\"publish\"][\"BlenderSubmitDeadline\"]  # noqa\n        cls.enabled = settings.get(\"asset_dependencies\", True)\n\n    def process(self, context):\n        dependencies = set()\n\n        # Add alembic files as dependencies\n        for cache in bpy.data.cache_files:\n            dependencies.add(\n                Path(bpy.path.abspath(cache.filepath)).resolve().as_posix())\n\n        # Add image files as dependencies\n        for image in bpy.data.images:\n            if image.filepath:\n                dependencies.add(Path(\n                    bpy.path.abspath(image.filepath)).resolve().as_posix())\n\n        context.data[\"fileDependencies\"] = list(dependencies)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_instance.html","title":"collect_instance","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_instance.html#client.ayon_blender.plugins.publish.collect_instance.CollectBlenderInstanceData","title":"<code>CollectBlenderInstanceData</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Validator to verify that the instance is not empty</p> Source code in <code>client/ayon_blender/plugins/publish/collect_instance.py</code> <pre><code>class CollectBlenderInstanceData(plugin.BlenderInstancePlugin):\n    \"\"\"Validator to verify that the instance is not empty\"\"\"\n\n    order = pyblish.api.CollectorOrder\n    hosts = [\"blender\"]\n    families = [\"model\", \"pointcache\", \"animation\", \"rig\", \"camera\", \"layout\",\n                \"blendScene\", \"usd\"]\n    label = \"Collect Instance\"\n\n    def process(self, instance):\n        instance_node = instance.data[\"transientData\"][\"instance_node\"]\n\n        # Collect members of the instance\n        members = [instance_node]\n        if isinstance(instance_node, bpy.types.Collection):\n            members.extend(instance_node.objects)\n            members.extend(instance_node.children)\n\n            # Special case for animation instances, include armatures\n            if instance.data[\"productType\"] == \"animation\":\n                for obj in instance_node.objects:\n                    if obj.type == 'EMPTY' and obj.get(AVALON_PROPERTY):\n                        members.extend(\n                            child for child in obj.children\n                            if child.type == 'ARMATURE'\n                        )\n        elif isinstance(instance_node, bpy.types.Object):\n            members.extend(instance_node.children_recursive)\n        else:\n            raise KnownPublishError(\n                f\"Unsupported instance node type '{type(instance_node)}' \"\n                f\"for instance '{instance}'\"\n            )\n\n        instance[:] = members\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_instance_frame_range.html","title":"collect_instance_frame_range","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html","title":"collect_render","text":"<p>Collect render data.</p>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.CollectBlenderRender","title":"<code>CollectBlenderRender</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Gather all publishable render instances.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_render.py</code> <pre><code>class CollectBlenderRender(plugin.BlenderInstancePlugin):\n    \"\"\"Gather all publishable render instances.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.01\n    hosts = [\"blender\"]\n    families = [\"renderlayer\"]\n    label = \"Collect Render\"\n    sync_workfile_version = False\n\n    @staticmethod\n    def generate_expected_files(\n        render_product, frame_start, frame_end, frame_step, ext\n    ):\n        \"\"\"\n        Generate the expected files for the render product for the beauty\n        render. This returns a list of files that should be rendered. It\n        replaces the sequence of `#` with the frame number.\n        \"\"\"\n        expected_files = {}\n        aov_files = []\n        for render_name, render_file in render_product:\n            path = os.path.dirname(render_file)\n            file = os.path.basename(render_file)\n\n            for frame in range(frame_start, frame_end + 1, frame_step):\n                frame_str = str(frame).rjust(4, \"0\")\n                filename = re.sub(\"#+\", frame_str, file)\n                expected_file = f\"{os.path.join(path, filename)}.{ext}\"\n                aov_files.append(expected_file.replace(\"\\\\\", \"/\"))\n\n            expected_files[render_name] = [\n                aov for aov in aov_files if render_name in aov\n            ]\n\n        return expected_files\n\n    def process(self, instance):\n\n        instance_node = instance.data[\"transientData\"][\"instance_node\"]\n        render_data = instance_node.get(\"render_data\")\n\n        assert render_data, \"No render data found.\"\n\n        render_product = render_data.get(\"render_product\")\n        aov_file_product = render_data.get(\"aov_file_product\")\n        ext = render_data.get(\"image_format\")\n        multilayer = render_data.get(\"multilayer_exr\")\n        review = render_data.get(\"review\", False)\n\n        frame_start = instance.data[\"frameStartHandle\"]\n        frame_end = instance.data[\"frameEndHandle\"]\n\n        if multilayer:\n            expected_files = next((rn_product for rn_product in render_product.values()), None)\n            expected_beauty = self.generate_expected_files(\n                expected_files, int(frame_start), int(frame_end),\n                int(bpy.context.scene.frame_step), ext)\n\n            instance.data.update({\n                \"families\": [\"render\", \"render.farm\"],\n                \"frameStart\": frame_start,\n                \"frameEnd\": frame_end,\n                \"productType\": \"render\",\n                \"frameStartHandle\": frame_start,\n                \"frameEndHandle\": frame_end,\n                \"fps\": instance.context.data[\"fps\"],\n                \"byFrameStep\": bpy.context.scene.frame_step,\n                \"review\": review,\n                \"multipartExr\": ext == \"exr\" and multilayer,\n                \"farm\": True,\n                \"expectedFiles\": [expected_beauty],\n                # OCIO not currently implemented in Blender, but the following\n                # settings are required by the schema, so it is hardcoded.\n                # TODO: Implement OCIO in Blender\n                \"colorspaceConfig\": \"\",\n                \"colorspaceDisplay\": \"sRGB\",\n                \"colorspaceView\": \"ACES 1.0 SDR-video\",\n                \"renderProducts\": colorspace.ARenderProduct(\n                    frame_start=frame_start,\n                    frame_end=frame_end\n                ),\n            })\n\n        else:\n            instance.data[\"integrate\"] = False\n            self.create_renderlayer_instance(\n                instance, render_product,\n                aov_file_product, ext, multilayer,\n                frame_start, frame_end, review)\n\n    def create_renderlayer_instance(self, instance, render_product,\n                                    aov_file_product, ext, multilayer,\n                                    frame_start, frame_end, review):\n        context = instance.context\n        prod_type = \"render\"\n        project_name = instance.context.data[\"projectName\"]\n        folder_entity = ayon_api.get_folder_by_path(\n            project_name,\n            instance.data[\"folderPath\"]\n        )\n        task_name = instance.data.get(\"task\")\n        task_entity = None\n        if folder_entity and task_name:\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], task_name\n            )\n\n        for view_layer in bpy.context.scene.view_layers:\n            viewlayer_name = view_layer.name\n            rn_product = render_product[viewlayer_name]\n            aov_product = aov_file_product[viewlayer_name] if aov_file_product else {}\n            viewlayer_product_name = get_product_name(\n                context.data[\"projectName\"],\n                task_entity[\"name\"],\n                task_entity[\"taskType\"],\n                context.data[\"hostName\"],\n                product_type=prod_type,\n                variant=instance.data[\"variant\"] + viewlayer_name,\n                project_settings=context.data[\"project_settings\"]\n            )\n            rn_layer_instance = context.create_instance(viewlayer_product_name)\n            rn_layer_instance[:] = instance[:]\n            expected_beauty = self.generate_expected_files(\n                rn_product, int(frame_start), int(frame_end),\n                int(bpy.context.scene.frame_step), ext)\n\n            expected_aovs = self.generate_expected_files(\n                aov_product, int(frame_start), int(frame_end),\n                int(bpy.context.scene.frame_step), ext)\n\n            expected_files = expected_beauty | expected_aovs\n            rn_layer_instance.data.update({\n                \"family\": prod_type,\n                \"families\": [prod_type, \"render.farm\"],\n                \"fps\": context.data[\"fps\"],\n                \"byFrameStep\": instance.data[\"creator_attributes\"].get(\"step\", 1),\n                \"review\": review,\n                \"multipartExr\": ext == \"exr\" and multilayer,\n                \"farm\": True,\n                \"folderPath\": instance.data[\"folderPath\"],\n                \"productName\": viewlayer_product_name,\n                \"productType\": prod_type,\n                \"expectedFiles\": [expected_files],\n                \"frameStart\": instance.data[\"frameStart\"],\n                \"frameEnd\": instance.data[\"frameEnd\"],\n                \"frameStartHandle\": frame_start,\n                \"frameEndHandle\": frame_end,\n                \"task\": instance.data[\"task\"],\n                # OCIO not currently implemented in Blender, but the following\n                # settings are required by the schema, so it is hardcoded.\n                # TODO: Implement OCIO in Blender\n                \"colorspaceConfig\": \"\",\n                \"colorspaceDisplay\": \"sRGB\",\n                \"colorspaceView\": \"ACES 1.0 SDR-video\",\n                \"renderProducts\": colorspace.ARenderProduct(\n                    frame_start=frame_start,\n                    frame_end=frame_end\n                ),\n                \"publish_attributes\": instance.data[\"publish_attributes\"]\n            })\n            instance.append(rn_layer_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.CollectBlenderRender.generate_expected_files","title":"<code>generate_expected_files(render_product, frame_start, frame_end, frame_step, ext)</code>  <code>staticmethod</code>","text":"<p>Generate the expected files for the render product for the beauty render. This returns a list of files that should be rendered. It replaces the sequence of <code>#</code> with the frame number.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_render.py</code> <pre><code>@staticmethod\ndef generate_expected_files(\n    render_product, frame_start, frame_end, frame_step, ext\n):\n    \"\"\"\n    Generate the expected files for the render product for the beauty\n    render. This returns a list of files that should be rendered. It\n    replaces the sequence of `#` with the frame number.\n    \"\"\"\n    expected_files = {}\n    aov_files = []\n    for render_name, render_file in render_product:\n        path = os.path.dirname(render_file)\n        file = os.path.basename(render_file)\n\n        for frame in range(frame_start, frame_end + 1, frame_step):\n            frame_str = str(frame).rjust(4, \"0\")\n            filename = re.sub(\"#+\", frame_str, file)\n            expected_file = f\"{os.path.join(path, filename)}.{ext}\"\n            aov_files.append(expected_file.replace(\"\\\\\", \"/\"))\n\n        expected_files[render_name] = [\n            aov for aov in aov_files if render_name in aov\n        ]\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_review.html","title":"collect_review","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_review.html#client.ayon_blender.plugins.publish.collect_review.CollectReview","title":"<code>CollectReview</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Collect Review data</p> Source code in <code>client/ayon_blender/plugins/publish/collect_review.py</code> <pre><code>class CollectReview(plugin.BlenderInstancePlugin):\n    \"\"\"Collect Review data\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.3\n    label = \"Collect Review Data\"\n    families = [\"review\"]\n\n    def process(self, instance):\n\n        self.log.debug(f\"instance: {instance}\")\n\n        datablock = instance.data[\"transientData\"][\"instance_node\"]\n\n        # get cameras\n        cameras = [\n            obj\n            for obj in datablock.all_objects\n            if isinstance(obj, bpy.types.Object) and obj.type == \"CAMERA\"\n        ]\n\n        assert len(cameras) == 1, (\n            f\"Not a single camera found in extraction: {cameras}\"\n        )\n        camera = cameras[0].name\n        self.log.debug(f\"camera: {camera}\")\n\n        focal_length = cameras[0].data.lens\n\n        # get isolate objects list from meshes instance members.\n        types = {\"MESH\", \"GPENCIL\"}\n        isolate_objects = [\n            obj\n            for obj in instance\n            if isinstance(obj, bpy.types.Object) and obj.type in types\n        ]\n\n        # Store focal length in `burninDataMembers`\n        burninData = instance.data.setdefault(\"burninDataMembers\", {})\n        burninData[\"focalLength\"] = focal_length\n\n        instance.data.update({\n            \"review_camera\": camera,\n            \"fps\": instance.context.data[\"fps\"],\n            \"isolate\": isolate_objects,\n        })\n\n        self.log.debug(f\"instance data: {instance.data}\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_workfile.html#client.ayon_blender.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Inject workfile data into its instance.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(plugin.BlenderInstancePlugin):\n    \"\"\"Inject workfile data into its instance.\"\"\"\n\n    order = CollectorOrder\n    label = \"Collect Workfile\"\n    hosts = [\"blender\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Process collector.\"\"\"\n\n        context = instance.context\n        filepath = context.data.get(\"currentFile\")\n        if not filepath:\n            self.log.warning(\"Deactivating workfile instance because no \"\n                             \"current filepath is found. Please save your \"\n                             \"workfile.\")\n            instance.data[\"publish\"] = False\n            return\n\n        filepath = Path(filepath)\n        ext = filepath.suffix\n\n        instance.data.update(\n            {\n                \"setMembers\": [filepath.as_posix()],\n                \"frameStart\": context.data.get(\"frameStart\", 1),\n                \"frameEnd\": context.data.get(\"frameEnd\", 1),\n                \"handleStart\": context.data.get(\"handleStart\", 1),\n                \"handledEnd\": context.data.get(\"handleEnd\", 1),\n                \"representations\": [\n                    {\n                        \"name\": ext.lstrip(\".\"),\n                        \"ext\": ext.lstrip(\".\"),\n                        \"files\": filepath.name,\n                        \"stagingDir\": filepath.parent,\n                    }\n                ],\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_workfile.html#client.ayon_blender.plugins.publish.collect_workfile.CollectWorkfile.process","title":"<code>process(instance)</code>","text":"<p>Process collector.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process collector.\"\"\"\n\n    context = instance.context\n    filepath = context.data.get(\"currentFile\")\n    if not filepath:\n        self.log.warning(\"Deactivating workfile instance because no \"\n                         \"current filepath is found. Please save your \"\n                         \"workfile.\")\n        instance.data[\"publish\"] = False\n        return\n\n    filepath = Path(filepath)\n    ext = filepath.suffix\n\n    instance.data.update(\n        {\n            \"setMembers\": [filepath.as_posix()],\n            \"frameStart\": context.data.get(\"frameStart\", 1),\n            \"frameEnd\": context.data.get(\"frameEnd\", 1),\n            \"handleStart\": context.data.get(\"handleStart\", 1),\n            \"handledEnd\": context.data.get(\"handleEnd\", 1),\n            \"representations\": [\n                {\n                    \"name\": ext.lstrip(\".\"),\n                    \"ext\": ext.lstrip(\".\"),\n                    \"files\": filepath.name,\n                    \"stagingDir\": filepath.parent,\n                }\n            ],\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc.html","title":"extract_abc","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc.html#client.ayon_blender.plugins.publish.extract_abc.ExtractABC","title":"<code>ExtractABC</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as ABC.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_abc.py</code> <pre><code>class ExtractABC(plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract as ABC.\"\"\"\n\n    label = \"Extract ABC\"\n    hosts = [\"blender\"]\n    families = [\"pointcache\"]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        attr_values = self.get_attr_values_from_data(instance.data)\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.abc\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        selected = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object):\n                obj.select_set(True)\n                selected.append(obj)\n\n        context = plugin.create_blender_context(\n            active=asset_group, selected=selected)\n\n        # Supply frame range if set on instance\n        kwargs = {}\n        if \"frameStartHandle\" in instance.data:\n            kwargs[\"start\"]: int = instance.data[\"frameStartHandle\"]\n        if \"frameEndHandle\" in instance.data:\n            kwargs[\"end\"]: int = instance.data[\"frameEndHandle\"]\n\n        with bpy.context.temp_override(**context):\n            # We export the abc\n            bpy.ops.wm.alembic_export(\n                filepath=filepath,\n                selected=True,\n                flatten=False,\n                subdiv_schema=attr_values.get(\"subdiv_schema\", False),\n                **kwargs\n            )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            BoolDef(\n                \"subdiv_schema\",\n                label=\"Alembic Mesh Subdiv Schema\",\n                tooltip=\"Export Meshes using Alembic's subdivision schema.\\n\"\n                        \"Enabling this includes creases with the export but \"\n                        \"excludes the mesh's normals.\\n\"\n                        \"Enabling this usually result in smaller file size \"\n                        \"due to lack of normals.\",\n                default=False\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc.html#client.ayon_blender.plugins.publish.extract_abc.ExtractModelABC","title":"<code>ExtractModelABC</code>","text":"<p>               Bases: <code>ExtractABC</code></p> <p>Extract model as ABC.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_abc.py</code> <pre><code>class ExtractModelABC(ExtractABC):\n    \"\"\"Extract model as ABC.\"\"\"\n\n    label = \"Extract Model ABC\"\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    optional = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc_animation.html","title":"extract_abc_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc_animation.html#client.ayon_blender.plugins.publish.extract_abc_animation.ExtractAnimationABC","title":"<code>ExtractAnimationABC</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as ABC.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_abc_animation.py</code> <pre><code>class ExtractAnimationABC(\n    plugin.BlenderExtractor,\n    publish.OptionalPyblishPluginMixin,\n):\n    \"\"\"Extract as ABC.\"\"\"\n\n    label = \"Extract Animation ABC\"\n    hosts = [\"blender\"]\n    families = [\"animation\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.abc\"\n\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        selected = []\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        objects = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Collection):\n                for child in obj.all_objects:\n                    objects.append(child)\n        for obj in objects:\n            children = [o for o in bpy.data.objects if o.parent == obj]\n            for child in children:\n                objects.append(child)\n\n        for obj in objects:\n            obj.select_set(True)\n            selected.append(obj)\n\n        context = plugin.create_blender_context(\n            active=asset_group, selected=selected)\n        with bpy.context.temp_override(**context):\n            # We export the abc\n            bpy.ops.wm.alembic_export(\n                filepath=filepath,\n                selected=True,\n                flatten=False,\n                start=instance.data[\"frameStartHandle\"],\n                end=instance.data[\"frameEndHandle\"]\n            )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html","title":"extract_blend","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html#client.ayon_blender.plugins.publish.extract_blend.ExtractBlend","title":"<code>ExtractBlend</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a blend file.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend.py</code> <pre><code>class ExtractBlend(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract a blend file.\"\"\"\n\n    label = \"Extract Blend\"\n    hosts = [\"blender\"]\n    families = [\"model\", \"camera\", \"rig\", \"action\", \"layout\", \"blendScene\"]\n    optional = True\n\n    # From settings\n    compress = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.blend\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        data_blocks = set()\n\n        for data in instance:\n            data_blocks.add(data)\n            # Pack used images in the blend files.\n            if not (\n                isinstance(data, bpy.types.Object) and data.type == 'MESH'\n            ):\n                continue\n            for material_slot in data.material_slots:\n                mat = material_slot.material\n                if not (mat and mat.use_nodes):\n                    continue\n                tree = mat.node_tree\n                if tree.type != 'SHADER':\n                    continue\n                for node in tree.nodes:\n                    if node.bl_idname != 'ShaderNodeTexImage':\n                        continue\n                    # Check if image is not packed already\n                    # and pack it if not.\n                    if node.image and node.image.packed_file is None:\n                        node.image.pack()\n\n        bpy.data.libraries.write(filepath, data_blocks, compress=self.compress)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'blend',\n            'ext': 'blend',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend_animation.html","title":"extract_blend_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend_animation.html#client.ayon_blender.plugins.publish.extract_blend_animation.ExtractBlendAnimation","title":"<code>ExtractBlendAnimation</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a blend file.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend_animation.py</code> <pre><code>class ExtractBlendAnimation(\n    plugin.BlenderExtractor,\n    publish.OptionalPyblishPluginMixin,\n):\n    \"\"\"Extract a blend file.\"\"\"\n\n    label = \"Extract Blend\"\n    hosts = [\"blender\"]\n    families = [\"animation\"]\n    optional = True\n\n    # From settings\n    compress = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.blend\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        data_blocks = set()\n\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == 'EMPTY':\n                child = obj.children[0]\n                if child and child.type == 'ARMATURE':\n                    if child.animation_data and child.animation_data.action:\n                        if not obj.animation_data:\n                            obj.animation_data_create()\n                        obj.animation_data.action = child.animation_data.action\n                        obj.animation_data_clear()\n                        data_blocks.add(child.animation_data.action)\n                        data_blocks.add(obj)\n\n        bpy.data.libraries.write(filepath, data_blocks, compress=self.compress)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'blend',\n            'ext': 'blend',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_abc.html","title":"extract_camera_abc","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_abc.html#client.ayon_blender.plugins.publish.extract_camera_abc.ExtractCameraABC","title":"<code>ExtractCameraABC</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract camera as ABC.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_camera_abc.py</code> <pre><code>class ExtractCameraABC(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract camera as ABC.\"\"\"\n\n    label = \"Extract Camera (ABC)\"\n    hosts = [\"blender\"]\n    families = [\"camera\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.abc\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        # Need to cast to list because children is a tuple\n        selected = list(asset_group.children)\n        active = selected[0]\n\n        for obj in selected:\n            obj.select_set(True)\n\n        context = plugin.create_blender_context(\n            active=active, selected=selected)\n\n        scene_overrides = {\n            \"unit_settings.scale_length\": instance.data.get(\"unitScale\"),\n        }\n        # Skip None value overrides\n        scene_overrides = {\n            key: value for key, value in scene_overrides.items()\n            if value is not None\n        }\n\n        with lib.attribute_overrides(bpy.context.scene, scene_overrides):\n            with bpy.context.temp_override(**context):\n                # We export the abc\n                bpy.ops.wm.alembic_export(\n                    filepath=filepath,\n                    selected=True,\n                    flatten=True,\n                    start=instance.data[\"frameStartHandle\"],\n                    end=instance.data[\"frameEndHandle\"]\n                )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_fbx.html","title":"extract_camera_fbx","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_fbx.html#client.ayon_blender.plugins.publish.extract_camera_fbx.ExtractCamera","title":"<code>ExtractCamera</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as the camera as FBX.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_camera_fbx.py</code> <pre><code>class ExtractCamera(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract as the camera as FBX.\"\"\"\n\n    label = \"Extract Camera (FBX)\"\n    hosts = [\"blender\"]\n    families = [\"camera\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.fbx\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        selected = []\n\n        camera = None\n\n        for obj in instance:\n            if obj.type == \"CAMERA\":\n                obj.select_set(True)\n                selected.append(obj)\n                camera = obj\n                break\n\n        assert camera, \"No camera found\"\n\n        context = plugin.create_blender_context(\n            active=camera, selected=selected)\n\n        scene_overrides = {\n            \"frame_start\": instance.data.get(\"frameStart\"),\n            \"frame_end\": instance.data.get(\"frameEnd\"),\n            \"frame_step\": instance.data.get(\"frameStep\"),\n            \"render.fps\": instance.data.get(\"fps\")\n        }\n        # Skip None value overrides\n        scene_overrides = {\n            key: value for key, value in scene_overrides.items()\n            if value is not None\n        }\n        if \"render.fps\" in scene_overrides:\n            scene_overrides[\"render.fps_base\"] = 1\n\n        with lib.attribute_overrides(bpy.context.scene, scene_overrides):\n            with bpy.context.temp_override(**context):\n                # We export the fbx\n                bpy.ops.export_scene.fbx(\n                    filepath=filepath,\n                    use_active_collection=False,\n                    use_selection=True,\n                    bake_anim_use_nla_strips=False,\n                    bake_anim_use_all_actions=False,\n                    add_leaf_bones=False,\n                    armature_nodetype='ROOT',\n                    object_types={'CAMERA'},\n                    bake_anim_simplify_factor=0.0\n                )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx.html","title":"extract_fbx","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx.html#client.ayon_blender.plugins.publish.extract_fbx.ExtractFBX","title":"<code>ExtractFBX</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as FBX.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_fbx.py</code> <pre><code>class ExtractFBX(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract as FBX.\"\"\"\n\n    label = \"Extract FBX\"\n    hosts = [\"blender\"]\n    families = [\"model\", \"rig\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.fbx\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        selected = []\n        for obj in instance:\n            obj.select_set(True)\n            selected.append(obj)\n\n        context = plugin.create_blender_context(\n            active=asset_group, selected=selected)\n\n        new_materials = []\n        new_materials_objs = []\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            objects.extend(obj.children)\n            if obj.type == 'MESH' and len(obj.data.materials) == 0:\n                mat = bpy.data.materials.new(obj.name)\n                obj.data.materials.append(mat)\n                new_materials.append(mat)\n                new_materials_objs.append(obj)\n\n        with bpy.context.temp_override(**context):\n            # We export the fbx\n            bpy.ops.export_scene.fbx(\n                filepath=filepath,\n                use_active_collection=False,\n                use_selection=True,\n                mesh_smooth_type='FACE',\n                add_leaf_bones=False\n            )\n\n        plugin.deselect_all()\n\n        for mat in new_materials:\n            bpy.data.materials.remove(mat)\n\n        for obj in new_materials_objs:\n            obj.data.materials.pop()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx_animation.html","title":"extract_fbx_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx_animation.html#client.ayon_blender.plugins.publish.extract_fbx_animation.ExtractAnimationFBX","title":"<code>ExtractAnimationFBX</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as animation.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_fbx_animation.py</code> <pre><code>class ExtractAnimationFBX(\n    plugin.BlenderExtractor,\n    publish.OptionalPyblishPluginMixin,\n):\n    \"\"\"Extract as animation.\"\"\"\n\n    label = \"Extract FBX\"\n    hosts = [\"blender\"]\n    families = [\"animation\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        # Get objects in this collection (but not in children collections)\n        # and for those objects include the children hierarchy\n        # TODO: Would it make more sense for the Collect Instance collector\n        #   to also always retrieve all the children?\n        objects = set(asset_group.objects)\n\n        # From the direct children of the collection find the 'root' node\n        # that we want to export - it is the 'highest' node in a hierarchy\n        root = get_highest_root(objects)\n\n        for obj in list(objects):\n            objects.update(obj.children_recursive)\n\n        # Find all armatures among the objects, assume to find only one\n        armatures = [obj for obj in objects if obj.type == \"ARMATURE\"]\n        if not armatures:\n            raise RuntimeError(\n                f\"Unable to find ARMATURE in collection: \"\n                f\"{asset_group.name}\"\n            )\n        elif len(armatures) &gt; 1:\n            self.log.warning(\n                \"Found more than one ARMATURE, using \"\n                f\"only first of: {armatures}\"\n            )\n        armature = armatures[0]\n\n        object_action_pairs = []\n        original_actions = []\n\n        starting_frames = []\n        ending_frames = []\n\n        # For each armature, we make a copy of the current action\n        if armature.animation_data and armature.animation_data.action:\n            curr_action = armature.animation_data.action\n            copy_action = curr_action.copy()\n\n            curr_frame_range = curr_action.frame_range\n\n            starting_frames.append(curr_frame_range[0])\n            ending_frames.append(curr_frame_range[1])\n        else:\n            self.log.info(\n                f\"Armature '{armature.name}' has no animation, \"\n                f\"skipping FBX animation extraction for {instance}.\"\n            )\n            return\n\n        asset_group_name = asset_group.name\n        asset_name = asset_group.get(AVALON_PROPERTY).get(\"asset_name\")\n        if asset_name:\n            # Rename for the export; this data is only present when loaded\n            # from a JSON Layout (layout family)\n            asset_group.name = asset_name\n\n        # Remove : from the armature name for the export\n        armature_name = armature.name\n        original_name = armature_name.split(':')[1]\n        armature.name = original_name\n\n        object_action_pairs.append((armature, copy_action))\n        original_actions.append(curr_action)\n\n        # We compute the starting and ending frames\n        max_frame = min(starting_frames)\n        min_frame = max(ending_frames)\n\n        # We bake the copy of the current action for each object\n        bpy_extras.anim_utils.bake_action_objects(\n            object_action_pairs,\n            frames=range(int(min_frame), int(max_frame)),\n            do_object=False,\n            do_clean=False\n        )\n\n        for obj in bpy.data.objects:\n            obj.select_set(False)\n\n        root.select_set(True)\n        armature.select_set(True)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        fbx_filename = f\"{instance_name}_{armature.name}.fbx\"\n        filepath = os.path.join(stagingdir, fbx_filename)\n\n        override = plugin.create_blender_context(\n            active=root, selected=[root, armature])\n\n        with bpy.context.temp_override(**override):\n            # We export the fbx\n            bpy.ops.export_scene.fbx(\n                filepath=filepath,\n                use_active_collection=False,\n                use_selection=True,\n                bake_anim_use_nla_strips=False,\n                bake_anim_use_all_actions=False,\n                add_leaf_bones=False,\n                armature_nodetype='ROOT',\n                object_types={'EMPTY', 'ARMATURE'}\n            )\n\n        armature.name = armature_name\n        asset_group.name = asset_group_name\n        root.select_set(True)\n        armature.select_set(False)\n\n        # We delete the baked action and set the original one back\n        for i in range(0, len(object_action_pairs)):\n            pair = object_action_pairs[i]\n            action = original_actions[i]\n\n            if action:\n                pair[0].animation_data.action = action\n\n            if pair[1]:\n                pair[1].user_clear()\n                bpy.data.actions.remove(pair[1])\n\n        json_filename = f\"{instance_name}.json\"\n        json_path = os.path.join(stagingdir, json_filename)\n\n        json_dict = {\n            \"instance_name\": asset_group.get(AVALON_PROPERTY).get(\"objectName\")\n        }\n\n        # collection = instance.data.get(\"name\")\n        # container = None\n        # for obj in bpy.data.collections[collection].objects:\n        #     if obj.type == \"ARMATURE\":\n        #         container_name = obj.get(\"avalon\").get(\"container_name\")\n        #         container = bpy.data.collections[container_name]\n        # if container:\n        #     json_dict = {\n        #         \"instance_name\": container.get(\"avalon\").get(\"instance_name\")\n        #     }\n\n        with open(json_path, \"w+\") as file:\n            json.dump(json_dict, fp=file, indent=2)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        fbx_representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': fbx_filename,\n            \"stagingDir\": stagingdir,\n        }\n        json_representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(fbx_representation)\n        instance.data[\"representations\"].append(json_representation)\n\n        self.log.debug(\"Extracted instance '{}' to: {}\".format(\n                       instance.name, fbx_representation))\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx_animation.html#client.ayon_blender.plugins.publish.extract_fbx_animation.get_all_parents","title":"<code>get_all_parents(obj)</code>","text":"<p>Get all recursive parents of object</p> Source code in <code>client/ayon_blender/plugins/publish/extract_fbx_animation.py</code> <pre><code>def get_all_parents(obj):\n    \"\"\"Get all recursive parents of object\"\"\"\n    result = []\n    while True:\n        obj = obj.parent\n        if not obj:\n            break\n        result.append(obj)\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_layout.html","title":"extract_layout","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_layout.html#client.ayon_blender.plugins.publish.extract_layout.ExtractLayout","title":"<code>ExtractLayout</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a layout.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_layout.py</code> <pre><code>class ExtractLayout(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract a layout.\"\"\"\n\n    label = \"Extract Layout (JSON)\"\n    hosts = [\"blender\"]\n    families = [\"layout\"]\n    optional = True\n\n    def _export_animation(self, asset, instance, stagingdir, fbx_count):\n        n = fbx_count\n\n        for obj in asset.children:\n            if obj.type != \"ARMATURE\":\n                continue\n\n            object_action_pairs = []\n            original_actions = []\n\n            starting_frames = []\n            ending_frames = []\n\n            # For each armature, we make a copy of the current action\n            curr_action = None\n            copy_action = None\n\n            if obj.animation_data and obj.animation_data.action:\n                curr_action = obj.animation_data.action\n                copy_action = curr_action.copy()\n\n                curr_frame_range = curr_action.frame_range\n\n                starting_frames.append(curr_frame_range[0])\n                ending_frames.append(curr_frame_range[1])\n            else:\n                self.log.info(\"Object has no animation.\")\n                continue\n\n            asset_group_name = asset.name\n            asset.name = asset.get(AVALON_PROPERTY).get(\"asset_name\")\n\n            armature_name = obj.name\n            original_name = armature_name.split(':')[1]\n            obj.name = original_name\n\n            object_action_pairs.append((obj, copy_action))\n            original_actions.append(curr_action)\n\n            # We compute the starting and ending frames\n            max_frame = min(starting_frames)\n            min_frame = max(ending_frames)\n\n            # We bake the copy of the current action for each object\n            bpy_extras.anim_utils.bake_action_objects(\n                object_action_pairs,\n                frames=range(int(min_frame), int(max_frame)),\n                do_object=False,\n                do_clean=False\n            )\n\n            for o in bpy.data.objects:\n                o.select_set(False)\n\n            asset.select_set(True)\n            obj.select_set(True)\n            fbx_filename = f\"{n:03d}.fbx\"\n            filepath = os.path.join(stagingdir, fbx_filename)\n\n            override = plugin.create_blender_context(\n                active=asset, selected=[asset, obj])\n            with bpy.context.temp_override(**override):\n                # We export the fbx\n                bpy.ops.export_scene.fbx(\n                    filepath=filepath,\n                    use_active_collection=False,\n                    use_selection=True,\n                    bake_anim_use_nla_strips=False,\n                    bake_anim_use_all_actions=False,\n                    add_leaf_bones=False,\n                    armature_nodetype='ROOT',\n                    object_types={'EMPTY', 'ARMATURE'}\n                )\n            obj.name = armature_name\n            asset.name = asset_group_name\n            asset.select_set(False)\n            obj.select_set(False)\n\n            # We delete the baked action and set the original one back\n            for i in range(0, len(object_action_pairs)):\n                pair = object_action_pairs[i]\n                action = original_actions[i]\n\n                if action:\n                    pair[0].animation_data.action = action\n\n                if pair[1]:\n                    pair[1].user_clear()\n                    bpy.data.actions.remove(pair[1])\n\n            return fbx_filename, n + 1\n\n        return None, n\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        json_data = []\n        fbx_files = []\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        fbx_count = 0\n\n        project_name = instance.context.data[\"projectName\"]\n        version_ids = set()\n        filtered_assets = []\n        for asset in asset_group.children:\n            metadata = asset.get(AVALON_PROPERTY)\n            if not metadata:\n                # Avoid raising error directly if there's just invalid data\n                # inside the instance; better to log it to the artist\n                # TODO: This should actually be validated in a validator\n                self.log.warning(\n                    f\"Found content in layout that is not a loaded \"\n                    f\"asset, skipping: {asset.name_full}\"\n                )\n                continue\n\n            filtered_assets.append((asset, metadata))\n            version_ids.add(metadata[\"parent\"])\n\n        repre_entities = get_representations(\n            project_name,\n            representation_names={\"blend\", \"fbx\", \"abc\"},\n            version_ids=version_ids,\n            fields={\"id\", \"versionId\", \"name\"}\n        )\n        repre_mapping_by_version_id = {\n            version_id: {}\n            for version_id in version_ids\n        }\n        for repre_entity in repre_entities:\n            version_id = repre_entity[\"versionId\"]\n            repre_mapping_by_version_id[version_id][repre_entity[\"name\"]] = (\n                repre_entity\n            )\n\n        for asset, metadata in filtered_assets:\n            version_id = metadata[\"parent\"]\n            product_type = metadata.get(\"product_type\")\n            if product_type is None:\n                product_type = metadata[\"family\"]\n\n            repres_by_name = repre_mapping_by_version_id[version_id]\n\n            self.log.debug(\"Parent: {}\".format(version_id))\n            # Get blend, fbx and abc reference\n            blend_id = repres_by_name.get(\"blend\", {}).get(\"id\")\n            fbx_id = repres_by_name.get(\"fbx\", {}).get(\"id\")\n            abc_id = repres_by_name.get(\"abc\", {}).get(\"id\")\n            json_element = {\n                key: value\n                for key, value in (\n                    (\"reference\", blend_id),\n                    (\"reference_fbx\", fbx_id),\n                    (\"reference_abc\", abc_id),\n                )\n                if value\n            }\n            json_element[\"product_type\"] = product_type\n            json_element[\"instance_name\"] = asset.name\n            json_element[\"asset_name\"] = metadata[\"asset_name\"]\n            json_element[\"file_path\"] = metadata[\"libpath\"]\n\n            json_element[\"transform\"] = {\n                \"translation\": {\n                    \"x\": asset.location.x,\n                    \"y\": asset.location.y,\n                    \"z\": asset.location.z\n                },\n                \"rotation\": {\n                    \"x\": asset.rotation_euler.x,\n                    \"y\": asset.rotation_euler.y,\n                    \"z\": asset.rotation_euler.z\n                },\n                \"scale\": {\n                    \"x\": asset.scale.x,\n                    \"y\": asset.scale.y,\n                    \"z\": asset.scale.z\n                }\n            }\n\n            json_element[\"transform_matrix\"] = []\n\n            for row in list(asset.matrix_world.transposed()):\n                json_element[\"transform_matrix\"].append(list(row))\n\n            json_element[\"basis\"] = [\n                [1, 0, 0, 0],\n                [0, -1, 0, 0],\n                [0, 0, 1, 0],\n                [0, 0, 0, 1]\n            ]\n\n            # Extract the animation as well\n            if product_type == \"rig\":\n                f, n = self._export_animation(\n                    asset, instance, stagingdir, fbx_count)\n                if f:\n                    fbx_files.append(f)\n                    json_element[\"animation\"] = f\n                    fbx_count = n\n\n            json_data.append(json_element)\n\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        json_filename = f\"{instance_name}.json\"\n\n        json_path = os.path.join(stagingdir, json_filename)\n\n        with open(json_path, \"w+\") as file:\n            json.dump(json_data, fp=file, indent=2)\n\n        json_representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(json_representation)\n\n        self.log.debug(fbx_files)\n\n        if len(fbx_files) == 1:\n            fbx_representation = {\n                'name': 'fbx',\n                'ext': '000.fbx',\n                'files': fbx_files[0],\n                \"stagingDir\": stagingdir,\n            }\n            instance.data[\"representations\"].append(fbx_representation)\n        elif len(fbx_files) &gt; 1:\n            fbx_representation = {\n                'name': 'fbx',\n                'ext': 'fbx',\n                'files': fbx_files,\n                \"stagingDir\": stagingdir,\n            }\n            instance.data[\"representations\"].append(fbx_representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, json_representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_playblast.html","title":"extract_playblast","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_playblast.html#client.ayon_blender.plugins.publish.extract_playblast.ExtractPlayblast","title":"<code>ExtractPlayblast</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract viewport playblast.</p> <p>Takes review camera and creates review Quicktime video based on viewport capture.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_playblast.py</code> <pre><code>class ExtractPlayblast(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"\n    Extract viewport playblast.\n\n    Takes review camera and creates review Quicktime video based on viewport\n    capture.\n    \"\"\"\n\n    label = \"Extract Playblast\"\n    hosts = [\"blender\"]\n    families = [\"review\"]\n    optional = True\n    order = pyblish.api.ExtractorOrder + 0.01\n\n    presets = \"{}\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # get scene fps\n        fps = instance.data.get(\"fps\")\n        if fps is None:\n            fps = bpy.context.scene.render.fps\n            instance.data[\"fps\"] = fps\n\n        self.log.debug(f\"fps: {fps}\")\n\n        # If start and end frames cannot be determined,\n        # get them from Blender timeline.\n        start = instance.data.get(\"frameStart\", bpy.context.scene.frame_start)\n        end = instance.data.get(\"frameEnd\", bpy.context.scene.frame_end)\n\n        self.log.debug(f\"start: {start}, end: {end}\")\n        assert end &gt;= start, \"Invalid time range!\"\n\n        # get cameras\n        camera = instance.data(\"review_camera\", None)\n\n        # get isolate objects list\n        isolate = instance.data(\"isolate\", None)\n\n        # get output path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        filename = f\"{folder_name}_{product_name}\"\n\n        path = os.path.join(stagingdir, filename)\n\n        self.log.debug(f\"Outputting images to {path}\")\n\n        presets = json.loads(self.presets)\n        preset = presets.get(\"default\")\n        preset.update({\n            \"camera\": camera,\n            \"start_frame\": start,\n            \"end_frame\": end,\n            \"filename\": path,\n            \"overwrite\": True,\n            \"isolate\": isolate,\n        })\n        preset.setdefault(\n            \"image_settings\",\n            {\n                \"file_format\": \"PNG\",\n                \"color_mode\": \"RGB\",\n                \"color_depth\": \"8\",\n                \"compression\": 15,\n            },\n        )\n\n        with maintained_time():\n            path = capture(**preset)\n\n        self.log.debug(f\"playblast path {path}\")\n\n        collected_files = os.listdir(stagingdir)\n        collections, remainder = clique.assemble(\n            collected_files,\n            patterns=[f\"{filename}\\\\.{clique.DIGITS_PATTERN}\\\\.png$\"],\n            minimum_items=1\n        )\n\n        if len(collections) &gt; 1:\n            raise RuntimeError(\n                f\"More than one collection found in stagingdir: {stagingdir}\"\n            )\n        elif len(collections) == 0:\n            raise RuntimeError(\n                f\"No collection found in stagingdir: {stagingdir}\"\n            )\n\n        frame_collection = collections[0]\n\n        self.log.debug(f\"Found collection of interest {frame_collection}\")\n\n        # `instance.data[\"files\"]` must be `str` if single frame\n        files = list(frame_collection)\n        if len(files) == 1:\n            files = files[0]\n\n        tags = [\"review\"]\n        if not instance.data.get(\"keepImages\"):\n            tags.append(\"delete\")\n\n        representation = {\n            \"name\": \"png\",\n            \"ext\": \"png\",\n            \"files\": files,\n            \"stagingDir\": stagingdir,\n            \"frameStart\": start,\n            \"frameEnd\": end,\n            \"fps\": fps,\n            \"tags\": tags,\n            \"camera_name\": camera\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_thumbnail.html","title":"extract_thumbnail","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_thumbnail.html#client.ayon_blender.plugins.publish.extract_thumbnail.ExtractThumbnail","title":"<code>ExtractThumbnail</code>","text":"<p>               Bases: <code>BlenderExtractor</code></p> <p>Extract viewport thumbnail.</p> <p>Takes review camera and creates a thumbnail based on viewport capture.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_thumbnail.py</code> <pre><code>class ExtractThumbnail(plugin.BlenderExtractor):\n    \"\"\"Extract viewport thumbnail.\n\n    Takes review camera and creates a thumbnail based on viewport\n    capture.\n\n    \"\"\"\n\n    label = \"Extract Thumbnail\"\n    hosts = [\"blender\"]\n    families = [\"review\"]\n    order = pyblish.api.ExtractorOrder + 0.01\n    presets = \"{}\"\n\n    def process(self, instance):\n        self.log.debug(\"Extracting capture..\")\n\n        if instance.data.get(\"thumbnailSource\"):\n            self.log.debug(\"Thumbnail source found, skipping...\")\n            return\n\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        filename = f\"{folder_name}_{product_name}\"\n\n        path = os.path.join(stagingdir, filename)\n\n        self.log.debug(f\"Outputting images to {path}\")\n\n        camera = instance.data.get(\"review_camera\", \"AUTO\")\n        start = instance.data.get(\"frameStart\", bpy.context.scene.frame_start)\n        product_type = instance.data[\"productType\"]\n        isolate = instance.data(\"isolate\", None)\n\n        presets = json.loads(self.presets)\n        preset = presets.get(product_type, {})\n\n        preset.update({\n            \"camera\": camera,\n            \"start_frame\": start,\n            \"end_frame\": start,\n            \"filename\": path,\n            \"overwrite\": True,\n            \"isolate\": isolate,\n        })\n        preset.setdefault(\n            \"image_settings\",\n            {\n                \"file_format\": \"JPEG\",\n                \"color_mode\": \"RGB\",\n                \"quality\": 100,\n            },\n        )\n\n        with maintained_time():\n            path = capture(**preset)\n\n        thumbnail = os.path.basename(self._fix_output_path(path))\n\n        self.log.debug(f\"thumbnail: {thumbnail}\")\n\n        instance.data.setdefault(\"representations\", [])\n\n        representation = {\n            \"name\": \"thumbnail\",\n            \"ext\": \"jpg\",\n            \"files\": thumbnail,\n            \"stagingDir\": stagingdir,\n            \"thumbnail\": True\n        }\n        instance.data[\"representations\"].append(representation)\n\n    def _fix_output_path(self, filepath):\n        \"\"\"Workaround to return correct filepath.\n\n        To workaround this we just glob.glob() for any file extensions and\n        assume the latest modified file is the correct file and return it.\n\n        \"\"\"\n        # Catch cancelled playblast\n        if filepath is None:\n            self.log.warning(\n                \"Playblast did not result in output path. \"\n                \"Playblast is probably interrupted.\"\n            )\n            return None\n\n        if not os.path.exists(filepath):\n            files = glob.glob(f\"{filepath}.*.jpg\")\n\n            if not files:\n                raise RuntimeError(f\"Couldn't find playblast from: {filepath}\")\n            filepath = max(files, key=os.path.getmtime)\n\n        return filepath\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_usd.html","title":"extract_usd","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_usd.html#client.ayon_blender.plugins.publish.extract_usd.ExtractModelUSD","title":"<code>ExtractModelUSD</code>","text":"<p>               Bases: <code>ExtractUSD</code></p> <p>Extract model as USD.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_usd.py</code> <pre><code>class ExtractModelUSD(ExtractUSD):\n    \"\"\"Extract model as USD.\"\"\"\n\n    label = \"Extract USD (Model)\"\n    hosts = [\"blender\"]\n    families = [\"model\"]\n\n    # Driven by settings\n    optional = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_usd.html#client.ayon_blender.plugins.publish.extract_usd.ExtractUSD","title":"<code>ExtractUSD</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as USD.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_usd.py</code> <pre><code>class ExtractUSD(plugin.BlenderExtractor,\n                 OptionalPyblishPluginMixin):\n    \"\"\"Extract as USD.\"\"\"\n\n    label = \"Extract USD\"\n    hosts = [\"blender\"]\n    families = [\"usd\"]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Ignore runtime instances (e.g. USD layers)\n        # TODO: This is better done via more specific `families`\n        if not instance.data.get(\"transientData\", {}).get(\"instance_node\"):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        filename = f\"{instance.name}.usd\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        # Select all members to \"export selected\"\n        plugin.deselect_all()\n\n        selected = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object):\n                obj.select_set(True)\n                selected.append(obj)\n\n        root = lib.get_highest_root(objects=instance[:])\n        if not root:\n            instance_node = instance.data[\"transientData\"][\"instance_node\"]\n            raise KnownPublishError(\n                f\"No root object found in instance: {instance_node.name}\"\n            )\n        self.log.debug(f\"Exporting using active root: {root.name}\")\n\n        context = plugin.create_blender_context(\n            active=root, selected=selected)\n\n        # Export USD\n        with bpy.context.temp_override(**context):\n            bpy.ops.wm.usd_export(\n                filepath=filepath,\n                selected_objects_only=True,\n                export_textures=False,\n                relative_paths=False,\n                export_animation=False,\n                export_hair=False,\n                export_uvmaps=True,\n                # TODO: add for new version of Blender (4+?)\n                # export_mesh_colors=True,\n                export_normals=True,\n                export_materials=True,\n                use_instancing=True\n            )\n\n        plugin.deselect_all()\n\n        # Add representation\n        representation = {\n            'name': 'usd',\n            'ext': 'usd',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/increment_workfile_version.html","title":"increment_workfile_version","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/increment_workfile_version.html#client.ayon_blender.plugins.publish.increment_workfile_version.IncrementWorkfileVersion","title":"<code>IncrementWorkfileVersion</code>","text":"<p>               Bases: <code>BlenderContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Increment current workfile version.</p> Source code in <code>client/ayon_blender/plugins/publish/increment_workfile_version.py</code> <pre><code>class IncrementWorkfileVersion(\n    plugin.BlenderContextPlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Increment current workfile version.\"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.9\n    label = \"Increment Workfile Version\"\n    optional = True\n    hosts = [\"blender\"]\n    families = [\"animation\", \"model\", \"rig\", \"action\", \"layout\", \"blendScene\",\n                \"pointcache\", \"render.farm\"]\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        assert all(result[\"success\"] for result in context.data[\"results\"]), (\n            \"Publishing not successful so version is not increased.\")\n\n        from ayon_core.lib import version_up\n        path = context.data[\"currentFile\"]\n        filepath = version_up(path)\n\n        save_file(filepath, copy=False)\n\n        self.log.debug('Incrementing blender workfile version')\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/integrate_animation.html","title":"integrate_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/integrate_animation.html#client.ayon_blender.plugins.publish.integrate_animation.IntegrateAnimation","title":"<code>IntegrateAnimation</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Generate a JSON file for animation.</p> Source code in <code>client/ayon_blender/plugins/publish/integrate_animation.py</code> <pre><code>class IntegrateAnimation(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Generate a JSON file for animation.\"\"\"\n\n    label = \"Integrate Animation\"\n    order = pyblish.api.IntegratorOrder + 0.1\n    optional = True\n    hosts = [\"blender\"]\n    families = [\"setdress\"]\n\n    def process(self, instance):\n        self.log.debug(\"Integrate Animation\")\n\n        representation = instance.data.get('representations')[0]\n        json_path = representation.get('publishedFiles')[0]\n\n        with open(json_path, \"r\") as file:\n            data = json.load(file)\n\n        # Update the json file for the setdress to add the published\n        # representations of the animations\n        for json_dict in data:\n            json_product_name = json_dict[\"productName\"]\n            i = None\n            for elem in instance.context:\n                if elem.data[\"productName\"] == json_product_name:\n                    i = elem\n                    break\n            if not i:\n                continue\n            rep = None\n            pub_repr = i.data[\"published_representations\"]\n            for elem in pub_repr:\n                if pub_repr[elem][\"representation\"][\"name\"] == \"fbx\":\n                    rep = pub_repr[elem]\n                    break\n            if not rep:\n                continue\n            obj_id = rep[\"representation\"][\"id\"]\n\n            if obj_id:\n                json_dict[\"representation_id\"] = str(obj_id)\n\n        with open(json_path, \"w\") as file:\n            json.dump(data, fp=file, indent=2)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_absolute_external_data_paths.html","title":"validate_absolute_external_data_paths","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_absolute_external_data_paths.html#client.ayon_blender.plugins.publish.validate_absolute_external_data_paths.ValidateAbsoluteDataBlockPaths","title":"<code>ValidateAbsoluteDataBlockPaths</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates Absolute Data Block Paths</p> <p>This validator checks if all external data paths are absolute to ensure the links would not be broken when publishing</p> Source code in <code>client/ayon_blender/plugins/publish/validate_absolute_external_data_paths.py</code> <pre><code>class ValidateAbsoluteDataBlockPaths(pyblish.api.ContextPlugin,\n                                     OptionalPyblishPluginMixin):\n    \"\"\"Validates Absolute Data Block Paths\n\n    This validator checks if all external data paths are absolute\n    to ensure the links would not be broken when publishing\n    \"\"\"\n\n    label = \"Validate Absolute Data Block Paths\"\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"workfile\"]\n    optional = True\n    actions = [RepairContextAction]\n\n    @classmethod\n    def get_invalid(cls, context):\n        invalid = []\n        object_type = type(bpy.data.objects)\n        for attr in dir(bpy.data):\n            collections = getattr(bpy.data, attr)\n            if not isinstance(collections, object_type):\n                continue\n            for data_block in collections:\n                if not hasattr(data_block, \"filepath\"):\n                    continue\n                if not data_block.filepath:\n                    continue\n                if data_block.filepath == bpy.path.abspath(data_block.filepath):\n                    continue\n\n                cls.log.error(f\"Data block filepath {data_block.filepath} \"\n                              \"is not absolute path\")\n                invalid.append(data_block.filepath)\n        return invalid\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            self.log.debug(\"Skipping Validate Absolute Data Block Paths...\")\n            return\n        invalid = self.get_invalid(context)\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid Data block filepaths\",\n                title=\"Relative Data block filepaths\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_description(cls):\n        return inspect.cleandoc(\"\"\"\n            ### Data block filepaths are invalid\n            Data block filepaths must be absolute paths to avoid issues during relocation\n            of the published workfile into the publish folder.\n\n            #### How to repair?\n\n            Using the Repair action will turn all datablock filepaths in your scene into\n            absolute filepaths.\n\n        \"\"\")\n\n    @classmethod\n    def repair(cls, context):\n        return bpy.ops.file.make_paths_absolute()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_camera_zero_keyframe.html","title":"validate_camera_zero_keyframe","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_camera_zero_keyframe.html#client.ayon_blender.plugins.publish.validate_camera_zero_keyframe.ValidateCameraZeroKeyframe","title":"<code>ValidateCameraZeroKeyframe</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Camera must have a keyframe at frame 0.</p> <p>Unreal shifts the first keyframe to frame 0. Forcing the camera to have a keyframe at frame 0 will ensure that the animation will be the same in Unreal and Blender.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_camera_zero_keyframe.py</code> <pre><code>class ValidateCameraZeroKeyframe(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Camera must have a keyframe at frame 0.\n\n    Unreal shifts the first keyframe to frame 0. Forcing the camera to have\n    a keyframe at frame 0 will ensure that the animation will be the same\n    in Unreal and Blender.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"camera\"]\n    label = \"Zero Keyframe\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == \"CAMERA\":\n                if obj.animation_data and obj.animation_data.action:\n                    action = obj.animation_data.action\n                    frames_set = set()\n                    for fcu in action.fcurves:\n                        for kp in fcu.keyframe_points:\n                            frames_set.add(kp.co[0])\n                    frames = list(frames_set)\n                    frames.sort()\n                    if frames[0] != 0.0:\n                        invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Camera must have a keyframe at frame 0: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_deadline_publish.html","title":"validate_deadline_publish","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_deadline_publish.html#client.ayon_blender.plugins.publish.validate_deadline_publish.ValidateDeadlinePublish","title":"<code>ValidateDeadlinePublish</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates Render File Directory is not the same in every submission</p> Source code in <code>client/ayon_blender/plugins/publish/validate_deadline_publish.py</code> <pre><code>class ValidateDeadlinePublish(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validates Render File Directory is\n    not the same in every submission\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"renderlayer\"]\n    hosts = [\"blender\"]\n    label = \"Validate Render Output for Deadline\"\n    optional = True\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            bullet_point_invalid_statement = \"\\n\".join(\n                \"- {}\".format(err) for err in invalid\n            )\n            report = (\n                \"Render Output has invalid values(s).\\n\\n\"\n                f\"{bullet_point_invalid_statement}\\n\\n\"\n            )\n            raise PublishValidationError(\n                report,\n                title=\"Invalid value(s) for Render Output\")\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n        output_node = get_composite_output_node()\n        if not output_node:\n            msg = \"No output node found in the compositor tree.\"\n            invalid.append(msg)\n\n        filepath = bpy.data.filepath\n        file = os.path.basename(filepath)\n        filename, ext = os.path.splitext(file)\n        if filename not in output_node.base_path:\n            msg = (\n                \"Render output folder doesn't match the blender scene name! \"\n                \"Use Repair action to fix the folder file path.\"\n            )\n            invalid.append(msg)\n        if not bpy.context.scene.render.filepath:\n            msg = (\n                \"No render filepath set in the scene!\"\n                \"Use Repair action to fix the render filepath.\"\n            )\n            invalid.append(msg)\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        container = instance.data[\"transientData\"][\"instance_node\"]\n        output_node = get_composite_output_node()\n        render_data = container.get(\"render_data\")\n        aov_sep = render_data.get(\"aov_separator\")\n        filename = os.path.basename(bpy.data.filepath)\n        filename, ext = os.path.splitext(filename)\n        ext = ext.strip(\".\")\n        is_multilayer = render_data.get(\"multilayer_exr\")\n        orig_output_path = output_node.base_path\n        if is_multilayer:\n            render_folder = render_data.get(\"render_folder\")\n            output_dir = os.path.dirname(bpy.data.filepath)\n            output_dir = os.path.join(output_dir, render_folder, filename)\n            orig_output_dir = os.path.dirname(orig_output_path)\n            new_output_dir = orig_output_path.replace(orig_output_dir, output_dir)\n        else:\n            output_node_dir = os.path.dirname(orig_output_path)\n            new_output_dir = os.path.join(output_node_dir, filename)\n\n        output_node.base_path = new_output_dir\n\n        new_output_dir = (\n            Path(new_output_dir).parent\n            if is_multilayer else Path(new_output_dir)\n        )\n        render_product = render_data.get(\"render_product\")\n        aov_file_product = render_data.get(\"aov_file_product\")\n        updated_render_product = update_render_product(\n            container.name, new_output_dir,\n            render_product, aov_sep,\n            multilayer=is_multilayer\n        )\n        render_data[\"render_product\"] = updated_render_product\n        if aov_file_product:\n            updated_aov_file_product = update_render_product(\n                container.name, new_output_dir,\n                aov_file_product, aov_sep\n            )\n            render_data[\"aov_file_product\"] = updated_aov_file_product\n\n        tmp_render_path = os.path.join(os.getenv(\"AYON_WORKDIR\"), \"renders\", \"tmp\")\n        tmp_render_path = tmp_render_path.replace(\"\\\\\", \"/\")\n        os.makedirs(tmp_render_path, exist_ok=True)\n        bpy.context.scene.render.filepath = f\"{tmp_render_path}/\"\n\n        bpy.ops.wm.save_as_mainfile(filepath=bpy.data.filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_deadline_publish.html#client.ayon_blender.plugins.publish.validate_deadline_publish.get_composite_output_node","title":"<code>get_composite_output_node()</code>","text":"<p>Get composite output node for validation</p> <p>Returns:</p> Name Type Description <code>node</code> <p>composite output node</p> Source code in <code>client/ayon_blender/plugins/publish/validate_deadline_publish.py</code> <pre><code>def get_composite_output_node():\n    \"\"\"Get composite output node for validation\n\n    Returns:\n        node: composite output node\n    \"\"\"\n    tree = bpy.context.scene.node_tree\n    output_type = \"CompositorNodeOutputFile\"\n    output_node = None\n    # Remove all output nodes that include \"AYON\" in the name.\n    # There should be only one.\n    for node in tree.nodes:\n        if node.bl_idname == output_type and \"AYON\" in node.name:\n            output_node = node\n            break\n    return output_node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_file_saved.html","title":"validate_file_saved","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_file_saved.html#client.ayon_blender.plugins.publish.validate_file_saved.SaveWorkfileAction","title":"<code>SaveWorkfileAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Save Workfile.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_file_saved.py</code> <pre><code>class SaveWorkfileAction(pyblish.api.Action):\n    \"\"\"Save Workfile.\"\"\"\n    label = \"Save Workfile\"\n    on = \"failed\"\n    icon = \"save\"\n\n    def process(self, context, plugin):\n        bpy.ops.wm.avalon_workfiles()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_file_saved.html#client.ayon_blender.plugins.publish.validate_file_saved.ValidateFileSaved","title":"<code>ValidateFileSaved</code>","text":"<p>               Bases: <code>BlenderContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the workfile has been saved.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_file_saved.py</code> <pre><code>class ValidateFileSaved(\n    plugin.BlenderContextPlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validate that the workfile has been saved.\"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.01\n    hosts = [\"blender\"]\n    label = \"Validate File Saved\"\n    optional = False\n    # TODO rename to 'exclude_product_types'\n    exclude_families = []\n    actions = [SaveWorkfileAction]\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        if not context.data[\"currentFile\"]:\n            # File has not been saved at all and has no filename\n            raise PublishValidationError(\n                \"Current workfile has not been saved yet.\\n\"\n                \"Save the workfile before continuing.\"\n            )\n\n        # Do not validate workfile has unsaved changes if only instances\n        # present of families that should be excluded\n        product_types = {\n            instance.data[\"productType\"] for instance in context\n            # Consider only enabled instances\n            if instance.data.get(\"publish\", True)\n            and instance.data.get(\"active\", True)\n        }\n\n        def is_excluded(family):\n            return any(family in exclude_family\n                       for exclude_family in self.exclude_families)\n\n        if all(is_excluded(product_type) for product_type in product_types):\n            self.log.debug(\"Only excluded families found, skipping workfile \"\n                           \"unsaved changes validation..\")\n            return\n\n        if bpy.data.is_dirty:\n            raise PublishValidationError(\"Workfile has unsaved changes.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_frame_range.html","title":"validate_frame_range","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_frame_range.html#client.ayon_blender.plugins.publish.validate_frame_range.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the frame ranges.</p> <p>This is an optional validator checking if the frame range on instance matches the frame range specified for the folder.</p> <p>It also validates render frame ranges of render layers.</p> <p>Repair action will change everything to match the folder frame range.</p> <p>This can be turned off by the artist to allow custom ranges.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_frame_range.py</code> <pre><code>class ValidateFrameRange(pyblish.api.InstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validates the frame ranges.\n\n    This is an optional validator checking if the frame range on instance\n    matches the frame range specified for the folder.\n\n    It also validates render frame ranges of render layers.\n\n    Repair action will change everything to match the folder frame range.\n\n    This can be turned off by the artist to allow custom ranges.\n    \"\"\"\n\n    label = \"Validate Frame Range\"\n    order = ValidateContentsOrder\n    families = [\"animation\", \"camera\", \"pointcache\", \"render\", \"review\"]\n    hosts = [\"blender\"]\n    optional = True\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate Frame Range...\")\n            return\n\n        frame_range = self.get_expected_frame_range(instance)\n        inst_frame_start = instance.data[\"frameStart\"]\n        inst_frame_end = instance.data[\"frameEnd\"]\n\n        if inst_frame_start is None or inst_frame_end is None:\n            raise KnownPublishError(\n                \"Missing frame start and frame end on \"\n                \"instance to validate.\"\n            )\n        frame_start = frame_range[\"frameStart\"]\n        frame_end = frame_range[\"frameEnd\"]\n        errors = []\n        if frame_start != inst_frame_start:\n            errors.append(\n                f\"Start frame ({inst_frame_start}) on instance does not match \"\n                f\"with the start frame ({frame_start}) set on the task \"\n                \"attributes.\")\n        if frame_end != inst_frame_end:\n            errors.append(\n                f\"End frame ({inst_frame_end}) on instance does not match \"\n                f\"with the end frame ({frame_end}) \"\n                \"from the task attributes.\")\n\n        if errors:\n            bullet_point_errors = \"\\n\".join(\n                \"- {}\".format(error) for error in errors\n            )\n            report = (\n                \"Frame range settings are incorrect.\\n\\n\"\n                f\"{bullet_point_errors}\\n\\n\"\n                \"You can use repair action to fix it.\"\n            )\n            raise PublishValidationError(report, title=\"Frame Range incorrect\")\n\n    @classmethod\n    def get_expected_frame_range(\n        cls, instance: pyblish.api.Instance\n    ) -&gt; Dict[str, int]:\n        \"\"\"Get required frame range\"\"\"\n        entity = instance.data[\"taskEntity\"]\n\n        # Task is not required for a publish instance, so we may need to\n        # validate against the folder entity\n        if not entity:\n            entity = instance.data[\"folderEntity\"]\n        return get_frame_range(entity)\n\n    @classmethod\n    def repair(cls, instance):\n        frame_range = cls.get_expected_frame_range(instance)\n\n        # Update the frame range attributes on the instance\n        create_context = instance.context.data[\"create_context\"]\n        create_instance = create_context.get_instance_by_id(\n            instance.data[\"instance_id\"]\n        )\n\n        creator_attributes = create_instance[\"creator_attributes\"]\n        creator_attributes[\"frameStart\"] = frame_range[\"frameStart\"]\n        creator_attributes[\"frameEnd\"] = frame_range[\"frameEnd\"]\n        create_context.save_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_frame_range.html#client.ayon_blender.plugins.publish.validate_frame_range.ValidateFrameRange.get_expected_frame_range","title":"<code>get_expected_frame_range(instance)</code>  <code>classmethod</code>","text":"<p>Get required frame range</p> Source code in <code>client/ayon_blender/plugins/publish/validate_frame_range.py</code> <pre><code>@classmethod\ndef get_expected_frame_range(\n    cls, instance: pyblish.api.Instance\n) -&gt; Dict[str, int]:\n    \"\"\"Get required frame range\"\"\"\n    entity = instance.data[\"taskEntity\"]\n\n    # Task is not required for a publish instance, so we may need to\n    # validate against the folder entity\n    if not entity:\n        entity = instance.data[\"folderEntity\"]\n    return get_frame_range(entity)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_instance_empty.html","title":"validate_instance_empty","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_instance_empty.html#client.ayon_blender.plugins.publish.validate_instance_empty.ValidateInstanceEmpty","title":"<code>ValidateInstanceEmpty</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Validator to verify that the instance is not empty</p> Source code in <code>client/ayon_blender/plugins/publish/validate_instance_empty.py</code> <pre><code>class ValidateInstanceEmpty(plugin.BlenderInstancePlugin):\n    \"\"\"Validator to verify that the instance is not empty\"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.01\n    hosts = [\"blender\"]\n    families = [\"model\", \"pointcache\", \"rig\", \"camera\" \"layout\", \"blendScene\"]\n    label = \"Validate Instance is not Empty\"\n    optional = False\n\n    def process(self, instance):\n        # Members are collected by `collect_instance` so we only need to check\n        # whether any member is included. The instance node will be included\n        # as a member as well, hence we will check for at least 2 members\n        if len(instance) &lt; 2:\n            raise PublishValidationError(f\"Instance {instance.name} is empty.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_has_uv.html","title":"validate_mesh_has_uv","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_has_uv.html#client.ayon_blender.plugins.publish.validate_mesh_has_uv.ValidateMeshHasUvs","title":"<code>ValidateMeshHasUvs</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the current mesh has UV's.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_mesh_has_uv.py</code> <pre><code>class ValidateMeshHasUvs(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Validate that the current mesh has UV's.\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Mesh Has UVs\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n    optional = True\n\n    @staticmethod\n    def has_uvs(obj: bpy.types.Object) -&gt; bool:\n        \"\"\"Check if an object has uv's.\"\"\"\n        if not obj.data.uv_layers:\n            return False\n        for uv_layer in obj.data.uv_layers:\n            for polygon in obj.data.polygons:\n                for loop_index in polygon.loop_indices:\n                    if (\n                        loop_index &gt;= len(uv_layer.data)\n                        or not uv_layer.data[loop_index].uv\n                    ):\n                        return False\n\n        return True\n\n    @classmethod\n    def get_invalid(cls, instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == 'MESH':\n                if obj.mode != \"OBJECT\":\n                    cls.log.warning(\n                        f\"Mesh object {obj.name} should be in 'OBJECT' mode\"\n                        \" to be properly checked.\"\n                    )\n                if not cls.has_uvs(obj):\n                    invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"Meshes found in instance without valid UV's: {invalid}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_has_uv.html#client.ayon_blender.plugins.publish.validate_mesh_has_uv.ValidateMeshHasUvs.has_uvs","title":"<code>has_uvs(obj)</code>  <code>staticmethod</code>","text":"<p>Check if an object has uv's.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_mesh_has_uv.py</code> <pre><code>@staticmethod\ndef has_uvs(obj: bpy.types.Object) -&gt; bool:\n    \"\"\"Check if an object has uv's.\"\"\"\n    if not obj.data.uv_layers:\n        return False\n    for uv_layer in obj.data.uv_layers:\n        for polygon in obj.data.polygons:\n            for loop_index in polygon.loop_indices:\n                if (\n                    loop_index &gt;= len(uv_layer.data)\n                    or not uv_layer.data[loop_index].uv\n                ):\n                    return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_no_negative_scale.html","title":"validate_mesh_no_negative_scale","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_no_negative_scale.html#client.ayon_blender.plugins.publish.validate_mesh_no_negative_scale.ValidateMeshNoNegativeScale","title":"<code>ValidateMeshNoNegativeScale</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure that meshes don't have a negative scale.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_mesh_no_negative_scale.py</code> <pre><code>class ValidateMeshNoNegativeScale(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Ensure that meshes don't have a negative scale.\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Mesh No Negative Scale\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == 'MESH':\n                if any(v &lt; 0 for v in obj.scale):\n                    invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Meshes found in instance with negative scale: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_model_uv_map1.html","title":"validate_model_uv_map1","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_model_uv_map1.html#client.ayon_blender.plugins.publish.validate_model_uv_map1.ValidateModelMeshUvMap1","title":"<code>ValidateModelMeshUvMap1</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate model mesh uvs are named <code>map1</code>.</p> <p>This is solely to get them to work nicely for the Maya pipeline.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_model_uv_map1.py</code> <pre><code>class ValidateModelMeshUvMap1(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Validate model mesh uvs are named `map1`.\n\n    This is solely to get them to work nicely for the Maya pipeline.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Mesh UVs named map1\"\n    actions = [ayon_blender.api.action.SelectInvalidAction,\n               RepairAction]\n    optional = True\n    enabled = False\n\n    @classmethod\n    def get_invalid(cls, instance) -&gt; List:\n\n        invalid = []\n        for obj in instance:\n            if obj.mode != \"OBJECT\":\n                cls.log.warning(\n                    f\"Mesh object {obj.name} should be in 'OBJECT' mode\"\n                    \" to be properly checked.\"\n                )\n\n            obj_data = obj.data\n            if isinstance(obj_data, bpy.types.Mesh):\n                mesh = obj_data\n\n                # Ignore mesh without UVs\n                if not mesh.uv_layers:\n                    continue\n\n                # If mesh has map1 all is ok\n                if mesh.uv_layers.get(\"map1\"):\n                    continue\n\n                cls.log.warning(\n                    f\"Mesh object {obj.name} should be in 'OBJECT' mode\"\n                    \" to be properly checked.\"\n                )\n                invalid.append(obj)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        for obj in cls.get_invalid(instance):\n            mesh = obj.data\n\n            # Rename the first UV set to map1\n            mesh.uv_layers[0].name = \"map1\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"Meshes found in instance without valid UV's: {invalid}\",\n                description=self.get_description()\n            )\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"## Meshes must have map1 uv set\n\n            To accompany a better Maya-focused pipeline with Alembics it is\n            expected that a Mesh has a `map1` UV set. Blender defaults to\n            a UV set named `UVMap` and thus needs to be renamed.\n\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_colons_in_name.html","title":"validate_no_colons_in_name","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_colons_in_name.html#client.ayon_blender.plugins.publish.validate_no_colons_in_name.ValidateNoColonsInName","title":"<code>ValidateNoColonsInName</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>There cannot be colons in names</p> <p>Object or bone names cannot include colons. Other software do not handle colons correctly.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_no_colons_in_name.py</code> <pre><code>class ValidateNoColonsInName(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"There cannot be colons in names\n\n    Object or bone names cannot include colons. Other software do not\n    handle colons correctly.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\", \"rig\"]\n    label = \"No Colons in names\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if ':' in obj.name:\n                invalid.append(obj)\n            if isinstance(obj, bpy.types.Object) and obj.type == 'ARMATURE':\n                for bone in obj.data.bones:\n                    if ':' in bone.name:\n                        invalid.append(obj)\n                        break\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Objects found with colon in name: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_object_mode.html","title":"validate_object_mode","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_object_mode.html#client.ayon_blender.plugins.publish.validate_object_mode.ValidateObjectIsInObjectMode","title":"<code>ValidateObjectIsInObjectMode</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the objects in the instance are in Object Mode.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_object_mode.py</code> <pre><code>class ValidateObjectIsInObjectMode(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Validate that the objects in the instance are in Object Mode.\"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.01\n    hosts = [\"blender\"]\n    families = [\"model\", \"rig\", \"layout\"]\n    label = \"Validate Object Mode\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n    optional = False\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.mode != \"OBJECT\":\n                invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Object found in instance is not in Object Mode: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_camera_is_set.html","title":"validate_render_camera_is_set","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_camera_is_set.html#client.ayon_blender.plugins.publish.validate_render_camera_is_set.ValidateRenderCameraIsSet","title":"<code>ValidateRenderCameraIsSet</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that there is a camera set as active for rendering.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_camera_is_set.py</code> <pre><code>class ValidateRenderCameraIsSet(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validate that there is a camera set as active for rendering.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"blender\"]\n    families = [\"render\"]\n    label = \"Validate Render Camera Is Set\"\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if not bpy.context.scene.camera:\n            raise PublishValidationError(\"No camera is active for rendering.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_transform_zero.html","title":"validate_transform_zero","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_transform_zero.html#client.ayon_blender.plugins.publish.validate_transform_zero.ValidateTransformZero","title":"<code>ValidateTransformZero</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Transforms can't have any values</p> Source code in <code>client/ayon_blender/plugins/publish/validate_transform_zero.py</code> <pre><code>class ValidateTransformZero(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Transforms can't have any values\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Transform Zero\"\n    actions = [ayon_blender.api.action.SelectInvalidAction,\n               RepairAction]\n\n    _identity = mathutils.Matrix()\n\n    @classmethod\n    def get_invalid(cls, instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if (\n                isinstance(obj, bpy.types.Object)\n                and obj.matrix_basis != cls._identity\n            ):\n                invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                \"Objects found in instance which do not\"\n                f\" have transform set to zero: {names}\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def repair(cls, instance):\n\n        invalid = cls.get_invalid(instance)\n        if not invalid:\n            return\n\n        context = plugin.create_blender_context(\n            active=invalid[0], selected=invalid\n        )\n        with lib.maintained_selection():\n            with bpy.context.temp_override(**context):\n                plugin.deselect_all()\n                for obj in invalid:\n                    obj.select_set(True)\n\n                # TODO: Preferably this does allow custom pivot point locations\n                #  and if so, this should likely apply to the delta instead\n                #  using `bpy.ops.object.transforms_to_deltas(mode=\"ALL\")`\n                bpy.ops.object.transform_apply(location=True,\n                                               rotation=True,\n                                               scale=True)\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"## Transforms can't have any values.\n\n            The location, rotation and scale on the transform must be at\n            the default values. This also goes for the delta transforms.\n\n            To solve this issue, try freezing the transforms:\n            - `Object` &gt; `Apply` &gt; `All Transforms`\n\n            Using the Repair action directly will do the same.\n\n            So long as the transforms, rotation and scale values are zero,\n            you're all good.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/render_settings.html","title":"render_settings","text":"<p>Providing models and values for Blender Render Settings.</p>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.CustomPassesModel","title":"<code>CustomPassesModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Custom Passes</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>class CustomPassesModel(BaseSettingsModel):\n    \"\"\"Custom Passes\"\"\"\n    _layout = \"compact\"\n\n    attribute: str = SettingsField(\"\", title=\"Attribute name\")\n    value: str = SettingsField(\n        \"COLOR\",\n        title=\"Type\",\n        enum_resolver=custom_passes_types_enum\n    )\n</code></pre>"}]}