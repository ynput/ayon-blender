{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Blender addon","text":"<p>Blender integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_blender<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>capture</li> <li>colorspace</li> <li>constants</li> <li>lib</li> <li>ops</li> <li>pipeline</li> <li>plugin</li> <li>plugin_load</li> <li>render_lib</li> <li>workio</li> </ul> </li> <li>blender_addon<ul> <li>startup<ul> <li>init</li> </ul> </li> </ul> </li> <li>hooks<ul> <li>pre_add_run_python_script_arg</li> <li>pre_pyside_install</li> <li>pre_windows_console</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>convert_legacy</li> <li>create_action</li> <li>create_animation</li> <li>create_blendScene</li> <li>create_camera</li> <li>create_layout</li> <li>create_model</li> <li>create_pointcache</li> <li>create_render</li> <li>create_review</li> <li>create_rig</li> <li>create_usd</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>import_workfile</li> <li>load_action</li> <li>load_audio</li> <li>load_blend</li> <li>load_blend_link</li> <li>load_blendscene</li> <li>load_cache</li> <li>load_camera_abc</li> <li>load_camera_fbx</li> <li>load_fbx</li> <li>load_image_compositor</li> <li>load_image_shader</li> <li>load_layout_json</li> <li>load_look</li> </ul> </li> <li>publish<ul> <li>collect_current_file</li> <li>collect_file_dependencies</li> <li>collect_instance</li> <li>collect_instance_frame_range</li> <li>collect_local_render_instances</li> <li>collect_render</li> <li>collect_review</li> <li>collect_workfile</li> <li>extract_abc</li> <li>extract_abc_animation</li> <li>extract_blend</li> <li>extract_blend_animation</li> <li>extract_camera_abc</li> <li>extract_camera_fbx</li> <li>extract_fbx</li> <li>extract_fbx_animation</li> <li>extract_layout</li> <li>extract_playblast</li> <li>extract_render</li> <li>extract_thumbnail</li> <li>extract_usd</li> <li>increment_workfile_version</li> <li>integrate_animation</li> <li>save_scene</li> <li>validate_absolute_external_data_paths</li> <li>validate_camera_zero_keyframe</li> <li>validate_file_saved</li> <li>validate_frame_range</li> <li>validate_instance_empty</li> <li>validate_mesh_has_uv</li> <li>validate_mesh_no_negative_scale</li> <li>validate_model_uv_map1</li> <li>validate_no_action</li> <li>validate_no_animation</li> <li>validate_no_colons_in_name</li> <li>validate_object_mode</li> <li>validate_render_camera_is_set</li> <li>validate_render_existing_frames</li> <li>validate_render_inputs</li> <li>validate_render_output_paths</li> <li>validate_transform_zero</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>creators</li> <li>imageio</li> <li>loaders</li> <li>main</li> <li>publish_plugins</li> <li>render_settings</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_blender/index.html","title":"ayon_blender","text":""},{"location":"autoapi/client/ayon_blender/index.html#client.ayon_blender.BlenderAddon","title":"<code>BlenderAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>class BlenderAddon(AYONAddon, IHostAddon):\n    name = \"blender\"\n    version = __version__\n    host_name = \"blender\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        # Prepare path to implementation script\n        implementation_script_path = os.path.join(\n            BLENDER_ADDON_ROOT,\n            \"blender_addon\"\n        )\n\n        # Add blender implementation script path to PYTHONPATH\n        python_path = env.get(\"PYTHONPATH\") or \"\"\n        python_path_parts = [\n            path\n            for path in python_path.split(os.pathsep)\n            if path\n        ]\n        python_path_parts.insert(0, implementation_script_path)\n        env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n        # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n        # to initialize the Blender startup environment, otherwise use the\n        # `BLENDER_USER_PATH`.\n        # The launch env is not applied yet, so we pass the env value\n        # from the launch environment\n        use_system_path = env_value_to_bool(\n            value=env.get(\"AYON_BLENDER_USE_SYSTEM_PATH\"),\n        )\n        if use_system_path:\n            self._configure_blender_system_paths(\n                env, implementation_script_path\n            )\n        else:\n            # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n            # nor supported multiple paths for it. See:\n            # https://projects.blender.org/blender/blender/issues/127013\n            self._configure_blender_user_paths(env, implementation_script_path)\n\n        # Define Qt binding if not defined\n        env.pop(\"QT_PREFERRED_BINDING\", None)\n\n    def _configure_blender_user_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_USER_SCRIPTS to configure AYON startup\"\"\"\n        previous_user_scripts = set()\n        # Implementation path is added to set for easier paths check inside\n        #   loops - will be removed at the end\n        previous_user_scripts.add(implementation_script_path)\n\n        ayon_blender_user_scripts = env.get(\"AYON_BLENDER_USER_SCRIPTS\") or \"\"\n        for path in ayon_blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        blender_user_scripts = env.get(\"BLENDER_USER_SCRIPTS\") or \"\"\n        for path in blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        # Remove implementation path from user script paths as is set to\n        #   `BLENDER_USER_SCRIPTS`\n        previous_user_scripts.remove(implementation_script_path)\n        env[\"BLENDER_USER_SCRIPTS\"] = implementation_script_path\n\n        # Set custom user scripts env\n        env[\"AYON_BLENDER_USER_SCRIPTS\"] = os.pathsep.join(\n            previous_user_scripts\n        )\n\n    def _configure_blender_system_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_SYSTEM_SCRIPTS to configure AYON startup.\n\n        This would only work with Blender 4.4+ due to new changes implemented\n        to `BLENDER_SYSTEM_SCRIPTS` functionality starting with that release.\n        \"\"\"\n        paths = [implementation_script_path]\n\n        # Support older AYON_BLENDER_USER_SCRIPTS for compatibility\n        if env.get(\"AYON_BLENDER_USER_SCRIPTS\"):\n            # Note that we `pop` the AYON_BLENDER_USER_SCRIPTS to avoid\n            # the legacy post-Blender launch logic script to trigger which\n            # is incompatible with Blender 4.4+\n            paths.append(env.pop(\"AYON_BLENDER_USER_SCRIPTS\"))\n\n        # Preserve existing BLENDER_SYSTEM_SCRIPTS, append them at the end\n        if env.get(\"BLENDER_SYSTEM_SCRIPTS\"):\n            paths.append(env.get(\"BLENDER_SYSTEM_SCRIPTS\"))\n\n        # Set custom user scripts env\n        env[\"BLENDER_SYSTEM_SCRIPTS\"] = os.pathsep.join(paths)\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(BLENDER_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/index.html#client.ayon_blender.BlenderAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    # Prepare path to implementation script\n    implementation_script_path = os.path.join(\n        BLENDER_ADDON_ROOT,\n        \"blender_addon\"\n    )\n\n    # Add blender implementation script path to PYTHONPATH\n    python_path = env.get(\"PYTHONPATH\") or \"\"\n    python_path_parts = [\n        path\n        for path in python_path.split(os.pathsep)\n        if path\n    ]\n    python_path_parts.insert(0, implementation_script_path)\n    env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n    # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n    # to initialize the Blender startup environment, otherwise use the\n    # `BLENDER_USER_PATH`.\n    # The launch env is not applied yet, so we pass the env value\n    # from the launch environment\n    use_system_path = env_value_to_bool(\n        value=env.get(\"AYON_BLENDER_USE_SYSTEM_PATH\"),\n    )\n    if use_system_path:\n        self._configure_blender_system_paths(\n            env, implementation_script_path\n        )\n    else:\n        # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n        # nor supported multiple paths for it. See:\n        # https://projects.blender.org/blender/blender/issues/127013\n        self._configure_blender_user_paths(env, implementation_script_path)\n\n    # Define Qt binding if not defined\n    env.pop(\"QT_PREFERRED_BINDING\", None)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_blender/addon.html#client.ayon_blender.addon.BlenderAddon","title":"<code>BlenderAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>class BlenderAddon(AYONAddon, IHostAddon):\n    name = \"blender\"\n    version = __version__\n    host_name = \"blender\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        # Prepare path to implementation script\n        implementation_script_path = os.path.join(\n            BLENDER_ADDON_ROOT,\n            \"blender_addon\"\n        )\n\n        # Add blender implementation script path to PYTHONPATH\n        python_path = env.get(\"PYTHONPATH\") or \"\"\n        python_path_parts = [\n            path\n            for path in python_path.split(os.pathsep)\n            if path\n        ]\n        python_path_parts.insert(0, implementation_script_path)\n        env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n        # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n        # to initialize the Blender startup environment, otherwise use the\n        # `BLENDER_USER_PATH`.\n        # The launch env is not applied yet, so we pass the env value\n        # from the launch environment\n        use_system_path = env_value_to_bool(\n            value=env.get(\"AYON_BLENDER_USE_SYSTEM_PATH\"),\n        )\n        if use_system_path:\n            self._configure_blender_system_paths(\n                env, implementation_script_path\n            )\n        else:\n            # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n            # nor supported multiple paths for it. See:\n            # https://projects.blender.org/blender/blender/issues/127013\n            self._configure_blender_user_paths(env, implementation_script_path)\n\n        # Define Qt binding if not defined\n        env.pop(\"QT_PREFERRED_BINDING\", None)\n\n    def _configure_blender_user_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_USER_SCRIPTS to configure AYON startup\"\"\"\n        previous_user_scripts = set()\n        # Implementation path is added to set for easier paths check inside\n        #   loops - will be removed at the end\n        previous_user_scripts.add(implementation_script_path)\n\n        ayon_blender_user_scripts = env.get(\"AYON_BLENDER_USER_SCRIPTS\") or \"\"\n        for path in ayon_blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        blender_user_scripts = env.get(\"BLENDER_USER_SCRIPTS\") or \"\"\n        for path in blender_user_scripts.split(os.pathsep):\n            if path:\n                previous_user_scripts.add(os.path.normpath(path))\n\n        # Remove implementation path from user script paths as is set to\n        #   `BLENDER_USER_SCRIPTS`\n        previous_user_scripts.remove(implementation_script_path)\n        env[\"BLENDER_USER_SCRIPTS\"] = implementation_script_path\n\n        # Set custom user scripts env\n        env[\"AYON_BLENDER_USER_SCRIPTS\"] = os.pathsep.join(\n            previous_user_scripts\n        )\n\n    def _configure_blender_system_paths(\n        self, env: dict, implementation_script_path: str\n    ):\n        \"\"\"Modify BLENDER_SYSTEM_SCRIPTS to configure AYON startup.\n\n        This would only work with Blender 4.4+ due to new changes implemented\n        to `BLENDER_SYSTEM_SCRIPTS` functionality starting with that release.\n        \"\"\"\n        paths = [implementation_script_path]\n\n        # Support older AYON_BLENDER_USER_SCRIPTS for compatibility\n        if env.get(\"AYON_BLENDER_USER_SCRIPTS\"):\n            # Note that we `pop` the AYON_BLENDER_USER_SCRIPTS to avoid\n            # the legacy post-Blender launch logic script to trigger which\n            # is incompatible with Blender 4.4+\n            paths.append(env.pop(\"AYON_BLENDER_USER_SCRIPTS\"))\n\n        # Preserve existing BLENDER_SYSTEM_SCRIPTS, append them at the end\n        if env.get(\"BLENDER_SYSTEM_SCRIPTS\"):\n            paths.append(env.get(\"BLENDER_SYSTEM_SCRIPTS\"))\n\n        # Set custom user scripts env\n        env[\"BLENDER_SYSTEM_SCRIPTS\"] = os.pathsep.join(paths)\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(BLENDER_ADDON_ROOT, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/addon.html#client.ayon_blender.addon.BlenderAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_blender/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    # Prepare path to implementation script\n    implementation_script_path = os.path.join(\n        BLENDER_ADDON_ROOT,\n        \"blender_addon\"\n    )\n\n    # Add blender implementation script path to PYTHONPATH\n    python_path = env.get(\"PYTHONPATH\") or \"\"\n    python_path_parts = [\n        path\n        for path in python_path.split(os.pathsep)\n        if path\n    ]\n    python_path_parts.insert(0, implementation_script_path)\n    env[\"PYTHONPATH\"] = os.pathsep.join(python_path_parts)\n\n    # If `AYON_BLENDER_USE_SYSTEM_PATH` is set use `BLENDER_SYSTEM_PATH`\n    # to initialize the Blender startup environment, otherwise use the\n    # `BLENDER_USER_PATH`.\n    # The launch env is not applied yet, so we pass the env value\n    # from the launch environment\n    use_system_path = env_value_to_bool(\n        value=env.get(\"AYON_BLENDER_USE_SYSTEM_PATH\"),\n    )\n    if use_system_path:\n        self._configure_blender_system_paths(\n            env, implementation_script_path\n        )\n    else:\n        # Old versions of Blender had broken BLENDER_SYSTEM_SCRIPTS\n        # nor supported multiple paths for it. See:\n        # https://projects.blender.org/blender/blender/issues/127013\n        self._configure_blender_user_paths(env, implementation_script_path)\n\n    # Define Qt binding if not defined\n    env.pop(\"QT_PREFERRED_BINDING\", None)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/version.html","title":"version","text":"<p>Package declaring AYON addon 'blender' version.</p>"},{"location":"autoapi/client/ayon_blender/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost","title":"<code>BlenderHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>IPublishHost</code>, <code>ILoadHost</code></p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>class BlenderHost(HostBase, IWorkfileHost, IPublishHost, ILoadHost):\n    name = \"blender\"\n\n    def get_app_information(self):\n        from ayon_core.host import ApplicationInformation\n\n        return ApplicationInformation(\n            app_name=\"Blender\",\n            app_version=bpy.app.version_string,\n        )\n\n    def install(self):\n        \"\"\"Override install method from HostBase.\n        Install Blender host functionality.\"\"\"\n        install()\n\n    def get_containers(self) -&gt; Iterator:\n        \"\"\"List containers from active Blender scene.\"\"\"\n        return ls()\n\n    def get_workfile_extensions(self) -&gt; List[str]:\n        \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n        Get workfile possible extensions.\n\n        Returns:\n            List[str]: Workfile extensions.\n        \"\"\"\n        return file_extensions()\n\n    def save_workfile(self, dst_path: str = None):\n        \"\"\"Override save_workfile method from IWorkfileHost.\n        Save currently opened workfile.\n\n        Args:\n            dst_path (str): Where the current scene should be saved. Or use\n                current path if `None` is passed.\n        \"\"\"\n        save_file(dst_path if dst_path else bpy.data.filepath)\n\n    def open_workfile(self, filepath: str):\n        \"\"\"Override open_workfile method from IWorkfileHost.\n        Open workfile at specified filepath in the host.\n\n        Args:\n            filepath (str): Path to workfile.\n        \"\"\"\n        open_file(filepath)\n\n    def get_current_workfile(self) -&gt; str:\n        \"\"\"Override get_current_workfile method from IWorkfileHost.\n        Retrieve currently opened workfile path.\n\n        Returns:\n            str: Path to currently opened workfile.\n        \"\"\"\n        return current_file()\n\n    def workfile_has_unsaved_changes(self) -&gt; bool:\n        \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n        Returns True if opened workfile has no unsaved changes.\n\n        Returns:\n            bool: True if scene is saved and False if it has unsaved\n                modifications.\n        \"\"\"\n        return has_unsaved_changes()\n\n    def work_root(self, session) -&gt; str:\n        \"\"\"Override work_root method from IWorkfileHost.\n        Modify workdir per host.\n\n        Args:\n            session (dict): Session context data.\n\n        Returns:\n            str: Path to new workdir.\n        \"\"\"\n        return work_root(session)\n\n    def get_context_data(self) -&gt; dict:\n        \"\"\"Override abstract method from IPublishHost.\n        Get global data related to creation-publishing from workfile.\n\n        Returns:\n            dict: Context data stored using 'update_context_data'.\n        \"\"\"\n        property = bpy.context.scene.get(AYON_PROPERTY)\n        if property:\n            return property.to_dict()\n        return {}\n\n    def update_context_data(self, data: dict, changes: dict):\n        \"\"\"Override abstract method from IPublishHost.\n        Store global context data to workfile.\n\n        Args:\n            data (dict): New data as are.\n            changes (dict): Only data that has been changed. Each value has\n                tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n        \"\"\"\n        bpy.context.scene[AYON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_containers","title":"<code>get_containers()</code>","text":"<p>List containers from active Blender scene.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_containers(self) -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\"\"\"\n    return ls()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Override abstract method from IPublishHost. Get global data related to creation-publishing from workfile.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data stored using 'update_context_data'.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_context_data(self) -&gt; dict:\n    \"\"\"Override abstract method from IPublishHost.\n    Get global data related to creation-publishing from workfile.\n\n    Returns:\n        dict: Context data stored using 'update_context_data'.\n    \"\"\"\n    property = bpy.context.scene.get(AYON_PROPERTY)\n    if property:\n        return property.to_dict()\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_current_workfile","title":"<code>get_current_workfile()</code>","text":"<p>Override get_current_workfile method from IWorkfileHost. Retrieve currently opened workfile path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to currently opened workfile.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_current_workfile(self) -&gt; str:\n    \"\"\"Override get_current_workfile method from IWorkfileHost.\n    Retrieve currently opened workfile path.\n\n    Returns:\n        str: Path to currently opened workfile.\n    \"\"\"\n    return current_file()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Override get_workfile_extensions method from IWorkfileHost. Get workfile possible extensions.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Workfile extensions.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_workfile_extensions(self) -&gt; List[str]:\n    \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n    Get workfile possible extensions.\n\n    Returns:\n        List[str]: Workfile extensions.\n    \"\"\"\n    return file_extensions()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.install","title":"<code>install()</code>","text":"<p>Override install method from HostBase. Install Blender host functionality.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Override install method from HostBase.\n    Install Blender host functionality.\"\"\"\n    install()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.open_workfile","title":"<code>open_workfile(filepath)</code>","text":"<p>Override open_workfile method from IWorkfileHost. Open workfile at specified filepath in the host.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to workfile.</p> required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def open_workfile(self, filepath: str):\n    \"\"\"Override open_workfile method from IWorkfileHost.\n    Open workfile at specified filepath in the host.\n\n    Args:\n        filepath (str): Path to workfile.\n    \"\"\"\n    open_file(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.save_workfile","title":"<code>save_workfile(dst_path=None)</code>","text":"<p>Override save_workfile method from IWorkfileHost. Save currently opened workfile.</p> <p>Parameters:</p> Name Type Description Default <code>dst_path</code> <code>str</code> <p>Where the current scene should be saved. Or use current path if <code>None</code> is passed.</p> <code>None</code> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def save_workfile(self, dst_path: str = None):\n    \"\"\"Override save_workfile method from IWorkfileHost.\n    Save currently opened workfile.\n\n    Args:\n        dst_path (str): Where the current scene should be saved. Or use\n            current path if `None` is passed.\n    \"\"\"\n    save_file(dst_path if dst_path else bpy.data.filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Override abstract method from IPublishHost. Store global context data to workfile.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>New data as are.</p> required <code>changes</code> <code>dict</code> <p>Only data that has been changed. Each value has tuple with '(, )' value. required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def update_context_data(self, data: dict, changes: dict):\n    \"\"\"Override abstract method from IPublishHost.\n    Store global context data to workfile.\n\n    Args:\n        data (dict): New data as are.\n        changes (dict): Only data that has been changed. Each value has\n            tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n    \"\"\"\n    bpy.context.scene[AYON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.work_root","title":"<code>work_root(session)</code>","text":"<p>Override work_root method from IWorkfileHost. Modify workdir per host.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict</code> <p>Session context data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to new workdir.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def work_root(self, session) -&gt; str:\n    \"\"\"Override work_root method from IWorkfileHost.\n    Modify workdir per host.\n\n    Args:\n        session (dict): Session context data.\n\n    Returns:\n        str: Path to new workdir.\n    \"\"\"\n    return work_root(session)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.BlenderHost.workfile_has_unsaved_changes","title":"<code>workfile_has_unsaved_changes()</code>","text":"<p>Override wokfile_has_unsaved_changes method from IWorkfileHost. Returns True if opened workfile has no unsaved changes.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if scene is saved and False if it has unsaved modifications.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def workfile_has_unsaved_changes(self) -&gt; bool:\n    \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n    Returns True if opened workfile has no unsaved changes.\n\n    Returns:\n        bool: True if scene is saved and False if it has unsaved\n            modifications.\n    \"\"\"\n    return has_unsaved_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='CON')</code>","text":"<p>Bundle <code>nodes</code> into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>List</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>Dict</code> <p>Asset information</p> required <code>loader</code> <code>Optional[str]</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Type Description <code>Collection</code> <p>The container assembly</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def containerise(name: str,\n                 namespace: str,\n                 nodes: List,\n                 context: Dict,\n                 loader: Optional[str] = None,\n                 suffix: Optional[str] = \"CON\") -&gt; bpy.types.Collection:\n    \"\"\"Bundle `nodes` into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name: Name of resulting assembly\n        namespace: Namespace under which to host container\n        nodes: Long names of nodes to containerise\n        context: Asset information\n        loader: Name of loader used to produce this container.\n        suffix: Suffix of container, defaults to `_CON`.\n\n    Returns:\n        The container assembly\n\n    \"\"\"\n\n    node_name = get_container_name(name, namespace, context, suffix)\n    container = bpy.data.collections.new(name=node_name)\n    # Link the children nodes\n    for obj in nodes:\n        if isinstance(obj, bpy.types.Object):\n            container.objects.link(obj)\n        elif isinstance(obj, bpy.types.Collection):\n            container.children.link(obj)\n        else:\n            raise TypeError(f\"Unsupported type {type(obj)} in nodes list.\")\n\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    metadata_update(container, data)\n    add_to_ayon_container(container)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.current_file","title":"<code>current_file()</code>","text":"<p>Return the path of the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def current_file() -&gt; Optional[str]:\n    \"\"\"Return the path of the open scene file.\"\"\"\n\n    current_filepath = bpy.data.filepath\n    if Path(current_filepath).is_file():\n        return current_filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.file_extensions","title":"<code>file_extensions()</code>","text":"<p>Return the supported file extensions for Blender scene files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def file_extensions() -&gt; List[str]:\n    \"\"\"Return the supported file extensions for Blender scene files.\"\"\"\n\n    return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.get_selection","title":"<code>get_selection(include_collections=False)</code>","text":"<p>Returns a list of selected objects in the current Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>include_collections</code> <code>bool</code> <p>Whether to include selected</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Object]</code> <p>List[bpy.types.Object]: A list of selected objects.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_selection(include_collections: bool = False) -&gt; List[bpy.types.Object]:\n    \"\"\"\n    Returns a list of selected objects in the current Blender scene.\n\n    Args:\n        include_collections (bool, optional): Whether to include selected\n        collections in the result. Defaults to False.\n\n    Returns:\n        List[bpy.types.Object]: A list of selected objects.\n    \"\"\"\n    selection = [obj for obj in bpy.context.scene.objects if obj.select_get()]\n\n    if include_collections:\n        selection.extend(get_selected_collections())\n\n    return selection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.has_unsaved_changes","title":"<code>has_unsaved_changes()</code>","text":"<p>Does the open scene file have unsaved changes?</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def has_unsaved_changes() -&gt; bool:\n    \"\"\"Does the open scene file have unsaved changes?\"\"\"\n\n    return bpy.data.is_dirty\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.install","title":"<code>install()</code>","text":"<p>Install Blender configuration for AYON.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install():\n    \"\"\"Install Blender configuration for AYON.\"\"\"\n    sys.excepthook = pype_excepthook_handler\n\n    pyblish.api.register_host(\"blender\")\n    pyblish.api.register_plugin_path(str(PUBLISH_PATH))\n\n    register_loader_plugin_path(str(LOAD_PATH))\n    register_creator_plugin_path(str(CREATE_PATH))\n\n    if lib.get_blender_version() &lt; (5, 0, 0):\n        # User script directories had issues in custom management in older\n        # Blender releases - appending user scripts within AYON was a\n        # workaround only in-place to solve that issue.\n        lib.append_user_scripts()\n    lib.set_app_templates_path()\n\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"open\", on_open)\n    register_event_callback(\"before.save\", on_before_save)\n\n    _register_callbacks()\n\n    if not IS_HEADLESS:\n        ops.register()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.ls","title":"<code>ls()</code>","text":"<p>List containers from active Blender scene.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Blender; once loaded they are called containers.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def ls() -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\n\n    This is the host-equivalent of api.ls(), but instead of listing assets on\n    disk, it lists assets already loaded in Blender; once loaded they are\n    called containers.\n    \"\"\"\n    container_ids = {\n        AYON_CONTAINER_ID,\n        # Backwards compatibility\n        AVALON_CONTAINER_ID\n    }\n\n    for id_type in container_ids:\n        for container in lib.lsattr(\"id\", id_type):\n            yield parse_container(container)\n\n    # Compositor nodes are not in `bpy.data` that `lib.lsattr` looks in.\n    node_tree = lib.get_scene_node_tree()\n    if node_tree:\n        for node in node_tree.nodes:\n            ayon_prop = node.get(AYON_PROPERTY)\n            if not ayon_prop:\n                avalon_prop = node.get(AVALON_PROPERTY)\n                if not avalon_prop:\n                    continue\n                else:\n                    node[AYON_PROPERTY] = avalon_prop\n                    ayon_prop = avalon_prop\n                    del node[AVALON_PROPERTY]\n\n            if ayon_prop.get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(node)\n\n    # Shader nodes are not available in a way that `lib.lsattr` can find.\n    for material in bpy.data.materials:\n        material_node_tree = material.node_tree\n        if not material_node_tree:\n            continue\n\n        for shader_node in material_node_tree.nodes:\n            ayon_shader_node = get_ayon_property(shader_node)\n            if not ayon_shader_node:\n                continue\n\n            if ayon_shader_node.get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(shader_node)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.lsattr","title":"<code>lsattr(attr, value=None)</code>","text":"<p>Return nodes matching <code>attr</code> and <code>value</code></p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Name of Blender property</p> required <code>value</code> <code>Union[str, int, bool, List, Dict, None]</code> <p>Value of attribute. If none is provided, return all nodes with this attribute.</p> <code>None</code> Example <p>lsattr(\"id\", \"myId\") ...   [bpy.data.objects[\"myNode\"] lsattr(\"id\") ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]</p> <p>Returns:</p> Type Description <code>List</code> <p>list</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattr(attr: str,\n           value: Union[str, int, bool, List, Dict, None] = None) -&gt; List:\n    r\"\"\"Return nodes matching `attr` and `value`\n\n    Arguments:\n        attr: Name of Blender property\n        value: Value of attribute. If none\n            is provided, return all nodes with this attribute.\n\n    Example:\n        &gt;&gt;&gt; lsattr(\"id\", \"myId\")\n        ...   [bpy.data.objects[\"myNode\"]\n        &gt;&gt;&gt; lsattr(\"id\")\n        ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]\n\n    Returns:\n        list\n    \"\"\"\n\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.lsattrs","title":"<code>lsattrs(attrs)</code>","text":"<p>Return nodes with the given attribute(s).</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict</code> <p>Name and value pairs of expected matches</p> required Example <p>lsattrs({\"age\": 5})  # Return nodes with an <code>age</code> of 5</p> <p>Returns a list.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattrs(attrs: Dict) -&gt; List:\n    r\"\"\"Return nodes with the given attribute(s).\n\n    Arguments:\n        attrs: Name and value pairs of expected matches\n\n    Example:\n        &gt;&gt;&gt; lsattrs({\"age\": 5})  # Return nodes with an `age` of 5\n        # Return nodes with both `age` and `color` of 5 and blue\n        &gt;&gt;&gt; lsattrs({\"age\": 5, \"color\": \"blue\"})\n\n    Returns a list.\n\n    \"\"\"\n\n    # For now return all objects, not filtered by scene/collection/view_layer.\n    matches = set()\n    for coll in dir(bpy.data):\n        if not isinstance(\n                getattr(bpy.data, coll),\n                bpy.types.bpy_prop_collection,\n        ):\n            continue\n        for node in getattr(bpy.data, coll):\n            ayon_prop = pipeline.get_ayon_property(node)\n            if not ayon_prop:\n                continue\n\n            for attr, value in attrs.items():\n                if (ayon_prop.get(attr)\n                        and (value is None or ayon_prop.get(attr) == value)):\n                    matches.add(node)\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.lsattrs--return-nodes-with-both-age-and-color-of-5-and-blue","title":"Return nodes with both <code>age</code> and <code>color</code> of 5 and blue","text":"<p>lsattrs({\"age\": 5, \"color\": \"blue\"})</p>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     # Modify selection ...     bpy.ops.object.select_all(action='DESELECT')</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    r\"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     # Modify selection\n        ...     bpy.ops.object.select_all(action='DESELECT')\n        &gt;&gt;&gt; # Selection restored\n    \"\"\"\n\n    previous_selection = get_selection()\n    previous_active = bpy.context.view_layer.objects.active\n    try:\n        yield\n    finally:\n        # Clear the selection\n        for node in get_selection():\n            node.select_set(state=False)\n        if previous_selection:\n            for node in previous_selection:\n                try:\n                    node.select_set(state=True)\n                except ReferenceError:\n                    # This could happen if a selected node was deleted during\n                    # the context.\n                    log.exception(\"Failed to reselect\")\n                    continue\n        try:\n            bpy.context.view_layer.objects.active = previous_active\n        except ReferenceError:\n            # This could happen if the active node was deleted during the\n            # context.\n            log.exception(\"Failed to set active object.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.maintained_selection--selection-restored","title":"Selection restored","text":""},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.maintained_time","title":"<code>maintained_time()</code>","text":"<p>Maintain current frame during context.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_time():\n    \"\"\"Maintain current frame during context.\"\"\"\n    current_time = bpy.context.scene.frame_current\n    try:\n        yield\n    finally:\n        bpy.context.scene.frame_current = current_time\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Open the scene file in Blender.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def open_file(filepath: str) -&gt; Optional[str]:\n    \"\"\"Open the scene file in Blender.\"\"\"\n    OpenFileCacher.set_opening()\n\n    preferences = bpy.context.preferences\n    load_ui = preferences.filepaths.use_load_ui\n    use_scripts = preferences.filepaths.use_scripts_auto_execute\n    result = bpy.ops.wm.open_mainfile(\n        filepath=filepath,\n        load_ui=load_ui,\n        use_scripts=use_scripts,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.prepare_rendering","title":"<code>prepare_rendering(variant_name, project_settings=None)</code>","text":"<p>Initialize render setup using render settings from project settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def prepare_rendering(\n    variant_name: str, project_settings: Optional[dict] = None\n) -&gt; \"bpy.types.CompositorNodeOutputFile\":\n    \"\"\"Initialize render setup using render settings from project settings.\"\"\"\n    assert bpy.data.filepath, \"Workfile not saved. Please save the file first.\"\n\n    if project_settings is None:\n        project_name: str = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n\n    ext = get_image_format(project_settings)\n    multilayer = get_multilayer(project_settings)\n    renderer = get_renderer(project_settings)\n    ver_major, ver_minor, _ = lib.get_blender_version()\n    if renderer == \"BLENDER_EEVEE\" and (\n        ver_major &gt;= 4 and ver_minor &gt;=2\n    ):\n        renderer = \"BLENDER_EEVEE_NEXT\"\n\n    # Set scene render settings\n    set_render_format(ext, multilayer)\n    bpy.context.scene.render.engine = renderer\n    view_layers = bpy.context.scene.view_layers\n    set_render_passes(project_settings, renderer, view_layers)\n\n    # Use selected renderlayer nodes, or assume we want a renderlayer node for\n    # each view layer so we retrieve all of them.\n    node_tree = lib.get_scene_node_tree(ensure_exists=True)\n    selected_renderlayer_nodes = []\n\n    # Check if node_tree is available before accessing nodes\n    if node_tree is not None:\n        for node in node_tree.nodes:\n            if node.bl_idname == \"CompositorNodeRLayers\" and node.select:\n                selected_renderlayer_nodes.append(node)\n\n    if selected_renderlayer_nodes:\n        render_layer_nodes = selected_renderlayer_nodes\n    else:\n        render_layer_nodes = get_or_create_render_layer_nodes(view_layers)\n\n    # Generate Compositing nodes\n    output_node = create_render_node_tree(\n        variant_name,\n        render_layer_nodes,\n        project_settings\n    )\n\n    set_tmp_scene_render_output_path(project_settings)\n    bpy.context.scene.render.use_overwrite = True\n\n    return output_node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.publish","title":"<code>publish()</code>","text":"<p>Shorthand to publish from within host.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def publish():\n    \"\"\"Shorthand to publish from within host.\"\"\"\n\n    return pyblish.util.publish()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.read","title":"<code>read(node)</code>","text":"<p>Return user-defined attributes from <code>node</code></p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def read(node: bpy.types.bpy_struct_meta_idprop):\n    \"\"\"Return user-defined attributes from `node`\"\"\"\n\n    data = dict(node.get(AYON_PROPERTY, {}))\n\n    # Ignore hidden/internal data\n    data = {\n        key: value\n        for key, value in data.items() if not key.startswith(\"_\")\n    }\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.save_file","title":"<code>save_file(filepath, copy=False)</code>","text":"<p>Save the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def save_file(filepath: str, copy: bool = False) -&gt; Optional[str]:\n    \"\"\"Save the open scene file.\"\"\"\n\n    preferences = bpy.context.preferences\n    compress = preferences.filepaths.use_file_compression\n    relative_remap = preferences.filepaths.use_relative_paths\n    result = bpy.ops.wm.save_as_mainfile(\n        filepath=filepath,\n        compress=compress,\n        relative_remap=relative_remap,\n        copy=copy,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall Blender configuration for AYON.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def uninstall():\n    \"\"\"Uninstall Blender configuration for AYON.\"\"\"\n    sys.excepthook = ORIGINAL_EXCEPTHOOK\n\n    pyblish.api.deregister_host(\"blender\")\n    pyblish.api.deregister_plugin_path(str(PUBLISH_PATH))\n\n    deregister_loader_plugin_path(str(LOAD_PATH))\n    deregister_creator_plugin_path(str(CREATE_PATH))\n\n    if not IS_HEADLESS:\n        ops.unregister()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/index.html#client.ayon_blender.api.work_root","title":"<code>work_root(session)</code>","text":"<p>Return the default root to browse for work files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def work_root(session: dict) -&gt; str:\n    \"\"\"Return the default root to browse for work files.\"\"\"\n\n    work_dir = session[\"AYON_WORKDIR\"]\n    scene_dir = session.get(\"AVALON_SCENEDIR\")\n    if scene_dir:\n        return str(Path(work_dir, scene_dir))\n    return work_dir\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_blender/api/action.html#client.ayon_blender.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid objects in Blender when a publish plug-in failed.</p> Source code in <code>client/ayon_blender/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid objects in Blender when a publish plug-in failed.\"\"\"\n    label = \"Select Invalid\"\n    on = \"failed\"\n    icon = \"search\"\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(context,\n                                                               plugin=plugin)\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes...\")\n        invalid = list()\n        for instance in errored_instances:\n            invalid_nodes = plugin.get_invalid(instance)\n            if invalid_nodes:\n                if isinstance(invalid_nodes, (list, tuple)):\n                    invalid.extend(invalid_nodes)\n                else:\n                    self.log.warning(\n                        \"Failed plug-in doesn't have any selectable objects.\"\n                    )\n\n        bpy.ops.object.select_all(action='DESELECT')\n\n        # Make sure every node is only processed once\n        invalid = list(set(invalid))\n        if not invalid:\n            self.log.info(\"No invalid nodes found.\")\n            return\n\n        invalid_names = [obj.name for obj in invalid]\n        self.log.info(\n            \"Selecting invalid objects: %s\", \", \".join(invalid_names)\n        )\n        # Select the objects and also make the last one the active object.\n        for obj in invalid:\n            obj.select_set(True)\n\n        bpy.context.view_layer.objects.active = invalid[-1]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html","title":"capture","text":"<p>Blender Capture Playblasting with independent viewport, camera and display options</p>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_frame_range","title":"<code>applied_frame_range(window, start, end, step)</code>","text":"<p>Context manager for setting frame range.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef applied_frame_range(window, start, end, step):\n    \"\"\"Context manager for setting frame range.\"\"\"\n    # Store current frame range\n    current_frame_start = window.scene.frame_start\n    current_frame_end = window.scene.frame_end\n    current_frame_step = window.scene.frame_step\n    # Apply frame range\n    window.scene.frame_start = start\n    window.scene.frame_end = end\n    window.scene.frame_step = step\n    try:\n        yield\n    finally:\n        # Restore frame range\n        window.scene.frame_start = current_frame_start\n        window.scene.frame_end = current_frame_end\n        window.scene.frame_step = current_frame_step\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_image_settings","title":"<code>applied_image_settings(window, options)</code>","text":"<p>Context manager to override image settings.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef applied_image_settings(window, options):\n    \"\"\"Context manager to override image settings.\"\"\"\n\n    options = options or ImageSettings.copy()\n    ffmpeg = options.pop(\"ffmpeg\", {})\n    render = window.scene.render\n\n    # Store current image settings\n    original = {}\n    for opt in options.copy():\n        try:\n            original[opt] = getattr(render.image_settings, opt)\n        except ValueError:\n            options.pop(opt)\n\n    # Store current ffmpeg settings\n    original_ffmpeg = {}\n    for opt in ffmpeg.copy():\n        try:\n            original_ffmpeg[opt] = getattr(render.ffmpeg, opt)\n        except ValueError:\n            ffmpeg.pop(opt)\n\n    # Apply image settings\n    for opt, value in options.items():\n        setattr(render.image_settings, opt, value)\n\n    # Apply ffmpeg settings\n    for opt, value in ffmpeg.items():\n        setattr(render.ffmpeg, opt, value)\n\n    try:\n        yield\n    finally:\n        # Restore previous settings\n        for opt, value in original.items():\n            setattr(render.image_settings, opt, value)\n        for opt, value in original_ffmpeg.items():\n            setattr(render.ffmpeg, opt, value)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_render_options","title":"<code>applied_render_options(window, options)</code>","text":"<p>Context manager for setting render options.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef applied_render_options(window, options):\n    \"\"\"Context manager for setting render options.\"\"\"\n    render = window.scene.render\n\n    # Store current settings\n    original = {}\n    for opt in options.copy():\n        try:\n            original[opt] = getattr(render, opt)\n        except ValueError:\n            options.pop(opt)\n\n    # Apply settings\n    _apply_options(render, options)\n\n    try:\n        yield\n    finally:\n        # Restore previous settings\n        _apply_options(render, original)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.applied_view","title":"<code>applied_view(window, camera, isolate=None, options=None)</code>","text":"<p>Apply view options to window.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def applied_view(window, camera, isolate=None, options=None):\n    \"\"\"Apply view options to window.\"\"\"\n    area = window.screen.areas[0]\n    space = area.spaces[0]\n\n    area.ui_type = \"VIEW_3D\"\n\n    types = {\"MESH\", \"GPENCIL\"}\n    objects = [obj for obj in window.scene.objects if obj.type in types]\n\n    if camera == \"AUTO\":\n        space.region_3d.view_perspective = \"ORTHO\"\n        isolate_objects(window, isolate or objects)\n    else:\n        isolate_objects(window, isolate or objects)\n        space.camera = window.scene.objects.get(camera)\n        space.region_3d.view_perspective = \"CAMERA\"\n\n    if isinstance(options, dict):\n        _apply_options(space, options)\n    else:\n        space.shading.type = \"SOLID\"\n        space.shading.color_type = \"MATERIAL\"\n        space.show_gizmo = False\n        space.overlay.show_overlays = False\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.capture","title":"<code>capture(camera=None, width=None, height=None, filename=None, start_frame=None, end_frame=None, step_frame=None, sound=None, isolate=None, maintain_aspect_ratio=True, overwrite=False, image_settings=None, display_options=None)</code>","text":"<p>Playblast in an independent windows Arguments:     camera (str, optional): Name of camera, defaults to \"Camera\"     width (int, optional): Width of output in pixels     height (int, optional): Height of output in pixels     filename (str, optional): Name of output file path. Defaults to current         render output path.     start_frame (int, optional): Defaults to current start frame.     end_frame (int, optional): Defaults to current end frame.     step_frame (int, optional): Defaults to 1.     sound (str, optional):  Specify the sound node to be used during         playblast. When None (default) no sound will be used.     isolate (list): List of nodes to isolate upon capturing     maintain_aspect_ratio (bool, optional): Modify height in order to         maintain aspect ratio.     overwrite (bool, optional): Whether or not to overwrite if file         already exists. If disabled and file exists and error will be         raised.     image_settings (dict, optional): Supplied image settings for render,         using <code>ImageSettings</code>     display_options (dict, optional): Supplied display options for render</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def capture(\n    camera=None,\n    width=None,\n    height=None,\n    filename=None,\n    start_frame=None,\n    end_frame=None,\n    step_frame=None,\n    sound=None,\n    isolate=None,\n    maintain_aspect_ratio=True,\n    overwrite=False,\n    image_settings=None,\n    display_options=None\n):\n    \"\"\"Playblast in an independent windows\n    Arguments:\n        camera (str, optional): Name of camera, defaults to \"Camera\"\n        width (int, optional): Width of output in pixels\n        height (int, optional): Height of output in pixels\n        filename (str, optional): Name of output file path. Defaults to current\n            render output path.\n        start_frame (int, optional): Defaults to current start frame.\n        end_frame (int, optional): Defaults to current end frame.\n        step_frame (int, optional): Defaults to 1.\n        sound (str, optional):  Specify the sound node to be used during\n            playblast. When None (default) no sound will be used.\n        isolate (list): List of nodes to isolate upon capturing\n        maintain_aspect_ratio (bool, optional): Modify height in order to\n            maintain aspect ratio.\n        overwrite (bool, optional): Whether or not to overwrite if file\n            already exists. If disabled and file exists and error will be\n            raised.\n        image_settings (dict, optional): Supplied image settings for render,\n            using `ImageSettings`\n        display_options (dict, optional): Supplied display options for render\n    \"\"\"\n\n    scene = bpy.context.scene\n    camera = camera or \"Camera\"\n\n    # Ensure camera exists.\n    if camera not in scene.objects and camera != \"AUTO\":\n        raise RuntimeError(\"Camera does not exist: {0}\".format(camera))\n\n    # Ensure resolution.\n    if width and height:\n        maintain_aspect_ratio = False\n    width = width or scene.render.resolution_x\n    height = height or scene.render.resolution_y\n    if maintain_aspect_ratio:\n        ratio = scene.render.resolution_x / scene.render.resolution_y\n        height = round(width / ratio)\n\n    # Get frame range.\n    if start_frame is None:\n        start_frame = scene.frame_start\n    if end_frame is None:\n        end_frame = scene.frame_end\n    if step_frame is None:\n        step_frame = 1\n    frame_range = (start_frame, end_frame, step_frame)\n\n    if filename is None:\n        filename = scene.render.filepath\n\n    render_options = {\n        \"filepath\": \"{}.\".format(filename.rstrip(\".\")),\n        \"resolution_x\": width,\n        \"resolution_y\": height,\n        \"use_overwrite\": overwrite,\n    }\n\n    with _independent_window() as window:\n\n        applied_view(window, camera, isolate, options=display_options)\n\n        with contextlib.ExitStack() as stack:\n            stack.enter_context(maintain_camera(window, camera))\n            stack.enter_context(applied_frame_range(window, *frame_range))\n            stack.enter_context(applied_render_options(window, render_options))\n            stack.enter_context(applied_image_settings(window, image_settings))\n            stack.enter_context(maintained_time())\n\n            bpy.ops.render.opengl(\n                animation=True,\n                render_keyed_only=False,\n                sequencer=False,\n                write_still=False,\n                view_context=True\n            )\n\n    return filename\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.isolate_objects","title":"<code>isolate_objects(window, objects)</code>","text":"<p>Isolate selection</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def isolate_objects(window, objects):\n    \"\"\"Isolate selection\"\"\"\n    deselect_all()\n\n    # Only select objects that happen to be in the view layer to avoid\n    # errors that object can't be selected because it is not in View Layer.\n    view_layer_objects = window.view_layer.objects\n    for obj in objects:\n        if obj.name in view_layer_objects:\n            obj.select_set(True)\n\n    context = create_blender_context(selected=objects, window=window)\n\n    with bpy.context.temp_override(**context):\n        bpy.ops.view3d.view_axis(type=\"FRONT\")\n        bpy.ops.view3d.localview()\n\n    deselect_all()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.maintain_camera","title":"<code>maintain_camera(window, camera)</code>","text":"<p>Context manager to override camera.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>@contextlib.contextmanager\ndef maintain_camera(window, camera):\n    \"\"\"Context manager to override camera.\"\"\"\n    current_camera = window.scene.camera\n    if camera in window.scene.objects:\n        window.scene.camera = window.scene.objects.get(camera)\n    try:\n        yield\n    finally:\n        window.scene.camera = current_camera\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/capture.html#client.ayon_blender.api.capture.restore_global_view","title":"<code>restore_global_view(window)</code>","text":"<p>Exit local view if active.</p> <p>Blender currently does not exit localview when closing windows.</p> Source code in <code>client/ayon_blender/api/capture.py</code> <pre><code>def restore_global_view(window):\n    \"\"\"Exit local view if active.\n\n    Blender currently does not exit localview when closing windows.\n    \"\"\"\n\n    types = {\"MESH\", \"GPENCIL\"}\n    objects = [obj for obj in window.scene.objects if obj.type in types]\n\n    context = create_blender_context(selected=objects, window=window)\n\n    with bpy.context.temp_override(**context):\n        # Only toggle back if in local view\n        if bpy.context.space_data.local_view:\n            bpy.ops.view3d.localview()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html","title":"colorspace","text":""},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.ARenderProduct","title":"<code>ARenderProduct</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>class ARenderProduct(object):\n    def __init__(self, frame_start, frame_end):\n        \"\"\"Constructor.\"\"\"\n        # Initialize\n        self.layer_data = self._get_layer_data(frame_start, frame_end)\n\n    def _get_layer_data(\n        self,\n        frame_start: int,\n        frame_end: int\n    ) -&gt; LayerMetadata:\n        return LayerMetadata(\n            frameStart=int(frame_start),\n            frameEnd=int(frame_end),\n        )\n\n    def add_render_product(\n        self,\n        product_name: str,\n        colorspace=\"\",\n        display=\"\",\n        view=\"\"):\n        self.layer_data.products.append(\n            RenderProduct(\n                productName=product_name,\n                colorspace=colorspace,\n                display=display,\n                view=view\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.ARenderProduct.__init__","title":"<code>__init__(frame_start, frame_end)</code>","text":"<p>Constructor.</p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>def __init__(self, frame_start, frame_end):\n    \"\"\"Constructor.\"\"\"\n    # Initialize\n    self.layer_data = self._get_layer_data(frame_start, frame_end)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.LayerMetadata","title":"<code>LayerMetadata</code>","text":"<p>               Bases: <code>object</code></p> <p>Data class for Render Layer metadata.</p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>@attr.s\nclass LayerMetadata(object):\n    \"\"\"Data class for Render Layer metadata.\"\"\"\n    frameStart = attr.ib()\n    frameEnd = attr.ib()\n    products: list[RenderProduct] = attr.ib(factory=list)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/colorspace.html#client.ayon_blender.api.colorspace.RenderProduct","title":"<code>RenderProduct</code>","text":"<p>               Bases: <code>object</code></p> <p>Getting Colorspace as Specific Render Product Parameter for submitting publish job.</p> Source code in <code>client/ayon_blender/api/colorspace.py</code> <pre><code>@attr.s\nclass RenderProduct(object):\n    \"\"\"\n    Getting Colorspace as Specific Render Product Parameter for submitting\n    publish job.\n    \"\"\"\n    colorspace = attr.ib()  # OCIO source colorspace\n    display = attr.ib()     # OCIO source display transform\n    view = attr.ib()        # OCIO source view transform\n    productName = attr.ib()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/constants.html","title":"constants","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.append_user_scripts","title":"<code>append_user_scripts()</code>","text":"<p>Apply user scripts to Blender.</p> <p>This was originally used for early Blender 4 versions due to requiring AYON to be sources from <code>BLENDER_USER_SCRIPTS</code> paths which unfortunately allowed only a single path, and it had the side effect of not loading the default user scripts anymore.</p> <p>In Blender 5+ this is irrelevant and instead additional Script Directories can be configured and used instead.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def append_user_scripts():\n    \"\"\"Apply user scripts to Blender.\n\n    This was originally used for early Blender 4 versions due to requiring\n    AYON to be sources from `BLENDER_USER_SCRIPTS` paths which unfortunately\n    allowed only a single path, *and* it had the side effect of not loading the\n    default user scripts anymore.\n\n    In Blender 5+ this is irrelevant and instead additional Script Directories\n    can be configured and used instead.\n    \"\"\"\n    default_user_prefs = os.path.join(\n        bpy.utils.resource_path('USER'),\n        \"scripts\",\n    )\n    user_scripts = os.environ.get(\"AYON_BLENDER_USER_SCRIPTS\") or default_user_prefs\n\n    try:\n        load_scripts(user_scripts.split(os.pathsep))\n    except Exception:\n        print(\"Couldn't load user scripts \\\"{}\\\"\".format(user_scripts))\n        traceback.print_exc()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.attribute_overrides","title":"<code>attribute_overrides(obj, attribute_values)</code>","text":"<p>Apply attribute or property overrides during context.</p> <p>Supports nested/deep overrides, that is also why it does not use **kwargs as function arguments because it requires the keys to support dots (<code>.</code>).</p> Example <p>with attribute_overrides(scene, { ...     \"render.fps\": 30, ...     \"frame_start\": 1001} ... ): ...     print(scene.render.fps) ...     print(scene.frame_start)</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to set attributes and properties on.</p> required <code>attribute_values</code> <p>(dict[str, Any]): The property names mapped to the values that will be applied during the context.</p> required Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef attribute_overrides(\n        obj,\n        attribute_values\n):\n    \"\"\"Apply attribute or property overrides during context.\n\n    Supports nested/deep overrides, that is also why it does not use **kwargs\n    as function arguments because it requires the keys to support dots (`.`).\n\n    Example:\n        &gt;&gt;&gt; with attribute_overrides(scene, {\n        ...     \"render.fps\": 30,\n        ...     \"frame_start\": 1001}\n        ... ):\n        ...     print(scene.render.fps)\n        ...     print(scene.frame_start)\n        # 30\n        # 1001\n\n    Arguments:\n        obj (Any): The object to set attributes and properties on.\n        attribute_values: (dict[str, Any]): The property names mapped to the\n            values that will be applied during the context.\n    \"\"\"\n    if not attribute_values:\n        # do nothing\n        yield\n        return\n\n    # Helper functions to get and set nested keys on the scene object like\n    # e.g. \"scene.unit_settings.scale_length\" or \"scene.render.fps\"\n    # by doing `setattr_deep(scene, \"unit_settings.scale_length\", 10)`\n    def getattr_deep(root, path):\n        for key in path.split(\".\"):\n            root = getattr(root, key)\n        return root\n\n    def setattr_deep(root, path, value):\n        keys = path.split(\".\")\n        last_key = keys.pop()\n        for key in keys:\n            root = getattr(root, key)\n        return setattr(root, last_key, value)\n\n    # Get original values\n    original = {\n        key: getattr_deep(obj, key) for key in attribute_values\n    }\n    try:\n        for key, value in attribute_values.items():\n            setattr_deep(obj, key, value)\n        yield\n    finally:\n        for key, value in original.items():\n            setattr_deep(obj, key, value)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.attribute_overrides--30","title":"30","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.attribute_overrides--1001","title":"1001","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.collect_animation_defs","title":"<code>collect_animation_defs(create_context, step=True, fps=False)</code>","text":"<p>Get the basic animation attribute definitions for the publisher.</p> <p>Parameters:</p> Name Type Description Default <code>create_context</code> <code>CreateContext</code> <p>The context of publisher will be used to define the defaults for the attributes to use the current context's entity frame range as default values.</p> required <code>step</code> <code>bool</code> <p>Whether to include <code>step</code> attribute definition.</p> <code>True</code> <code>fps</code> <code>bool</code> <p>Whether to include <code>fps</code> attribute definition.</p> <code>False</code> <p>Returns:</p> Type Description <p>List[NumberDef]: List of number attribute definitions.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def collect_animation_defs(create_context, step=True, fps=False):\n    \"\"\"Get the basic animation attribute definitions for the publisher.\n\n    Arguments:\n        create_context (CreateContext): The context of publisher will be\n            used to define the defaults for the attributes to use the current\n            context's entity frame range as default values.\n        step (bool): Whether to include `step` attribute definition.\n        fps (bool): Whether to include `fps` attribute definition.\n\n    Returns:\n        List[NumberDef]: List of number attribute definitions.\n\n    \"\"\"\n\n    # get scene values as defaults\n    scene = bpy.context.scene\n    # frame_start = scene.frame_start\n    # frame_end = scene.frame_end\n    # handle_start = 0\n    # handle_end = 0\n\n    # use task entity attributes to set defaults based on current context\n    task_entity = create_context.get_current_task_entity()\n    attrib: dict = task_entity[\"attrib\"]\n    frame_start = attrib[\"frameStart\"]\n    frame_end = attrib[\"frameEnd\"]\n    handle_start = attrib[\"handleStart\"]\n    handle_end = attrib[\"handleEnd\"]\n\n    # build attributes\n    defs = [\n        NumberDef(\"frameStart\",\n                  label=\"Frame Start\",\n                  default=frame_start,\n                  decimals=0),\n        NumberDef(\"frameEnd\",\n                  label=\"Frame End\",\n                  default=frame_end,\n                  decimals=0),\n        NumberDef(\"handleStart\",\n                  label=\"Handle Start\",\n                  tooltip=\"Frames added before frame start to use as handles.\",\n                  default=handle_start,\n                  decimals=0),\n        NumberDef(\"handleEnd\",\n                  label=\"Handle End\",\n                  tooltip=\"Frames added after frame end to use as handles.\",\n                  default=handle_end,\n                  decimals=0),\n    ]\n\n    if step:\n        defs.append(\n            NumberDef(\n                \"step\",\n                label=\"Step size\",\n                tooltip=\"Number of frames to skip forward while rendering/\"\n                        \"playing back each frame\",\n                default=1,\n                decimals=0\n            )\n        )\n\n    if fps:\n        current_fps = scene.render.fps / scene.render.fps_base\n        fps_def = NumberDef(\n            \"fps\", label=\"FPS\", default=current_fps, decimals=5\n        )\n        defs.append(fps_def)\n\n    return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.create_animation_instance","title":"<code>create_animation_instance(rig)</code>","text":"<p>Create animation instances for the given rigs.</p> <p>Parameters:</p> Name Type Description Default <code>rig</code> <code>Union[Collection, Object]</code> <p>Rig to create</p> required Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def create_animation_instance(rig: Union[bpy.types.Collection, bpy.types.Object]):\n    \"\"\"Create animation instances for the given rigs.\n\n    Args:\n        rig (Union[bpy.types.Collection, bpy.types.Object]): Rig to create\n        animation instances for.\n    \"\"\"\n    creator_identifier = \"io.ayon.creators.blender.animation\"\n    host = registered_host()\n    create_context = CreateContext(host)\n\n    create_context.create(\n        creator_identifier=creator_identifier,\n        variant=rig.name.split(':')[-1],\n        pre_create_data={\n            \"use_selection\": False,\n            \"asset_group\": rig\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_all_parents","title":"<code>get_all_parents(obj)</code>","text":"<p>Get all recursive parents of object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Object</code> <p>Object to get all parents for.</p> required <p>Returns:</p> Type Description <p>List[bpy.types.Object]: All parents of object</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_all_parents(obj):\n    \"\"\"Get all recursive parents of object.\n\n    Arguments:\n        obj (bpy.types.Object): Object to get all parents for.\n\n    Returns:\n        List[bpy.types.Object]: All parents of object\n\n    \"\"\"\n    result = []\n    while True:\n        obj = obj.parent\n        if not obj:\n            break\n        result.append(obj)\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_blender_version","title":"<code>get_blender_version()</code>","text":"<p>Get Blender Version</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_blender_version():\n    \"\"\"Get Blender Version\n    \"\"\"\n    major, minor, subversion = bpy.app.version\n    return major, minor, subversion\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_highest_root","title":"<code>get_highest_root(objects)</code>","text":"<p>Get the highest object (the least parents) among the objects.</p> <p>If multiple objects have the same amount of parents (or no parents) the first object found in the input iterable will be returned.</p> <p>Note that this will not return objects outside of the input list, as such it will not return the root of node from a child node. It is purely intended to find the highest object among a list of objects. To instead get the root from one object use, e.g. <code>get_all_parents(obj)[-1]</code></p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>List[Object]</code> <p>Objects to find the highest root in.</p> required <p>Returns:</p> Type Description <p>Optional[bpy.types.Object]: First highest root found or None if no <code>bpy.types.Object</code> found in input list.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_highest_root(objects):\n    \"\"\"Get the highest object (the least parents) among the objects.\n\n    If multiple objects have the same amount of parents (or no parents) the\n    first object found in the input iterable will be returned.\n\n    Note that this will *not* return objects outside of the input list, as\n    such it will not return the root of node from a child node. It is purely\n    intended to find the highest object among a list of objects. To instead\n    get the root from one object use, e.g. `get_all_parents(obj)[-1]`\n\n    Arguments:\n        objects (List[bpy.types.Object]): Objects to find the highest root in.\n\n    Returns:\n        Optional[bpy.types.Object]: First highest root found or None if no\n            `bpy.types.Object` found in input list.\n\n    \"\"\"\n    included_objects = {obj.name_full for obj in objects}\n    num_parents_to_obj = {}\n    for obj in objects:\n        if isinstance(obj, bpy.types.Object):\n            parents = get_all_parents(obj)\n            # included parents\n            parents = [parent for parent in parents if\n                       parent.name_full in included_objects]\n            if not parents:\n                # A node without parents must be a highest root\n                return obj\n\n            num_parents_to_obj.setdefault(len(parents), obj)\n\n    if not num_parents_to_obj:\n        return\n\n    minimum_parent = min(num_parents_to_obj)\n    return num_parents_to_obj[minimum_parent]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_scene_node_tree","title":"<code>get_scene_node_tree(ensure_exists=False)</code>","text":"<p>Return the node tree</p> <p>Parameters:</p> Name Type Description Default <code>ensure_exists</code> <code>bool</code> <p>When enabled, make sure a compositor node tree is enabled and set.</p> <code>False</code> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_scene_node_tree(ensure_exists=False):\n    \"\"\"Return the node tree\n\n    Arguments:\n        ensure_exists (bool): When enabled, make sure a compositor node tree is\n            enabled and set.\n    \"\"\"\n    if get_blender_version() &gt;= (5, 0, 0):\n        # Blender 5.0+\n        if not bpy.context.scene.compositing_node_group and ensure_exists:\n            # In Blender 5 if no comp node tree is set, create one\n            tree = bpy.data.node_groups.new(\"Compositor Nodes\",\n                                            \"CompositorNodeTree\")\n            bpy.context.scene.compositing_node_group = tree\n            return tree\n\n        return bpy.context.scene.compositing_node_group\n    else:\n        # Blender 4.0 and below\n        if not bpy.context.scene.node_tree and ensure_exists:\n            # Force enable compositor in Blender 4\n            bpy.context.scene.use_nodes = True\n\n        return bpy.context.scene.node_tree\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_selected_collections","title":"<code>get_selected_collections()</code>","text":"<p>Returns a list of the currently selected collections in the outliner.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the outliner cannot be found in the main Blender</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of <code>bpy.types.Collection</code> objects that are currently</p> <p>selected in the outliner.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_selected_collections():\n    \"\"\"\n    Returns a list of the currently selected collections in the outliner.\n\n    Raises:\n        RuntimeError: If the outliner cannot be found in the main Blender\n        window.\n\n    Returns:\n        list: A list of `bpy.types.Collection` objects that are currently\n        selected in the outliner.\n    \"\"\"\n    window = bpy.context.window or bpy.context.window_manager.windows[0]\n\n    try:\n        area = next(\n            area for area in window.screen.areas\n            if area.type == 'OUTLINER')\n        region = next(\n            region for region in area.regions\n            if region.type == 'WINDOW')\n    except StopIteration as e:\n        raise RuntimeError(\"Could not find outliner. An outliner space \"\n                           \"must be in the main Blender window.\") from e\n\n    with bpy.context.temp_override(\n        window=window,\n        area=area,\n        region=region,\n        screen=window.screen\n    ):\n        ids = bpy.context.selected_ids\n\n    return [id for id in ids if isinstance(id, bpy.types.Collection)]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.get_selection","title":"<code>get_selection(include_collections=False)</code>","text":"<p>Returns a list of selected objects in the current Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>include_collections</code> <code>bool</code> <p>Whether to include selected</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Object]</code> <p>List[bpy.types.Object]: A list of selected objects.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def get_selection(include_collections: bool = False) -&gt; List[bpy.types.Object]:\n    \"\"\"\n    Returns a list of selected objects in the current Blender scene.\n\n    Args:\n        include_collections (bool, optional): Whether to include selected\n        collections in the result. Defaults to False.\n\n    Returns:\n        List[bpy.types.Object]: A list of selected objects.\n    \"\"\"\n    selection = [obj for obj in bpy.context.scene.objects if obj.select_get()]\n\n    if include_collections:\n        selection.extend(get_selected_collections())\n\n    return selection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.imprint","title":"<code>imprint(node, data)</code>","text":"<p>Write <code>data</code> to <code>node</code> as userDefined attributes</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>bpy_struct_meta_idprop</code> <p>Long name of node</p> required <code>data</code> <code>Dict</code> <p>Dictionary of key/value pairs</p> required Example <p>import bpy def compute(): ...   return 6 ... bpy.ops.mesh.primitive_cube_add() cube = bpy.context.view_layer.objects.active imprint(cube, { ...   \"regularString\": \"myFamily\", ...   \"computedValue\": lambda: compute() ... }) ... cube['ayon']['computedValue'] 6</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def imprint(node: bpy.types.bpy_struct_meta_idprop, data: Dict):\n    r\"\"\"Write `data` to `node` as userDefined attributes\n\n    Arguments:\n        node: Long name of node\n        data: Dictionary of key/value pairs\n\n    Example:\n        &gt;&gt;&gt; import bpy\n        &gt;&gt;&gt; def compute():\n        ...   return 6\n        ...\n        &gt;&gt;&gt; bpy.ops.mesh.primitive_cube_add()\n        &gt;&gt;&gt; cube = bpy.context.view_layer.objects.active\n        &gt;&gt;&gt; imprint(cube, {\n        ...   \"regularString\": \"myFamily\",\n        ...   \"computedValue\": lambda: compute()\n        ... })\n        ...\n        &gt;&gt;&gt; cube['ayon']['computedValue']\n        6\n    \"\"\"\n\n    imprint_data = dict()\n\n    for key, value in data.items():\n        if value is None:\n            continue\n\n        if callable(value):\n            # Support values evaluated at imprint\n            value = value()\n\n        if not isinstance(value, (int, float, bool, str, list, dict)):\n            raise TypeError(f\"Unsupported type: {type(value)}\")\n\n        imprint_data[key] = value\n\n    pipeline.metadata_update(node, imprint_data)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.load_scripts","title":"<code>load_scripts(paths)</code>","text":"<p>Copy of <code>load_scripts</code> from Blender's implementation.</p> <p>It is possible that this function will be changed in future and usage will be based on Blender version.</p> <p>This does not work in Blender 5+ due to <code>bpy_types</code> being unavailable. But usually this is not needed for Blender 5+ anyway, because it does allow better user scripts management through environment variables than older releases of Blender.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def load_scripts(paths):\n    \"\"\"Copy of `load_scripts` from Blender's implementation.\n\n    It is possible that this function will be changed in future and usage will\n    be based on Blender version.\n\n    This does not work in Blender 5+ due to `bpy_types` being unavailable. But\n    usually this is not needed for Blender 5+ anyway, because it does allow\n    better user scripts management through environment variables than older\n    releases of Blender.\n    \"\"\"\n    import bpy_types\n\n    loaded_modules = set()\n\n    previous_classes = [\n        cls\n        for cls in bpy.types.bpy_struct.__subclasses__()\n    ]\n\n    def register_module_call(mod):\n        register = getattr(mod, \"register\", None)\n        if register:\n            try:\n                register()\n            except:  # noqa E722\n                traceback.print_exc()\n        else:\n            print(\"\\nWarning! '%s' has no register function, \"\n                  \"this is now a requirement for registerable scripts\" %\n                  mod.__file__)\n\n    def unregister_module_call(mod):\n        unregister = getattr(mod, \"unregister\", None)\n        if unregister:\n            try:\n                unregister()\n            except:  # noqa E722\n                traceback.print_exc()\n\n    def test_reload(mod):\n        # reloading this causes internal errors\n        # because the classes from this module are stored internally\n        # possibly to refresh internal references too but for now, best not to.\n        if mod == bpy_types:\n            return mod\n\n        try:\n            return importlib.reload(mod)\n        except:  # noqa E722\n            traceback.print_exc()\n\n    def test_register(mod):\n        if mod:\n            register_module_call(mod)\n            bpy.utils._global_loaded_modules.append(mod.__name__)\n\n    from bpy_restrict_state import RestrictBlend\n\n    with RestrictBlend():\n        for base_path in paths:\n            for path_subdir in bpy.utils._script_module_dirs:\n                path = os.path.join(base_path, path_subdir)\n                if not os.path.isdir(path):\n                    continue\n\n                bpy.utils._sys_path_ensure_prepend(path)\n\n                # Only add to 'sys.modules' unless this is 'startup'.\n                if path_subdir != \"startup\":\n                    continue\n                for mod in bpy.utils.modules_from_path(path, loaded_modules):\n                    test_register(mod)\n\n    addons_paths = []\n    for base_path in paths:\n        addons_path = os.path.join(base_path, \"addons\")\n        if not os.path.exists(addons_path):\n            continue\n        addons_paths.append(addons_path)\n        addons_module_path = os.path.join(addons_path, \"modules\")\n        if os.path.exists(addons_module_path):\n            bpy.utils._sys_path_ensure_prepend(addons_module_path)\n\n    if addons_paths:\n        # Fake addons\n        origin_paths = addon_utils.paths\n\n        def new_paths():\n            paths = origin_paths() + addons_paths\n            return paths\n\n        addon_utils.paths = new_paths\n        addon_utils.modules_refresh()\n\n    # load template (if set)\n    if any(bpy.utils.app_template_paths()):\n        import bl_app_template_utils\n        bl_app_template_utils.reset(reload_scripts=False)\n        del bl_app_template_utils\n\n    for cls in bpy.types.bpy_struct.__subclasses__():\n        if cls in previous_classes:\n            continue\n        if not getattr(cls, \"is_registered\", False):\n            continue\n        for subcls in cls.__subclasses__():\n            if not subcls.is_registered:\n                print(\n                    \"Warning, unregistered class: %s(%s)\" %\n                    (subcls.__name__, cls.__name__)\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.lsattr","title":"<code>lsattr(attr, value=None)</code>","text":"<p>Return nodes matching <code>attr</code> and <code>value</code></p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Name of Blender property</p> required <code>value</code> <code>Union[str, int, bool, List, Dict, None]</code> <p>Value of attribute. If none is provided, return all nodes with this attribute.</p> <code>None</code> Example <p>lsattr(\"id\", \"myId\") ...   [bpy.data.objects[\"myNode\"] lsattr(\"id\") ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]</p> <p>Returns:</p> Type Description <code>List</code> <p>list</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattr(attr: str,\n           value: Union[str, int, bool, List, Dict, None] = None) -&gt; List:\n    r\"\"\"Return nodes matching `attr` and `value`\n\n    Arguments:\n        attr: Name of Blender property\n        value: Value of attribute. If none\n            is provided, return all nodes with this attribute.\n\n    Example:\n        &gt;&gt;&gt; lsattr(\"id\", \"myId\")\n        ...   [bpy.data.objects[\"myNode\"]\n        &gt;&gt;&gt; lsattr(\"id\")\n        ...   [bpy.data.objects[\"myNode\"], bpy.data.objects[\"myOtherNode\"]]\n\n    Returns:\n        list\n    \"\"\"\n\n    return lsattrs({attr: value})\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.lsattrs","title":"<code>lsattrs(attrs)</code>","text":"<p>Return nodes with the given attribute(s).</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>Dict</code> <p>Name and value pairs of expected matches</p> required Example <p>lsattrs({\"age\": 5})  # Return nodes with an <code>age</code> of 5</p> <p>Returns a list.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def lsattrs(attrs: Dict) -&gt; List:\n    r\"\"\"Return nodes with the given attribute(s).\n\n    Arguments:\n        attrs: Name and value pairs of expected matches\n\n    Example:\n        &gt;&gt;&gt; lsattrs({\"age\": 5})  # Return nodes with an `age` of 5\n        # Return nodes with both `age` and `color` of 5 and blue\n        &gt;&gt;&gt; lsattrs({\"age\": 5, \"color\": \"blue\"})\n\n    Returns a list.\n\n    \"\"\"\n\n    # For now return all objects, not filtered by scene/collection/view_layer.\n    matches = set()\n    for coll in dir(bpy.data):\n        if not isinstance(\n                getattr(bpy.data, coll),\n                bpy.types.bpy_prop_collection,\n        ):\n            continue\n        for node in getattr(bpy.data, coll):\n            ayon_prop = pipeline.get_ayon_property(node)\n            if not ayon_prop:\n                continue\n\n            for attr, value in attrs.items():\n                if (ayon_prop.get(attr)\n                        and (value is None or ayon_prop.get(attr) == value)):\n                    matches.add(node)\n    return list(matches)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.lsattrs--return-nodes-with-both-age-and-color-of-5-and-blue","title":"Return nodes with both <code>age</code> and <code>color</code> of 5 and blue","text":"<p>lsattrs({\"age\": 5, \"color\": \"blue\"})</p>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     # Modify selection ...     bpy.ops.object.select_all(action='DESELECT')</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    r\"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     # Modify selection\n        ...     bpy.ops.object.select_all(action='DESELECT')\n        &gt;&gt;&gt; # Selection restored\n    \"\"\"\n\n    previous_selection = get_selection()\n    previous_active = bpy.context.view_layer.objects.active\n    try:\n        yield\n    finally:\n        # Clear the selection\n        for node in get_selection():\n            node.select_set(state=False)\n        if previous_selection:\n            for node in previous_selection:\n                try:\n                    node.select_set(state=True)\n                except ReferenceError:\n                    # This could happen if a selected node was deleted during\n                    # the context.\n                    log.exception(\"Failed to reselect\")\n                    continue\n        try:\n            bpy.context.view_layer.objects.active = previous_active\n        except ReferenceError:\n            # This could happen if the active node was deleted during the\n            # context.\n            log.exception(\"Failed to set active object.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.maintained_selection--selection-restored","title":"Selection restored","text":""},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.maintained_time","title":"<code>maintained_time()</code>","text":"<p>Maintain current frame during context.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_time():\n    \"\"\"Maintain current frame during context.\"\"\"\n    current_time = bpy.context.scene.frame_current\n    try:\n        yield\n    finally:\n        bpy.context.scene.frame_current = current_time\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.packed_images","title":"<code>packed_images(datablocks, logger=None)</code>","text":"<p>Unpack packed images during context This will pack all unpacked images found in the given datablocks, and unpack them back when exiting the context.</p> <p>Parameters:</p> Name Type Description Default <code>datablocks</code> <code>set</code> <p>Datablocks to search for unpacked images.</p> required <code>logger</code> <code>Logger</code> <p>Logger to use for warnings if packing fails.</p> <code>None</code> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef packed_images(datablocks, logger=None):\n    \"\"\"Unpack packed images during context\n    This will pack all unpacked images found in the given datablocks,\n    and unpack them back when exiting the context.\n\n    Args:\n        datablocks (set): Datablocks to search for\n            unpacked images.\n        logger (logging.Logger): Logger to use for warnings if packing fails.\n\n    \"\"\"\n\n    if logger is None:\n        logger = log\n\n    unpacked_node_images = set()\n    for data in datablocks:\n        if not (\n            isinstance(data, bpy.types.Object) and data.type == 'MESH'\n        ):\n            continue\n        for material_slot in data.material_slots:\n            mat = material_slot.material\n            if not (mat and mat.use_nodes):\n                continue\n            tree = mat.node_tree\n            if tree.type != 'SHADER':\n                continue\n            for node in tree.nodes:\n                if node.bl_idname != 'ShaderNodeTexImage':\n                    continue\n                if not node.image:\n                    continue\n                if node.image.packed_file is not None:\n                    continue\n\n                try:\n                    node.image.pack()\n                except RuntimeError:\n                    logger.warning(\n                        f\"Unable to pack node: {node}\",\n                        exc_info=True\n                    )\n                    continue\n                unpacked_node_images.add(node.image)\n    try:\n        yield\n\n    finally:\n        for image in unpacked_node_images:\n            image.unpack()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.read","title":"<code>read(node)</code>","text":"<p>Return user-defined attributes from <code>node</code></p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def read(node: bpy.types.bpy_struct_meta_idprop):\n    \"\"\"Return user-defined attributes from `node`\"\"\"\n\n    data = dict(node.get(AYON_PROPERTY, {}))\n\n    # Ignore hidden/internal data\n    data = {\n        key: value\n        for key, value in data.items() if not key.startswith(\"_\")\n    }\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.search_replace_render_paths","title":"<code>search_replace_render_paths(src, dest)</code>","text":"<p>Search and replace render paths in the current scene.</p> <p>This function searches for all render paths in the current scene and replaces them with a new path defined by the user.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>Search text to replace.</p> required <code>dest</code> <code>str</code> <p>Replacement text for the search.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any changes were made, False otherwise.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>def search_replace_render_paths(src: str, dest: str) -&gt; bool:\n    \"\"\"Search and replace render paths in the current scene.\n\n    This function searches for all render paths in the current scene and\n    replaces them with a new path defined by the user.\n\n    Arguments:\n        src (str): Search text to replace.\n        dest (str): Replacement text for the search.\n\n    Returns:\n        bool: True if any changes were made, False otherwise.\n\n    \"\"\"\n    changes = False\n\n    # Scene\n    path: str = bpy.context.scene.render.filepath\n    new_path: str = path.replace(src, dest)\n    if new_path != path:\n        log.info(f\"Updating scene render path from '{path}' to '{new_path}'\")\n        bpy.context.scene.render.filepath = new_path\n        changes = True\n\n    # Base paths for Compositor File Output Nodes\n    node_tree = get_scene_node_tree()\n    if node_tree:\n        for node in node_tree.nodes:\n            if node.bl_idname != \"CompositorNodeOutputFile\":\n                continue\n\n            path: str = node.base_path\n            new_path: str = path.replace(src, dest)\n            if new_path == path:\n                continue\n\n            log.info(\n                \"Updating compositor output file node base render path from \"\n                f\"'{path}' to '{new_path}'\"\n            )\n            node.base_path = new_path\n            changes = True\n\n    return changes\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.strip_container_data","title":"<code>strip_container_data(containers)</code>","text":"<p>Remove container data during context</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef strip_container_data(containers):\n    \"\"\"Remove container data during context\n    \"\"\"\n    container_data = {}\n    for container in containers:\n        node = container[\"node\"]\n        container_data[node] = dict(\n            node.get(AYON_PROPERTY)\n        )\n        del node[AYON_PROPERTY]\n    try:\n        yield\n\n    finally:\n        for key, item in container_data.items():\n            key[AYON_PROPERTY] = item\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.strip_instance_data","title":"<code>strip_instance_data(node)</code>","text":"<p>Remove instance data during context</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef strip_instance_data(node):\n    \"\"\"Remove instance data during context\n    \"\"\"\n    previous_data = dict(node.get(AYON_PROPERTY, {}))\n    try:\n        node[AYON_PROPERTY][\"active\"] = False\n        yield\n    finally:\n        node[AYON_PROPERTY] = previous_data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/lib.html#client.ayon_blender.api.lib.strip_namespace","title":"<code>strip_namespace(containers)</code>","text":"<p>Strip namespace during context This context manager is only valid for blender version elder than 5.0. This would be deprecated after the blender 5.0.</p> Source code in <code>client/ayon_blender/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef strip_namespace(containers):\n    \"\"\"Strip namespace during context\n    This context manager is only valid for blender version elder than 5.0.\n    This would be deprecated after the blender 5.0.\n    \"\"\"\n    if get_blender_version() &gt;= (5, 0, 0):\n        yield\n        return\n\n    nodes = [\n        container[\"node\"] for container in containers\n    ]\n    original_namespaces = {}\n    for node in nodes:\n        if isinstance(node, bpy.types.Collection):\n            children = node.children_recursive\n        elif isinstance(node, bpy.types.Object):\n            children = node.children\n        elif isinstance(node, (bpy.types.Node, bpy.types.Action)):\n            children = [node]\n        else:\n            raise TypeError(f\"Unsupported type: {node} ({type(node)})\")\n\n        for child in children:\n            original_name = child.name\n            if \":\" not in original_name:\n                continue\n            namespace, name = original_name.rsplit(':', 1)\n            child.name = name\n            original_namespaces[child] = namespace\n\n    try:\n        yield\n    finally:\n        for node, original_namespace in original_namespaces.items():\n            node.name = f\"{original_namespace}:{name}\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html","title":"ops","text":"<p>Blender operators and menus for use with AYON.</p>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchCreator","title":"<code>LaunchCreator</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch AYON Creator.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchCreator(LaunchQtApp):\n    \"\"\"Launch AYON Creator.\"\"\"\n\n    bl_idname = \"wm.ayon_creator\"\n    bl_label = \"Create...\"\n    _tool_name = \"creator\"\n\n    def before_window_show(self):\n        self._window.refresh()\n\n    def execute(self, context):\n        host_tools.show_publisher(tab=\"create\")\n        return {\"FINISHED\"}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchLibrary","title":"<code>LaunchLibrary</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch Library Loader.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchLibrary(LaunchQtApp):\n    \"\"\"Launch Library Loader.\"\"\"\n\n    bl_idname = \"wm.library_loader\"\n    bl_label = \"Library...\"\n    _tool_name = \"libraryloader\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchLoader","title":"<code>LaunchLoader</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch AYON Loader.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchLoader(LaunchQtApp):\n    \"\"\"Launch AYON Loader.\"\"\"\n\n    bl_idname = \"wm.ayon_loader\"\n    bl_label = \"Load...\"\n    _tool_name = \"loader\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchManager","title":"<code>LaunchManager</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch AYON Manager.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchManager(LaunchQtApp):\n    \"\"\"Launch AYON Manager.\"\"\"\n\n    bl_idname = \"wm.ayon_manager\"\n    bl_label = \"Manage...\"\n    _tool_name = \"sceneinventory\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchPublisher","title":"<code>LaunchPublisher</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch AYON Publisher.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchPublisher(LaunchQtApp):\n    \"\"\"Launch AYON Publisher.\"\"\"\n\n    bl_idname = \"wm.ayon_publisher\"\n    bl_label = \"Publish...\"\n\n    def execute(self, context):\n        host_tools.show_publisher(tab=\"publish\")\n        return {\"FINISHED\"}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchQtApp","title":"<code>LaunchQtApp</code>","text":"<p>               Bases: <code>Operator</code></p> <p>A Base class for operators to launch a Qt app.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchQtApp(bpy.types.Operator):\n    \"\"\"A Base class for operators to launch a Qt app.\"\"\"\n\n    _window = Union[QtWidgets.QDialog, ModuleType]\n    _tool_name: str = None\n    _init_args: Optional[List] = list()\n    _init_kwargs: Optional[Dict] = dict()\n    bl_idname: str = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if self.bl_idname is None:\n            raise NotImplementedError(\"Attribute `bl_idname` must be set!\")\n        print(f\"Initialising {self.bl_idname}...\")\n        GlobalClass.app = BlenderApplication.get_app()\n\n        if not bpy.app.timers.is_registered(_process_app_events):\n            bpy.app.timers.register(\n                _process_app_events,\n                persistent=True\n            )\n\n    def execute(self, context):\n        \"\"\"Execute the operator.\n\n        The child class must implement `execute()` where it only has to set\n        `self._window` to the desired Qt window and then simply run\n        `return super().execute(context)`.\n        `self._window` is expected to have a `show` method.\n        If the `show` method requires arguments, you can set `self._show_args`\n        and `self._show_kwargs`. `args` should be a list, `kwargs` a\n        dictionary.\n        \"\"\"\n\n        if self._tool_name is None:\n            if self._window is None:\n                raise AttributeError(\"`self._window` is not set.\")\n\n        else:\n            window = BlenderApplication.get_window(self.bl_idname)\n            if window is None:\n                window = host_tools.get_tool_by_name(self._tool_name)\n                BlenderApplication.store_window(self.bl_idname, window)\n            self._window = window\n\n        if not isinstance(self._window, (QtWidgets.QWidget, ModuleType)):\n            raise AttributeError(\n                \"`window` should be a `QWidget or module`. Got: {}\".format(\n                    str(type(self._window))\n                )\n            )\n\n        self.before_window_show()\n\n        def pull_to_front(window):\n            \"\"\"Pull window forward to screen.\n\n            If Window is minimized this will un-minimize, then it can be raised\n            and activated to the front.\n            \"\"\"\n            window.setWindowState(\n                (window.windowState() &amp; ~QtCore.Qt.WindowMinimized) |\n                QtCore.Qt.WindowActive\n            )\n            window.raise_()\n            window.activateWindow()\n\n        if isinstance(self._window, ModuleType):\n            self._window.show()\n            pull_to_front(self._window)\n\n            # Pull window to the front\n            window = None\n            if hasattr(self._window, \"window\"):\n                window = self._window.window\n            elif hasattr(self._window, \"_window\"):\n                window = self._window.window\n\n            if window:\n                BlenderApplication.store_window(self.bl_idname, window)\n\n        else:\n            origin_flags = self._window.windowFlags()\n            on_top_flags = origin_flags | QtCore.Qt.WindowStaysOnTopHint\n            self._window.setWindowFlags(on_top_flags)\n            self._window.show()\n            pull_to_front(self._window)\n\n            # if on_top_flags != origin_flags:\n            #     self._window.setWindowFlags(origin_flags)\n            #     self._window.show()\n\n        return {'FINISHED'}\n\n    def before_window_show(self):\n        return\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchQtApp.execute","title":"<code>execute(context)</code>","text":"<p>Execute the operator.</p> <p>The child class must implement <code>execute()</code> where it only has to set <code>self._window</code> to the desired Qt window and then simply run <code>return super().execute(context)</code>. <code>self._window</code> is expected to have a <code>show</code> method. If the <code>show</code> method requires arguments, you can set <code>self._show_args</code> and <code>self._show_kwargs</code>. <code>args</code> should be a list, <code>kwargs</code> a dictionary.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def execute(self, context):\n    \"\"\"Execute the operator.\n\n    The child class must implement `execute()` where it only has to set\n    `self._window` to the desired Qt window and then simply run\n    `return super().execute(context)`.\n    `self._window` is expected to have a `show` method.\n    If the `show` method requires arguments, you can set `self._show_args`\n    and `self._show_kwargs`. `args` should be a list, `kwargs` a\n    dictionary.\n    \"\"\"\n\n    if self._tool_name is None:\n        if self._window is None:\n            raise AttributeError(\"`self._window` is not set.\")\n\n    else:\n        window = BlenderApplication.get_window(self.bl_idname)\n        if window is None:\n            window = host_tools.get_tool_by_name(self._tool_name)\n            BlenderApplication.store_window(self.bl_idname, window)\n        self._window = window\n\n    if not isinstance(self._window, (QtWidgets.QWidget, ModuleType)):\n        raise AttributeError(\n            \"`window` should be a `QWidget or module`. Got: {}\".format(\n                str(type(self._window))\n            )\n        )\n\n    self.before_window_show()\n\n    def pull_to_front(window):\n        \"\"\"Pull window forward to screen.\n\n        If Window is minimized this will un-minimize, then it can be raised\n        and activated to the front.\n        \"\"\"\n        window.setWindowState(\n            (window.windowState() &amp; ~QtCore.Qt.WindowMinimized) |\n            QtCore.Qt.WindowActive\n        )\n        window.raise_()\n        window.activateWindow()\n\n    if isinstance(self._window, ModuleType):\n        self._window.show()\n        pull_to_front(self._window)\n\n        # Pull window to the front\n        window = None\n        if hasattr(self._window, \"window\"):\n            window = self._window.window\n        elif hasattr(self._window, \"_window\"):\n            window = self._window.window\n\n        if window:\n            BlenderApplication.store_window(self.bl_idname, window)\n\n    else:\n        origin_flags = self._window.windowFlags()\n        on_top_flags = origin_flags | QtCore.Qt.WindowStaysOnTopHint\n        self._window.setWindowFlags(on_top_flags)\n        self._window.show()\n        pull_to_front(self._window)\n\n        # if on_top_flags != origin_flags:\n        #     self._window.setWindowFlags(origin_flags)\n        #     self._window.show()\n\n    return {'FINISHED'}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.LaunchWorkFiles","title":"<code>LaunchWorkFiles</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Launch AYON Work Files.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class LaunchWorkFiles(LaunchQtApp):\n    \"\"\"Launch AYON Work Files.\"\"\"\n\n    bl_idname = \"wm.ayon_workfiles\"\n    bl_label = \"Work Files...\"\n    _tool_name = \"workfiles\"\n\n    def execute(self, context):\n        return super().execute(context)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.MainThreadItem","title":"<code>MainThreadItem</code>","text":"<p>Structure to store information about callback in main thread.</p> <p>Item should be used to execute callback in main thread which may be needed for execution of Qt objects.</p> <p>Item store callback (callable variable), arguments and keyword arguments for the callback. Item hold information about it's process.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class MainThreadItem:\n    \"\"\"Structure to store information about callback in main thread.\n\n    Item should be used to execute callback in main thread which may be needed\n    for execution of Qt objects.\n\n    Item store callback (callable variable), arguments and keyword arguments\n    for the callback. Item hold information about it's process.\n    \"\"\"\n    not_set = object()\n    sleep_time = 0.1\n\n    def __init__(self, callback, *args, **kwargs):\n        self.done = False\n        self.exception = self.not_set\n        self.result = self.not_set\n        self.callback = callback\n        self.args = args\n        self.kwargs = kwargs\n\n    def execute(self):\n        \"\"\"Execute callback and store its result.\n\n        Method must be called from main thread. Item is marked as `done`\n        when callback execution finished. Store output of callback of exception\n        information when callback raises one.\n        \"\"\"\n        print(\"Executing process in main thread\")\n        if self.done:\n            print(\"- item is already processed\")\n            return\n\n        callback = self.callback\n        args = self.args\n        kwargs = self.kwargs\n        print(\"Running callback: {}\".format(str(callback)))\n        try:\n            result = callback(*args, **kwargs)\n            self.result = result\n\n        except Exception:\n            self.exception = sys.exc_info()\n\n        finally:\n            print(\"Done\")\n            self.done = True\n\n    def wait(self):\n        \"\"\"Wait for result from main thread.\n\n        This method stops current thread until callback is executed.\n\n        Returns:\n            object: Output of callback. May be any type or object.\n\n        Raises:\n            Exception: Reraise any exception that happened during callback\n                execution.\n        \"\"\"\n        while not self.done:\n            print(self.done)\n            time.sleep(self.sleep_time)\n\n        if self.exception is self.not_set:\n            return self.result\n        raise self.exception\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.MainThreadItem.execute","title":"<code>execute()</code>","text":"<p>Execute callback and store its result.</p> <p>Method must be called from main thread. Item is marked as <code>done</code> when callback execution finished. Store output of callback of exception information when callback raises one.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def execute(self):\n    \"\"\"Execute callback and store its result.\n\n    Method must be called from main thread. Item is marked as `done`\n    when callback execution finished. Store output of callback of exception\n    information when callback raises one.\n    \"\"\"\n    print(\"Executing process in main thread\")\n    if self.done:\n        print(\"- item is already processed\")\n        return\n\n    callback = self.callback\n    args = self.args\n    kwargs = self.kwargs\n    print(\"Running callback: {}\".format(str(callback)))\n    try:\n        result = callback(*args, **kwargs)\n        self.result = result\n\n    except Exception:\n        self.exception = sys.exc_info()\n\n    finally:\n        print(\"Done\")\n        self.done = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.MainThreadItem.wait","title":"<code>wait()</code>","text":"<p>Wait for result from main thread.</p> <p>This method stops current thread until callback is executed.</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Output of callback. May be any type or object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Reraise any exception that happened during callback execution.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def wait(self):\n    \"\"\"Wait for result from main thread.\n\n    This method stops current thread until callback is executed.\n\n    Returns:\n        object: Output of callback. May be any type or object.\n\n    Raises:\n        Exception: Reraise any exception that happened during callback\n            execution.\n    \"\"\"\n    while not self.done:\n        print(self.done)\n        time.sleep(self.sleep_time)\n\n    if self.exception is self.not_set:\n        return self.result\n    raise self.exception\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.TOPBAR_MT_ayon","title":"<code>TOPBAR_MT_ayon</code>","text":"<p>               Bases: <code>Menu</code></p> <p>AYON menu.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class TOPBAR_MT_ayon(bpy.types.Menu):\n    \"\"\"AYON menu.\"\"\"\n\n    bl_idname = \"TOPBAR_MT_AYON\"\n    bl_label = os.environ.get(\"AYON_MENU_LABEL\")\n\n    def draw(self, context):\n        \"\"\"Draw the menu in the UI.\"\"\"\n\n        layout = self.layout\n\n        pcoll = PREVIEW_COLLECTIONS.get(\"ayon\")\n        if pcoll:\n            pyblish_menu_icon = pcoll[\"pyblish_menu_icon\"]\n            pyblish_menu_icon_id = pyblish_menu_icon.icon_id\n        else:\n            pyblish_menu_icon_id = 0\n\n        folder_path = get_current_folder_path()\n        task_name = get_current_task_name()\n        context_label = f\"{folder_path}, {task_name}\"\n        context_label_item = layout.row()\n        context_label_item.operator(\n            LaunchWorkFiles.bl_idname, text=context_label\n        )\n        context_label_item.enabled = False\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n        if project_settings[\"core\"][\"tools\"][\"ayon_menu\"].get(\n            \"version_up_current_workfile\"):\n                layout.separator()\n                layout.operator(\n                    VersionUpWorkfile.bl_idname,\n                    text=\"Version Up Workfile\"\n                )\n                wm = bpy.context.window_manager\n                keyconfigs = wm.keyconfigs\n                keymap = keyconfigs.addon.keymaps.new(name='Window', space_type='EMPTY')\n                keymap.keymap_items.new(\n                    VersionUpWorkfile.bl_idname, 'S',\n                    'PRESS', ctrl=True, alt=True\n                )\n                bpy.context.window_manager.keyconfigs.addon.keymaps.update()\n\n        layout.separator()\n        layout.operator(LaunchCreator.bl_idname, text=\"Create...\")\n        layout.operator(LaunchLoader.bl_idname, text=\"Load...\")\n        layout.operator(\n            LaunchPublisher.bl_idname,\n            text=\"Publish...\",\n            icon_value=pyblish_menu_icon_id,\n        )\n        layout.operator(LaunchManager.bl_idname, text=\"Manage...\")\n        layout.operator(LaunchLibrary.bl_idname, text=\"Library...\")\n        layout.separator()\n        layout.operator(SetFrameRange.bl_idname, text=\"Set Frame Range\")\n        layout.operator(SetResolution.bl_idname, text=\"Set Resolution\")\n        layout.operator(SetUnitScale.bl_idname, text=\"Set Unit Scale\")\n        layout.operator(CreateRenderSetup.bl_idname,\n                        text=\"Create Render Setup\")\n        layout.separator()\n        layout.operator(LaunchWorkFiles.bl_idname, text=\"Work Files...\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.TOPBAR_MT_ayon.draw","title":"<code>draw(context)</code>","text":"<p>Draw the menu in the UI.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def draw(self, context):\n    \"\"\"Draw the menu in the UI.\"\"\"\n\n    layout = self.layout\n\n    pcoll = PREVIEW_COLLECTIONS.get(\"ayon\")\n    if pcoll:\n        pyblish_menu_icon = pcoll[\"pyblish_menu_icon\"]\n        pyblish_menu_icon_id = pyblish_menu_icon.icon_id\n    else:\n        pyblish_menu_icon_id = 0\n\n    folder_path = get_current_folder_path()\n    task_name = get_current_task_name()\n    context_label = f\"{folder_path}, {task_name}\"\n    context_label_item = layout.row()\n    context_label_item.operator(\n        LaunchWorkFiles.bl_idname, text=context_label\n    )\n    context_label_item.enabled = False\n    project_name = get_current_project_name()\n    project_settings = get_project_settings(project_name)\n    if project_settings[\"core\"][\"tools\"][\"ayon_menu\"].get(\n        \"version_up_current_workfile\"):\n            layout.separator()\n            layout.operator(\n                VersionUpWorkfile.bl_idname,\n                text=\"Version Up Workfile\"\n            )\n            wm = bpy.context.window_manager\n            keyconfigs = wm.keyconfigs\n            keymap = keyconfigs.addon.keymaps.new(name='Window', space_type='EMPTY')\n            keymap.keymap_items.new(\n                VersionUpWorkfile.bl_idname, 'S',\n                'PRESS', ctrl=True, alt=True\n            )\n            bpy.context.window_manager.keyconfigs.addon.keymaps.update()\n\n    layout.separator()\n    layout.operator(LaunchCreator.bl_idname, text=\"Create...\")\n    layout.operator(LaunchLoader.bl_idname, text=\"Load...\")\n    layout.operator(\n        LaunchPublisher.bl_idname,\n        text=\"Publish...\",\n        icon_value=pyblish_menu_icon_id,\n    )\n    layout.operator(LaunchManager.bl_idname, text=\"Manage...\")\n    layout.operator(LaunchLibrary.bl_idname, text=\"Library...\")\n    layout.separator()\n    layout.operator(SetFrameRange.bl_idname, text=\"Set Frame Range\")\n    layout.operator(SetResolution.bl_idname, text=\"Set Resolution\")\n    layout.operator(SetUnitScale.bl_idname, text=\"Set Unit Scale\")\n    layout.operator(CreateRenderSetup.bl_idname,\n                    text=\"Create Render Setup\")\n    layout.separator()\n    layout.operator(LaunchWorkFiles.bl_idname, text=\"Work Files...\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.VersionUpWorkfile","title":"<code>VersionUpWorkfile</code>","text":"<p>               Bases: <code>LaunchQtApp</code></p> <p>Perform Incremental Save Workfile.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>class VersionUpWorkfile(LaunchQtApp):\n    \"\"\"Perform Incremental Save Workfile.\"\"\"\n\n    bl_idname = \"wm.ayon_version_up_workfile\"\n    bl_label = \"Version Up Workfile\"\n\n    def execute(self, context):\n        version_up_current_workfile()\n        return {\"FINISHED\"}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.draw_ayon_menu","title":"<code>draw_ayon_menu(self, context)</code>","text":"<p>Draw the AYON menu in the top bar.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def draw_ayon_menu(self, context):\n    \"\"\"Draw the AYON menu in the top bar.\"\"\"\n\n    self.layout.menu(TOPBAR_MT_ayon.bl_idname)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.execute_function_in_main_thread","title":"<code>execute_function_in_main_thread(f)</code>","text":"<p>Decorator to move a function call into main thread items</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def execute_function_in_main_thread(f):\n    \"\"\"Decorator to move a function call into main thread items\"\"\"\n    def wrapper(*args, **kwargs):\n        mti = MainThreadItem(f, *args, **kwargs)\n        execute_in_main_thread(mti)\n    return wrapper\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.register","title":"<code>register()</code>","text":"<p>Register the operators and menu.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def register():\n    \"Register the operators and menu.\"\n\n    pcoll = bpy.utils.previews.new()\n    pyblish_icon_file = Path(__file__).parent / \"icons\" / \"pyblish-32x32.png\"\n    pcoll.load(\"pyblish_menu_icon\", str(pyblish_icon_file.absolute()), 'IMAGE')\n    PREVIEW_COLLECTIONS[\"ayon\"] = pcoll\n\n    BlenderApplication.get_app()\n    for cls in classes:\n        bpy.utils.register_class(cls)\n    bpy.types.TOPBAR_MT_editor_menus.append(draw_ayon_menu)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/ops.html#client.ayon_blender.api.ops.unregister","title":"<code>unregister()</code>","text":"<p>Unregister the operators and menu.</p> Source code in <code>client/ayon_blender/api/ops.py</code> <pre><code>def unregister():\n    \"\"\"Unregister the operators and menu.\"\"\"\n\n    pcoll = PREVIEW_COLLECTIONS.pop(\"ayon\")\n    bpy.utils.previews.remove(pcoll)\n    bpy.types.TOPBAR_MT_editor_menus.remove(draw_ayon_menu)\n    for cls in reversed(classes):\n        bpy.utils.unregister_class(cls)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost","title":"<code>BlenderHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>IPublishHost</code>, <code>ILoadHost</code></p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>class BlenderHost(HostBase, IWorkfileHost, IPublishHost, ILoadHost):\n    name = \"blender\"\n\n    def get_app_information(self):\n        from ayon_core.host import ApplicationInformation\n\n        return ApplicationInformation(\n            app_name=\"Blender\",\n            app_version=bpy.app.version_string,\n        )\n\n    def install(self):\n        \"\"\"Override install method from HostBase.\n        Install Blender host functionality.\"\"\"\n        install()\n\n    def get_containers(self) -&gt; Iterator:\n        \"\"\"List containers from active Blender scene.\"\"\"\n        return ls()\n\n    def get_workfile_extensions(self) -&gt; List[str]:\n        \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n        Get workfile possible extensions.\n\n        Returns:\n            List[str]: Workfile extensions.\n        \"\"\"\n        return file_extensions()\n\n    def save_workfile(self, dst_path: str = None):\n        \"\"\"Override save_workfile method from IWorkfileHost.\n        Save currently opened workfile.\n\n        Args:\n            dst_path (str): Where the current scene should be saved. Or use\n                current path if `None` is passed.\n        \"\"\"\n        save_file(dst_path if dst_path else bpy.data.filepath)\n\n    def open_workfile(self, filepath: str):\n        \"\"\"Override open_workfile method from IWorkfileHost.\n        Open workfile at specified filepath in the host.\n\n        Args:\n            filepath (str): Path to workfile.\n        \"\"\"\n        open_file(filepath)\n\n    def get_current_workfile(self) -&gt; str:\n        \"\"\"Override get_current_workfile method from IWorkfileHost.\n        Retrieve currently opened workfile path.\n\n        Returns:\n            str: Path to currently opened workfile.\n        \"\"\"\n        return current_file()\n\n    def workfile_has_unsaved_changes(self) -&gt; bool:\n        \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n        Returns True if opened workfile has no unsaved changes.\n\n        Returns:\n            bool: True if scene is saved and False if it has unsaved\n                modifications.\n        \"\"\"\n        return has_unsaved_changes()\n\n    def work_root(self, session) -&gt; str:\n        \"\"\"Override work_root method from IWorkfileHost.\n        Modify workdir per host.\n\n        Args:\n            session (dict): Session context data.\n\n        Returns:\n            str: Path to new workdir.\n        \"\"\"\n        return work_root(session)\n\n    def get_context_data(self) -&gt; dict:\n        \"\"\"Override abstract method from IPublishHost.\n        Get global data related to creation-publishing from workfile.\n\n        Returns:\n            dict: Context data stored using 'update_context_data'.\n        \"\"\"\n        property = bpy.context.scene.get(AYON_PROPERTY)\n        if property:\n            return property.to_dict()\n        return {}\n\n    def update_context_data(self, data: dict, changes: dict):\n        \"\"\"Override abstract method from IPublishHost.\n        Store global context data to workfile.\n\n        Args:\n            data (dict): New data as are.\n            changes (dict): Only data that has been changed. Each value has\n                tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n        \"\"\"\n        bpy.context.scene[AYON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_containers","title":"<code>get_containers()</code>","text":"<p>List containers from active Blender scene.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_containers(self) -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\"\"\"\n    return ls()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Override abstract method from IPublishHost. Get global data related to creation-publishing from workfile.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Context data stored using 'update_context_data'.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_context_data(self) -&gt; dict:\n    \"\"\"Override abstract method from IPublishHost.\n    Get global data related to creation-publishing from workfile.\n\n    Returns:\n        dict: Context data stored using 'update_context_data'.\n    \"\"\"\n    property = bpy.context.scene.get(AYON_PROPERTY)\n    if property:\n        return property.to_dict()\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_current_workfile","title":"<code>get_current_workfile()</code>","text":"<p>Override get_current_workfile method from IWorkfileHost. Retrieve currently opened workfile path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to currently opened workfile.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_current_workfile(self) -&gt; str:\n    \"\"\"Override get_current_workfile method from IWorkfileHost.\n    Retrieve currently opened workfile path.\n\n    Returns:\n        str: Path to currently opened workfile.\n    \"\"\"\n    return current_file()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.get_workfile_extensions","title":"<code>get_workfile_extensions()</code>","text":"<p>Override get_workfile_extensions method from IWorkfileHost. Get workfile possible extensions.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: Workfile extensions.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_workfile_extensions(self) -&gt; List[str]:\n    \"\"\"Override get_workfile_extensions method from IWorkfileHost.\n    Get workfile possible extensions.\n\n    Returns:\n        List[str]: Workfile extensions.\n    \"\"\"\n    return file_extensions()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.install","title":"<code>install()</code>","text":"<p>Override install method from HostBase. Install Blender host functionality.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Override install method from HostBase.\n    Install Blender host functionality.\"\"\"\n    install()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.open_workfile","title":"<code>open_workfile(filepath)</code>","text":"<p>Override open_workfile method from IWorkfileHost. Open workfile at specified filepath in the host.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to workfile.</p> required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def open_workfile(self, filepath: str):\n    \"\"\"Override open_workfile method from IWorkfileHost.\n    Open workfile at specified filepath in the host.\n\n    Args:\n        filepath (str): Path to workfile.\n    \"\"\"\n    open_file(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.save_workfile","title":"<code>save_workfile(dst_path=None)</code>","text":"<p>Override save_workfile method from IWorkfileHost. Save currently opened workfile.</p> <p>Parameters:</p> Name Type Description Default <code>dst_path</code> <code>str</code> <p>Where the current scene should be saved. Or use current path if <code>None</code> is passed.</p> <code>None</code> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def save_workfile(self, dst_path: str = None):\n    \"\"\"Override save_workfile method from IWorkfileHost.\n    Save currently opened workfile.\n\n    Args:\n        dst_path (str): Where the current scene should be saved. Or use\n            current path if `None` is passed.\n    \"\"\"\n    save_file(dst_path if dst_path else bpy.data.filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Override abstract method from IPublishHost. Store global context data to workfile.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>New data as are.</p> required <code>changes</code> <code>dict</code> <p>Only data that has been changed. Each value has tuple with '(, )' value. required Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def update_context_data(self, data: dict, changes: dict):\n    \"\"\"Override abstract method from IPublishHost.\n    Store global context data to workfile.\n\n    Args:\n        data (dict): New data as are.\n        changes (dict): Only data that has been changed. Each value has\n            tuple with '(&lt;old&gt;, &lt;new&gt;)' value.\n    \"\"\"\n    bpy.context.scene[AYON_PROPERTY] = data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.work_root","title":"<code>work_root(session)</code>","text":"<p>Override work_root method from IWorkfileHost. Modify workdir per host.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>dict</code> <p>Session context data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to new workdir.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def work_root(self, session) -&gt; str:\n    \"\"\"Override work_root method from IWorkfileHost.\n    Modify workdir per host.\n\n    Args:\n        session (dict): Session context data.\n\n    Returns:\n        str: Path to new workdir.\n    \"\"\"\n    return work_root(session)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.BlenderHost.workfile_has_unsaved_changes","title":"<code>workfile_has_unsaved_changes()</code>","text":"<p>Override wokfile_has_unsaved_changes method from IWorkfileHost. Returns True if opened workfile has no unsaved changes.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if scene is saved and False if it has unsaved modifications.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def workfile_has_unsaved_changes(self) -&gt; bool:\n    \"\"\"Override wokfile_has_unsaved_changes method from IWorkfileHost.\n    Returns True if opened workfile has no unsaved changes.\n\n    Returns:\n        bool: True if scene is saved and False if it has unsaved\n            modifications.\n    \"\"\"\n    return has_unsaved_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.add_to_ayon_container","title":"<code>add_to_ayon_container(container)</code>","text":"<p>Add the container (object or collection) to the AYON container.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def add_to_ayon_container(\n    container: Union[bpy.types.Collection, bpy.types.Object]\n):\n    \"\"\"Add the container (object or collection) to the AYON container.\"\"\"\n    ayon_container = get_ayon_container()\n    if isinstance(container, bpy.types.Collection):\n        ayon_container.children.link(container)\n    elif isinstance(container, bpy.types.Object):\n        ayon_container.objects.link(container)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.containerise","title":"<code>containerise(name, namespace, nodes, context, loader=None, suffix='CON')</code>","text":"<p>Bundle <code>nodes</code> into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>nodes</code> <code>List</code> <p>Long names of nodes to containerise</p> required <code>context</code> <code>Dict</code> <p>Asset information</p> required <code>loader</code> <code>Optional[str]</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Type Description <code>Collection</code> <p>The container assembly</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def containerise(name: str,\n                 namespace: str,\n                 nodes: List,\n                 context: Dict,\n                 loader: Optional[str] = None,\n                 suffix: Optional[str] = \"CON\") -&gt; bpy.types.Collection:\n    \"\"\"Bundle `nodes` into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name: Name of resulting assembly\n        namespace: Namespace under which to host container\n        nodes: Long names of nodes to containerise\n        context: Asset information\n        loader: Name of loader used to produce this container.\n        suffix: Suffix of container, defaults to `_CON`.\n\n    Returns:\n        The container assembly\n\n    \"\"\"\n\n    node_name = get_container_name(name, namespace, context, suffix)\n    container = bpy.data.collections.new(name=node_name)\n    # Link the children nodes\n    for obj in nodes:\n        if isinstance(obj, bpy.types.Object):\n            container.objects.link(obj)\n        elif isinstance(obj, bpy.types.Collection):\n            container.children.link(obj)\n        else:\n            raise TypeError(f\"Unsupported type {type(obj)} in nodes list.\")\n\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    metadata_update(container, data)\n    add_to_ayon_container(container)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.containerise_existing","title":"<code>containerise_existing(container, name, namespace, context, loader=None, suffix='CON')</code>","text":"<p>Imprint or update container with metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>Dict</code> <p>Asset information</p> required <code>loader</code> <code>Optional[str]</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'CON'</code> <p>Returns:</p> Type Description <code>Collection</code> <p>The container assembly</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def containerise_existing(\n        container: bpy.types.Collection,\n        name: str,\n        namespace: str,\n        context: Dict,\n        loader: Optional[str] = None,\n        suffix: Optional[str] = \"CON\") -&gt; bpy.types.Collection:\n    \"\"\"Imprint or update container with metadata.\n\n    Arguments:\n        name: Name of resulting assembly\n        namespace: Namespace under which to host container\n        context: Asset information\n        loader: Name of loader used to produce this container.\n        suffix: Suffix of container, defaults to `_CON`.\n\n    Returns:\n        The container assembly\n    \"\"\"\n\n    node_name = container.name\n    if suffix:\n        node_name = f\"{node_name}_{suffix}\"\n    container.name = node_name\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    metadata_update(container, data)\n    add_to_ayon_container(container)\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.ensure_ayon_container","title":"<code>ensure_ayon_container()</code>","text":"<p>Ensure AYON_CONTAINERS exists and is ready for use.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def ensure_ayon_container() -&gt; bpy.types.Collection:\n    \"\"\"Ensure AYON_CONTAINERS exists and is ready for use.\"\"\"\n    ayon_container = bpy.data.collections.get(AYON_CONTAINERS)\n    if ayon_container:\n        return ayon_container\n\n    # Create and configure container\n    ayon_container = bpy.data.collections.new(name=AYON_CONTAINERS)\n    bpy.context.scene.collection.children.link(ayon_container)\n    ayon_container.color_tag = \"COLOR_02\"\n    ayon_container.use_fake_user = True\n    return ayon_container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.get_ayon_container","title":"<code>get_ayon_container()</code>","text":"<p>Get Ayon Container</p> <p>Returns:</p> Type Description <code>Collection</code> <p>bpy.types.Collection: Ayon containers collection</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_ayon_container() -&gt; bpy.types.Collection:\n    \"\"\"Get Ayon Container\n\n    Returns:\n         bpy.types.Collection: Ayon containers collection\n    \"\"\"\n    ayon_container = bpy.data.collections.get(AYON_CONTAINERS)\n    if ayon_container:\n        return ayon_container\n\n    # Backwards compatibility, check for legacy Avalon container\n    avalon_container = bpy.data.collections.get(AVALON_CONTAINERS)\n    if avalon_container:\n        # Convert legacy Avalon container to Ayon container\n        log.debug(\n            \"Converting legacy Avalon container to AYON container.\"\n        )\n        # Rename the collection\n        avalon_container.name = AYON_CONTAINERS\n        return avalon_container\n\n    # Create a new AYON container if it does not exist\n    return ensure_ayon_container()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.get_container_name","title":"<code>get_container_name(name, namespace, context, suffix)</code>","text":"<p>Function to get container name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>Dict</code> <p>Asset information</p> required <code>suffix</code> <code>str</code> <p>Suffix of container</p> required <p>Returns:</p> Type Description <p>The name of the container assembly</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_container_name(name: str,\n                       namespace: str,\n                       context: Dict,\n                       suffix: str):\n    \"\"\"Function to get container name\n\n    Args:\n        name: Name of resulting assembly\n        namespace: Namespace under which to host container\n        context: Asset information\n        suffix: Suffix of container\n\n    Returns:\n        The name of the container assembly\n    \"\"\"\n    node_name = f\"{context['folder']['name']}_{name}\"\n    if namespace:\n        node_name = f\"{namespace}:{node_name}\"\n    if suffix:\n        node_name = f\"{node_name}_{suffix}\"\n\n    return node_name\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.get_frame_range","title":"<code>get_frame_range(task_entity=None)</code>","text":"<p>Get the task entity's frame range and handles</p> <p>Parameters:</p> Name Type Description Default <code>task_entity</code> <code>Optional[dict]</code> <p>Task Entity. When not provided defaults to current context task.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict[str, int], None]</code> <p>Union[Dict[str, int], None]: Dictionary with frame start, frame end, handle start, handle end.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def get_frame_range(task_entity=None) -&gt; Union[Dict[str, int], None]:\n    \"\"\"Get the task entity's frame range and handles\n\n    Args:\n        task_entity (Optional[dict]): Task Entity.\n            When not provided defaults to current context task.\n\n    Returns:\n        Union[Dict[str, int], None]: Dictionary with\n            frame start, frame end, handle start, handle end.\n    \"\"\"\n    # Set frame start/end\n    if task_entity is None:\n        task_entity = get_current_task_entity(fields={\"attrib\"})\n    task_attributes = task_entity[\"attrib\"]\n    frame_start = int(task_attributes[\"frameStart\"])\n    frame_end = int(task_attributes[\"frameEnd\"])\n    handle_start = int(task_attributes[\"handleStart\"])\n    handle_end = int(task_attributes[\"handleEnd\"])\n    frame_start_handle = frame_start - handle_start\n    frame_end_handle = frame_end + handle_end\n\n    return {\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"frameStartHandle\": frame_start_handle,\n        \"frameEndHandle\": frame_end_handle,\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.install","title":"<code>install()</code>","text":"<p>Install Blender configuration for AYON.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def install():\n    \"\"\"Install Blender configuration for AYON.\"\"\"\n    sys.excepthook = pype_excepthook_handler\n\n    pyblish.api.register_host(\"blender\")\n    pyblish.api.register_plugin_path(str(PUBLISH_PATH))\n\n    register_loader_plugin_path(str(LOAD_PATH))\n    register_creator_plugin_path(str(CREATE_PATH))\n\n    if lib.get_blender_version() &lt; (5, 0, 0):\n        # User script directories had issues in custom management in older\n        # Blender releases - appending user scripts within AYON was a\n        # workaround only in-place to solve that issue.\n        lib.append_user_scripts()\n    lib.set_app_templates_path()\n\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"open\", on_open)\n    register_event_callback(\"before.save\", on_before_save)\n\n    _register_callbacks()\n\n    if not IS_HEADLESS:\n        ops.register()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List containers from active Blender scene.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Blender; once loaded they are called containers.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def ls() -&gt; Iterator:\n    \"\"\"List containers from active Blender scene.\n\n    This is the host-equivalent of api.ls(), but instead of listing assets on\n    disk, it lists assets already loaded in Blender; once loaded they are\n    called containers.\n    \"\"\"\n    container_ids = {\n        AYON_CONTAINER_ID,\n        # Backwards compatibility\n        AVALON_CONTAINER_ID\n    }\n\n    for id_type in container_ids:\n        for container in lib.lsattr(\"id\", id_type):\n            yield parse_container(container)\n\n    # Compositor nodes are not in `bpy.data` that `lib.lsattr` looks in.\n    node_tree = lib.get_scene_node_tree()\n    if node_tree:\n        for node in node_tree.nodes:\n            ayon_prop = node.get(AYON_PROPERTY)\n            if not ayon_prop:\n                avalon_prop = node.get(AVALON_PROPERTY)\n                if not avalon_prop:\n                    continue\n                else:\n                    node[AYON_PROPERTY] = avalon_prop\n                    ayon_prop = avalon_prop\n                    del node[AVALON_PROPERTY]\n\n            if ayon_prop.get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(node)\n\n    # Shader nodes are not available in a way that `lib.lsattr` can find.\n    for material in bpy.data.materials:\n        material_node_tree = material.node_tree\n        if not material_node_tree:\n            continue\n\n        for shader_node in material_node_tree.nodes:\n            ayon_shader_node = get_ayon_property(shader_node)\n            if not ayon_shader_node:\n                continue\n\n            if ayon_shader_node.get(\"id\") not in container_ids:\n                continue\n\n            yield parse_container(shader_node)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.metadata_update","title":"<code>metadata_update(node, data)</code>","text":"<p>Imprint the node with metadata.</p> <p>Existing metadata will be updated.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def metadata_update(node: bpy.types.bpy_struct_meta_idprop, data: Dict):\n    \"\"\"Imprint the node with metadata.\n\n    Existing metadata will be updated.\n    \"\"\"\n\n    if not node.get(AYON_PROPERTY):\n        node[AYON_PROPERTY] = dict()\n    for key, value in data.items():\n        if value is None:\n            continue\n        node[AYON_PROPERTY][key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.on_before_save","title":"<code>on_before_save(event)</code>","text":"<p>Handle the event before saving a Blender file.</p> <p>When saving to a new scene name, e.g. on incrementing the workfile then update the render paths to match the new scene name by replacing the old scene name with the new one in all render paths.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def on_before_save(event):\n    \"\"\"Handle the event before saving a Blender file.\n\n    When saving to a new scene name, e.g. on incrementing the workfile then\n    update the render paths to match the new scene name by replacing the old\n    scene name with the new one in all render paths.\n    \"\"\"\n    blend_path_before: str = bpy.data.filepath\n    blend_path_after: str = event.get(\"filename\")\n\n    if not blend_path_before:\n        # Saving from a new unsaved file, no need to check for changes.\n        return\n\n    blend_name_before: str = os.path.splitext(\n        os.path.basename(blend_path_before))[0]\n    blend_name_after: str = os.path.splitext(\n        os.path.basename(blend_path_after))[0]\n    if blend_name_before != blend_name_after:\n        print(f\"Detected scene name change from {blend_name_before} to \"\n              f\"{blend_name_after}\")\n        # TODO: We may want to allow disabling this feature, especially after\n        #  Blender 4.5+ supporting the `{blend_name}` in templates in render\n        #  paths to avoid needing to hardcode the blender scene filename into\n        #  those paths.\n        # Update any render paths if they previously contained the scene name\n        # Warning: if the scene name is `a` before and now `helloworld` then\n        #  this may easily get out of hand by turning `asset` into\n        #  `helloworldsset`, but since filenames tend to be longer and\n        #  contain version numbers, this is not expected to happen often.\n        search_replace_render_paths(blend_name_before, blend_name_after)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.parse_container","title":"<code>parse_container(container, validate=True)</code>","text":"<p>Return the container node's full container data.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Collection</code> <p>A container node name.</p> required <code>validate</code> <code>bool</code> <p>turn the validation for the container on or off</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict</code> <p>The container schema data for this container node.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def parse_container(container: bpy.types.Collection,\n                    validate: bool = True) -&gt; Dict:\n    \"\"\"Return the container node's full container data.\n\n    Args:\n        container: A container node name.\n        validate: turn the validation for the container on or off\n\n    Returns:\n        The container schema data for this container node.\n\n    \"\"\"\n\n    data = lib.read(container)\n\n    # Append transient data\n    data[\"objectName\"] = container.name\n    data[\"node\"] = container  # store parsed object for easy access in loader\n\n    if validate:\n        schema.validate(data)\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.publish","title":"<code>publish()</code>","text":"<p>Shorthand to publish from within host.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def publish():\n    \"\"\"Shorthand to publish from within host.\"\"\"\n\n    return pyblish.util.publish()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/pipeline.html#client.ayon_blender.api.pipeline.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall Blender configuration for AYON.</p> Source code in <code>client/ayon_blender/api/pipeline.py</code> <pre><code>def uninstall():\n    \"\"\"Uninstall Blender configuration for AYON.\"\"\"\n    sys.excepthook = ORIGINAL_EXCEPTHOOK\n\n    pyblish.api.deregister_host(\"blender\")\n    pyblish.api.deregister_plugin_path(str(PUBLISH_PATH))\n\n    deregister_loader_plugin_path(str(LOAD_PATH))\n    deregister_creator_plugin_path(str(CREATE_PATH))\n\n    if not IS_HEADLESS:\n        ops.unregister()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html","title":"plugin","text":"<p>Shared functionality for pipeline plugins for Blender.</p>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator","title":"<code>BlenderCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Base class for Blender Creator plug-ins.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>class BlenderCreator(Creator):\n    \"\"\"Base class for Blender Creator plug-ins.\"\"\"\n    defaults = ['Main']\n\n    settings_category = \"blender\"\n    create_as_asset_group = False\n\n    @staticmethod\n    def cache_instance_data(shared_data):\n        \"\"\"Cache instances for Creators shared data.\n\n        Create `blender_cached_instances` key when needed in shared data and\n        fill it with all collected instances from the scene under its\n        respective creator identifiers.\n\n        If legacy instances are detected in the scene, create\n        `blender_cached_legacy_instances` key and fill it with\n        all legacy products from this family as a value.  # key or value?\n\n        Args:\n            shared_data(Dict[str, Any]): Shared data.\n\n        \"\"\"\n        if not shared_data.get('blender_cached_instances'):\n            cache = {}\n            cache_legacy = {}\n            convert_avalon_instances()\n            ayon_instances = bpy.data.collections.get(AYON_INSTANCES)\n            ayon_instance_objs = (\n                ayon_instances.objects if ayon_instances else []\n            )\n\n            # Consider any node tree objects as well\n            node_tree_objects = []\n            node_tree = get_scene_node_tree()\n            if node_tree:\n                node_tree_objects = node_tree.nodes\n\n            for obj_or_col in itertools.chain(\n                    ayon_instance_objs,\n                    bpy.data.collections,\n                    node_tree_objects\n            ):\n                ayon_prop = get_ayon_property(obj_or_col)\n                if not ayon_prop:\n                    continue\n\n                if ayon_prop.get('id') not in {\n                    AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n                }:\n                    continue\n\n                creator_id = ayon_prop.get(\"creator_identifier\")\n                if \"openpype\" in creator_id:\n                    creator_id = creator_id.replace(\"openpype\", \"ayon\")\n                    ayon_prop[\"creator_identifier\"] = creator_id\n\n                if creator_id:\n                    # Creator instance\n                    cache.setdefault(creator_id, []).append(obj_or_col)\n                else:\n                    # Legacy creator instance\n                    family = ayon_prop.get('family')\n                    cache_legacy.setdefault(family, []).append(obj_or_col)\n\n            shared_data[\"blender_cached_instances\"] = cache\n            shared_data[\"blender_cached_legacy_instances\"] = cache_legacy\n        return shared_data\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        \"\"\"Override abstract method from Creator.\n        Create new instance and store it.\n\n        Args:\n            product_name (str): Product name of created instance.\n            instance_data (dict): Instance base data.\n            pre_create_data (dict): Data based on pre creation attributes.\n                Those may affect how creator works.\n        \"\"\"\n        # Get Instance Container or create it if it does not exist\n        ayon_instances = self._ensure_ayon_instances_collection()\n\n        # Create asset group\n        folder_name = instance_data[\"folderPath\"].split(\"/\")[-1]\n\n        name = prepare_scene_name(folder_name, product_name)\n        if self.create_as_asset_group:\n            # Create instance as empty\n            instance_node = bpy.data.objects.new(name=name, object_data=None)\n            instance_node.empty_display_type = 'SINGLE_ARROW'\n            ayon_instances.objects.link(instance_node)\n        else:\n            # Create instance collection\n            instance_node = bpy.data.collections.new(name=name)\n            ayon_instances.children.link(instance_node)\n\n        self.set_instance_data(product_name, instance_data)\n\n        # Mimic families override like `self.read` does\n        instance_data[\"families\"] = self.get_publish_families()\n\n        instance = CreatedInstance(\n            self.product_type, product_name, instance_data, self,\n            transient_data={\"instance_node\": instance_node}\n        )\n        self._add_instance_to_context(instance)\n\n        self.imprint(instance_node, instance_data)\n\n        return instance_node\n\n    def collect_instances(self):\n        \"\"\"Override abstract method from BlenderCreator.\n        Collect existing instances related to this creator plugin.\"\"\"\n\n        # Cache instances in shared data\n        self.cache_instance_data(self.collection_shared_data)\n\n        # Get cached instances\n        cached_instances = self.collection_shared_data.get(\n            \"blender_cached_instances\"\n        )\n        if not cached_instances:\n            return\n\n        # Process only instances that were created by this creator\n        for instance_node in cached_instances.get(self.identifier, []):\n            instance_data = self.read(instance_node)\n\n            # Create instance object from existing data\n            instance = CreatedInstance.from_existing(\n                instance_data=instance_data,\n                creator=self,\n                transient_data={\"instance_node\": instance_node}\n            )\n\n            # Add instance to create context\n            self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        \"\"\"Override abstract method from BlenderCreator.\n        Store changes of existing instances so they can be recollected.\n\n        Args:\n            update_list(List[UpdateData]): Changed instances\n                and their changes, as a list of tuples.\n        \"\"\"\n\n        for created_instance, changes in update_list:\n            data = created_instance.data_to_store()\n            node = created_instance.transient_data[\"instance_node\"]\n            if not node:\n                # We can't update if we don't know the node\n                self.log.error(\n                    f\"Unable to update instance {created_instance} \"\n                    f\"without instance node.\"\n                )\n                return\n\n            # Rename the instance node in the scene if product\n            #   or folder changed.\n            # Do not rename the instance if the family is workfile, as the\n            # workfile instance is included in the AYON_CONTAINER collection.\n            if (\n                \"productName\" in changes.changed_keys\n                or \"folderPath\" in changes.changed_keys\n            ) and created_instance.product_type != \"workfile\":\n                folder_name = data[\"folderPath\"].split(\"/\")[-1]\n                name = prepare_scene_name(\n                    folder_name, data[\"productName\"]\n                )\n                node.name = name\n\n            self.imprint(node, data)\n\n    def remove_instances(self, instances: List[CreatedInstance]):\n        for instance in instances:\n            node = instance.transient_data[\"instance_node\"]\n\n            # Remove collection node and its children\n            if isinstance(node, bpy.types.Collection):\n                # Remove recursively linked child collections and objects\n                for child in node.children_recursive:\n                     if isinstance(child, bpy.types.Object):\n                        if len(child.users_collection) == 1:\n                            if child.name not in bpy.context.scene.collection:\n                                bpy.context.scene.collection.objects.link(child)\n                # Remove directly linked objects\n                for obj in node.objects:\n                    if len(obj.users_collection) == 1:\n                        if obj.name not in bpy.context.scene.collection.objects:\n                            bpy.context.scene.collection.objects.link(obj)\n\n                bpy.data.collections.remove(node)\n\n            # Remove object node\n            elif isinstance(node, bpy.types.Object):\n                bpy.data.objects.remove(node)\n\n            # Remove compositor node\n            elif isinstance(node, bpy.types.CompositorNode):\n                node_tree = get_scene_node_tree()\n                node_tree.nodes.remove(node)\n\n            self._remove_instance_from_context(instance)\n\n    def set_instance_data(\n        self,\n        product_name: str,\n        instance_data: dict\n    ):\n        \"\"\"Fill instance data with required items.\n\n        Args:\n            product_name (str): Product name of created instance.\n            instance_data (dict): Instance base data.\n            instance_node (bpy.types.ID): Instance node in blender scene.\n        \"\"\"\n        if not instance_data:\n            instance_data = {}\n\n        instance_data.update(\n            {\n                \"id\": AYON_INSTANCE_ID,\n                \"creator_identifier\": self.identifier,\n                \"productName\": product_name,\n            }\n        )\n\n    def _ensure_ayon_instances_collection(self) -&gt; bpy.types.Collection:\n        \"\"\"Create AYON Instances collections that contains created instances.\n\n        Returns:\n            bpy.types.Collection: AYON Instances collection\n        \"\"\"\n        node = bpy.data.collections.get(AYON_INSTANCES)\n        if node:\n            # Already exists, return it\n            return node\n\n        node = bpy.data.collections.new(AYON_INSTANCES)\n        node.color_tag = \"COLOR_04\"\n        node.use_fake_user = True\n        bpy.context.scene.collection.children.link(node)\n        return node\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\"use_selection\",\n                    label=\"Use selection\",\n                    default=True)\n        ]\n\n    def imprint(self, node, data: dict):\n        \"\"\"Imprint data to the instance node.\n\n        This can be overridden by a sub-class to store certain data of the\n        instance in a different way, e.g. in a custom property or the 'mute'\n        state of a node.\n        \"\"\"\n        data.pop(\"families\", None)\n        imprint(node, data)\n\n    def read(self, node) -&gt; dict:\n        \"\"\"Read data from the instance node.\n\n        The `data` dictionary is the readily stored\n        \"\"\"\n        ayon_property = node.get(AYON_PROPERTY)\n        if not ayon_property:\n            return {}\n\n        data = ayon_property.to_dict()\n        data[\"families\"] = self.get_publish_families()\n        return data\n\n    def get_publish_families(self) -&gt; list[str]:\n        return [self.product_type]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.cache_instance_data","title":"<code>cache_instance_data(shared_data)</code>  <code>staticmethod</code>","text":"<p>Cache instances for Creators shared data.</p> <p>Create <code>blender_cached_instances</code> key when needed in shared data and fill it with all collected instances from the scene under its respective creator identifiers.</p> <p>If legacy instances are detected in the scene, create <code>blender_cached_legacy_instances</code> key and fill it with all legacy products from this family as a value.  # key or value?</p> <p>Parameters:</p> Name Type Description Default <code>shared_data</code> <code>Dict[str, Any]</code> <p>Shared data.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>@staticmethod\ndef cache_instance_data(shared_data):\n    \"\"\"Cache instances for Creators shared data.\n\n    Create `blender_cached_instances` key when needed in shared data and\n    fill it with all collected instances from the scene under its\n    respective creator identifiers.\n\n    If legacy instances are detected in the scene, create\n    `blender_cached_legacy_instances` key and fill it with\n    all legacy products from this family as a value.  # key or value?\n\n    Args:\n        shared_data(Dict[str, Any]): Shared data.\n\n    \"\"\"\n    if not shared_data.get('blender_cached_instances'):\n        cache = {}\n        cache_legacy = {}\n        convert_avalon_instances()\n        ayon_instances = bpy.data.collections.get(AYON_INSTANCES)\n        ayon_instance_objs = (\n            ayon_instances.objects if ayon_instances else []\n        )\n\n        # Consider any node tree objects as well\n        node_tree_objects = []\n        node_tree = get_scene_node_tree()\n        if node_tree:\n            node_tree_objects = node_tree.nodes\n\n        for obj_or_col in itertools.chain(\n                ayon_instance_objs,\n                bpy.data.collections,\n                node_tree_objects\n        ):\n            ayon_prop = get_ayon_property(obj_or_col)\n            if not ayon_prop:\n                continue\n\n            if ayon_prop.get('id') not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                continue\n\n            creator_id = ayon_prop.get(\"creator_identifier\")\n            if \"openpype\" in creator_id:\n                creator_id = creator_id.replace(\"openpype\", \"ayon\")\n                ayon_prop[\"creator_identifier\"] = creator_id\n\n            if creator_id:\n                # Creator instance\n                cache.setdefault(creator_id, []).append(obj_or_col)\n            else:\n                # Legacy creator instance\n                family = ayon_prop.get('family')\n                cache_legacy.setdefault(family, []).append(obj_or_col)\n\n        shared_data[\"blender_cached_instances\"] = cache\n        shared_data[\"blender_cached_legacy_instances\"] = cache_legacy\n    return shared_data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Override abstract method from BlenderCreator. Collect existing instances related to this creator plugin.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Override abstract method from BlenderCreator.\n    Collect existing instances related to this creator plugin.\"\"\"\n\n    # Cache instances in shared data\n    self.cache_instance_data(self.collection_shared_data)\n\n    # Get cached instances\n    cached_instances = self.collection_shared_data.get(\n        \"blender_cached_instances\"\n    )\n    if not cached_instances:\n        return\n\n    # Process only instances that were created by this creator\n    for instance_node in cached_instances.get(self.identifier, []):\n        instance_data = self.read(instance_node)\n\n        # Create instance object from existing data\n        instance = CreatedInstance.from_existing(\n            instance_data=instance_data,\n            creator=self,\n            transient_data={\"instance_node\": instance_node}\n        )\n\n        # Add instance to create context\n        self._add_instance_to_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Override abstract method from Creator. Create new instance and store it.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Product name of created instance.</p> required <code>instance_data</code> <code>dict</code> <p>Instance base data.</p> required <code>pre_create_data</code> <code>dict</code> <p>Data based on pre creation attributes. Those may affect how creator works.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def create(\n    self, product_name: str, instance_data: dict, pre_create_data: dict\n):\n    \"\"\"Override abstract method from Creator.\n    Create new instance and store it.\n\n    Args:\n        product_name (str): Product name of created instance.\n        instance_data (dict): Instance base data.\n        pre_create_data (dict): Data based on pre creation attributes.\n            Those may affect how creator works.\n    \"\"\"\n    # Get Instance Container or create it if it does not exist\n    ayon_instances = self._ensure_ayon_instances_collection()\n\n    # Create asset group\n    folder_name = instance_data[\"folderPath\"].split(\"/\")[-1]\n\n    name = prepare_scene_name(folder_name, product_name)\n    if self.create_as_asset_group:\n        # Create instance as empty\n        instance_node = bpy.data.objects.new(name=name, object_data=None)\n        instance_node.empty_display_type = 'SINGLE_ARROW'\n        ayon_instances.objects.link(instance_node)\n    else:\n        # Create instance collection\n        instance_node = bpy.data.collections.new(name=name)\n        ayon_instances.children.link(instance_node)\n\n    self.set_instance_data(product_name, instance_data)\n\n    # Mimic families override like `self.read` does\n    instance_data[\"families\"] = self.get_publish_families()\n\n    instance = CreatedInstance(\n        self.product_type, product_name, instance_data, self,\n        transient_data={\"instance_node\": instance_node}\n    )\n    self._add_instance_to_context(instance)\n\n    self.imprint(instance_node, instance_data)\n\n    return instance_node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.imprint","title":"<code>imprint(node, data)</code>","text":"<p>Imprint data to the instance node.</p> <p>This can be overridden by a sub-class to store certain data of the instance in a different way, e.g. in a custom property or the 'mute' state of a node.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def imprint(self, node, data: dict):\n    \"\"\"Imprint data to the instance node.\n\n    This can be overridden by a sub-class to store certain data of the\n    instance in a different way, e.g. in a custom property or the 'mute'\n    state of a node.\n    \"\"\"\n    data.pop(\"families\", None)\n    imprint(node, data)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.read","title":"<code>read(node)</code>","text":"<p>Read data from the instance node.</p> <p>The <code>data</code> dictionary is the readily stored</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def read(self, node) -&gt; dict:\n    \"\"\"Read data from the instance node.\n\n    The `data` dictionary is the readily stored\n    \"\"\"\n    ayon_property = node.get(AYON_PROPERTY)\n    if not ayon_property:\n        return {}\n\n    data = ayon_property.to_dict()\n    data[\"families\"] = self.get_publish_families()\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.set_instance_data","title":"<code>set_instance_data(product_name, instance_data)</code>","text":"<p>Fill instance data with required items.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>Product name of created instance.</p> required <code>instance_data</code> <code>dict</code> <p>Instance base data.</p> required <code>instance_node</code> <code>ID</code> <p>Instance node in blender scene.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def set_instance_data(\n    self,\n    product_name: str,\n    instance_data: dict\n):\n    \"\"\"Fill instance data with required items.\n\n    Args:\n        product_name (str): Product name of created instance.\n        instance_data (dict): Instance base data.\n        instance_node (bpy.types.ID): Instance node in blender scene.\n    \"\"\"\n    if not instance_data:\n        instance_data = {}\n\n    instance_data.update(\n        {\n            \"id\": AYON_INSTANCE_ID,\n            \"creator_identifier\": self.identifier,\n            \"productName\": product_name,\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderCreator.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Override abstract method from BlenderCreator. Store changes of existing instances so they can be recollected.</p> <p>Parameters:</p> Name Type Description Default <code>update_list</code> <code>List[UpdateData]</code> <p>Changed instances and their changes, as a list of tuples.</p> required Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Override abstract method from BlenderCreator.\n    Store changes of existing instances so they can be recollected.\n\n    Args:\n        update_list(List[UpdateData]): Changed instances\n            and their changes, as a list of tuples.\n    \"\"\"\n\n    for created_instance, changes in update_list:\n        data = created_instance.data_to_store()\n        node = created_instance.transient_data[\"instance_node\"]\n        if not node:\n            # We can't update if we don't know the node\n            self.log.error(\n                f\"Unable to update instance {created_instance} \"\n                f\"without instance node.\"\n            )\n            return\n\n        # Rename the instance node in the scene if product\n        #   or folder changed.\n        # Do not rename the instance if the family is workfile, as the\n        # workfile instance is included in the AYON_CONTAINER collection.\n        if (\n            \"productName\" in changes.changed_keys\n            or \"folderPath\" in changes.changed_keys\n        ) and created_instance.product_type != \"workfile\":\n            folder_name = data[\"folderPath\"].split(\"/\")[-1]\n            name = prepare_scene_name(\n                folder_name, data[\"productName\"]\n            )\n            node.name = name\n\n        self.imprint(node, data)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader","title":"<code>BlenderLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic AssetLoader for Blender</p> <p>This will implement the basic logic for linking/appending assets into another Blender scene.</p> <p>The <code>update</code> method should be implemented by a subclass, because it's different for different types (e.g. model, rig, animation, etc.).</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>class BlenderLoader(LoaderPlugin):\n    \"\"\"A basic AssetLoader for Blender\n\n    This will implement the basic logic for linking/appending assets\n    into another Blender scene.\n\n    The `update` method should be implemented by a subclass, because\n    it's different for different types (e.g. model, rig, animation,\n    etc.).\n    \"\"\"\n    settings_category = \"blender\"\n\n    @staticmethod\n    def _get_instance_empty(instance_name: str, nodes: List) -&gt; Optional[bpy.types.Object]:\n        \"\"\"Get the 'instance empty' that holds the collection instance.\"\"\"\n        for node in nodes:\n            if not isinstance(node, bpy.types.Object):\n                continue\n            if (node.type == 'EMPTY' and node.instance_type == 'COLLECTION'\n                    and node.instance_collection and node.name == instance_name):\n                return node\n        return None\n\n    @staticmethod\n    def _get_instance_collection(instance_name: str, nodes: List) -&gt; Optional[bpy.types.Collection]:\n        \"\"\"Get the 'instance collection' (container) for this asset.\"\"\"\n        for node in nodes:\n            if not isinstance(node, bpy.types.Collection):\n                continue\n            if node.name == instance_name:\n                return node\n        return None\n\n    @staticmethod\n    def _get_library_from_container(container: bpy.types.Collection) -&gt; bpy.types.Library:\n        \"\"\"Find the library file from the container.\n\n        It traverses the objects from this collection, checks if there is only\n        1 library from which the objects come from and returns the library.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        assert not container.children, \"Nested collections are not supported.\"\n        assert container.objects, \"The collection doesn't contain any objects.\"\n        libraries = set()\n        for obj in container.objects:\n            assert obj.library, f\"'{obj.name}' is not linked.\"\n            libraries.add(obj.library)\n\n        assert len(\n            libraries) == 1, \"'{container.name}' contains objects from more then 1 library.\"\n\n        return list(libraries)[0]\n\n    def process_asset(self,\n                      context: dict,\n                      name: str,\n                      namespace: Optional[str] = None,\n                      options: Optional[Dict] = None):\n        \"\"\"Must be implemented by a subclass\"\"\"\n        raise NotImplementedError(\"Must be implemented by a subclass\")\n\n    def load(self,\n             context: dict,\n             name: Optional[str] = None,\n             namespace: Optional[str] = None,\n             options: Optional[Dict] = None) -&gt; Optional[bpy.types.Collection]:\n        \"\"\" Run the loader on Blender main thread\"\"\"\n        mti = MainThreadItem(self._load, context, name, namespace, options)\n        execute_in_main_thread(mti)\n\n    def _load(self,\n              context: dict,\n              name: Optional[str] = None,\n              namespace: Optional[str] = None,\n              options: Optional[Dict] = None\n    ) -&gt; Optional[bpy.types.Collection]:\n        \"\"\"Load asset via database\n\n        Arguments:\n            context: Full parenthood of representation to load\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            options: Additional settings dictionary\n        \"\"\"\n        # TODO: make it possible to add the asset several times by\n        # just re-using the collection\n        filepath = self.filepath_from_context(context)\n        assert Path(filepath).exists(), f\"{filepath} doesn't exist.\"\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        unique_number = get_unique_number(\n            folder_name, product_name\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n        name = name or prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n\n        nodes = self.process_asset(\n            context=context,\n            name=name,\n            namespace=namespace,\n            options=options,\n        )\n\n        # Only containerise if anything was loaded by the Loader.\n        if not nodes:\n            return None\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Must be implemented by a subclass\"\"\"\n        raise NotImplementedError(\"Must be implemented by a subclass\")\n\n    def update(self, container: Dict, context: Dict):\n        \"\"\" Run the update on Blender main thread\"\"\"\n        mti = MainThreadItem(self.exec_update, container, context)\n        execute_in_main_thread(mti)\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Must be implemented by a subclass\"\"\"\n        raise NotImplementedError(\"Must be implemented by a subclass\")\n\n    def remove(self, container: Dict) -&gt; bool:\n        \"\"\" Run the remove on Blender main thread\"\"\"\n        mti = MainThreadItem(self.exec_remove, container)\n        execute_in_main_thread(mti)\n\n    def switch(self, container, context):\n        # Support switch in scene inventory\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Must be implemented by a subclass</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Must be implemented by a subclass\"\"\"\n    raise NotImplementedError(\"Must be implemented by a subclass\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Must be implemented by a subclass</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Must be implemented by a subclass\"\"\"\n    raise NotImplementedError(\"Must be implemented by a subclass\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Run the loader on Blender main thread</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def load(self,\n         context: dict,\n         name: Optional[str] = None,\n         namespace: Optional[str] = None,\n         options: Optional[Dict] = None) -&gt; Optional[bpy.types.Collection]:\n    \"\"\" Run the loader on Blender main thread\"\"\"\n    mti = MainThreadItem(self._load, context, name, namespace, options)\n    execute_in_main_thread(mti)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Must be implemented by a subclass</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def process_asset(self,\n                  context: dict,\n                  name: str,\n                  namespace: Optional[str] = None,\n                  options: Optional[Dict] = None):\n    \"\"\"Must be implemented by a subclass\"\"\"\n    raise NotImplementedError(\"Must be implemented by a subclass\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.remove","title":"<code>remove(container)</code>","text":"<p>Run the remove on Blender main thread</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def remove(self, container: Dict) -&gt; bool:\n    \"\"\" Run the remove on Blender main thread\"\"\"\n    mti = MainThreadItem(self.exec_remove, container)\n    execute_in_main_thread(mti)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.BlenderLoader.update","title":"<code>update(container, context)</code>","text":"<p>Run the update on Blender main thread</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def update(self, container: Dict, context: Dict):\n    \"\"\" Run the update on Blender main thread\"\"\"\n    mti = MainThreadItem(self.exec_update, container, context)\n    execute_in_main_thread(mti)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.create_blender_context","title":"<code>create_blender_context(active=None, selected=None, window=None)</code>","text":"<p>Create a new Blender context. If an object is passed as parameter, it is set as selected and active.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def create_blender_context(active: Optional[bpy.types.Object] = None,\n                           selected: Optional[bpy.types.Object] = None,\n                           window: Optional[bpy.types.Window] = None):\n    \"\"\"Create a new Blender context. If an object is passed as\n    parameter, it is set as selected and active.\n    \"\"\"\n\n    if not isinstance(selected, list):\n        selected = [selected]\n\n    override_context = bpy.context.copy()\n\n    windows = [window] if window else bpy.context.window_manager.windows\n\n    for win in windows:\n        for area in win.screen.areas:\n            if area.type == 'VIEW_3D':\n                for region in area.regions:\n                    if region.type == 'WINDOW':\n                        override_context['window'] = win\n                        override_context['screen'] = win.screen\n                        override_context['area'] = area\n                        override_context['region'] = region\n                        override_context['scene'] = bpy.context.scene\n                        override_context['active_object'] = active\n                        override_context['selected_objects'] = selected\n                        return override_context\n    raise Exception(\"Could not create a custom Blender context.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.deselect_all","title":"<code>deselect_all()</code>","text":"<p>Deselect all objects in the scene.</p> <p>Blender gives context error if trying to deselect object that it isn't in object mode.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def deselect_all():\n    \"\"\"Deselect all objects in the scene.\n\n    Blender gives context error if trying to deselect object that it isn't\n    in object mode.\n    \"\"\"\n    modes = []\n    active = bpy.context.view_layer.objects.active\n\n    for obj in bpy.data.objects:\n        if obj.mode != 'OBJECT':\n            modes.append((obj, obj.mode))\n            bpy.context.view_layer.objects.active = obj\n            context_override = create_blender_context(active=obj)\n            with bpy.context.temp_override(**context_override):\n                bpy.ops.object.mode_set(mode='OBJECT')\n\n    context_override = create_blender_context()\n    with bpy.context.temp_override(**context_override):\n        bpy.ops.object.select_all(action='DESELECT')\n\n    for p in modes:\n        bpy.context.view_layer.objects.active = p[0]\n        context_override = create_blender_context(active=p[0])\n        with bpy.context.temp_override(**context_override):\n            bpy.ops.object.mode_set(mode=p[1])\n\n    bpy.context.view_layer.objects.active = active\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.get_parent_collection","title":"<code>get_parent_collection(collection)</code>","text":"<p>Get the parent of the input collection</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def get_parent_collection(collection):\n    \"\"\"Get the parent of the input collection\"\"\"\n    check_list = [bpy.context.scene.collection]\n\n    for c in check_list:\n        if collection.name in c.children.keys():\n            return c\n        check_list.extend(c.children)\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.get_unique_number","title":"<code>get_unique_number(folder_name, product_name)</code>","text":"<p>Return a unique number based on the folder name.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def get_unique_number(\n    folder_name: str, product_name: str\n) -&gt; str:\n    \"\"\"Return a unique number based on the folder name.\"\"\"\n    ayon_container = get_ayon_container()\n    # Check the names of both object and collection containers\n    obj_asset_groups = ayon_container.objects\n    obj_group_names = {\n        c.name for c in obj_asset_groups\n        if c.type == 'EMPTY' and c.get(AYON_PROPERTY)}\n    coll_asset_groups = ayon_container.children\n    coll_group_names = {\n        c.name for c in coll_asset_groups\n        if c.get(AYON_PROPERTY)}\n    container_names = obj_group_names.union(coll_group_names)\n    count = 1\n    name = f\"{folder_name}_{count:0&gt;2}_{product_name}\"\n    while name in container_names:\n        count += 1\n        name = f\"{folder_name}_{count:0&gt;2}_{product_name}\"\n    return f\"{count:0&gt;2}\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin.html#client.ayon_blender.api.plugin.prepare_scene_name","title":"<code>prepare_scene_name(folder_name, product_name, namespace=None)</code>","text":"<p>Return a consistent name for an asset.</p> Source code in <code>client/ayon_blender/api/plugin.py</code> <pre><code>def prepare_scene_name(\n    folder_name: str, product_name: str, namespace: Optional[str] = None\n) -&gt; str:\n    \"\"\"Return a consistent name for an asset.\"\"\"\n    name = f\"{folder_name}\"\n    if namespace:\n        name = f\"{name}_{namespace}\"\n    name = f\"{name}_{product_name}\"\n\n    # Blender name for a collection or object cannot be longer than 63\n    # characters. If the name is longer, it will raise an error.\n    # The truncation will only happen for blender version elder than 5.0\n    if get_blender_version() &lt; (5, 0, 0) and len(name) &gt; 63:\n        raise ValueError(f\"Scene name '{name}' would be too long.\")\n\n    return name\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin_load.html","title":"plugin_load","text":""},{"location":"autoapi/client/ayon_blender/api/plugin_load.html#client.ayon_blender.api.plugin_load.add_override","title":"<code>add_override(loaded_collection)</code>","text":"<p>Add overrides for the loaded armatures.</p> Source code in <code>client/ayon_blender/api/plugin_load.py</code> <pre><code>def add_override(\n    loaded_collection: bpy.types.Collection,\n) -&gt; bpy.types.Collection:\n    \"\"\"Add overrides for the loaded armatures.\"\"\"\n    overridden_collections = list(\n        get_overridden_collections_from_reference_collection(loaded_collection)\n    )\n    context = bpy.context\n    scene = context.scene\n    loaded_objects = loaded_collection.all_objects\n    # This slightly convoluted way of running the operator seems necessary to\n    # have it work reliably for more than 1 rig on both Linux and Windows.\n    # Giving it a 'random' object from the collection seems to override\n    # everything contained in the loaded collection.\n    context.view_layer.objects.active = loaded_objects[0]\n\n    from .plugin import create_blender_context  # todo: move import\n    operator_context = create_blender_context(\n        active=loaded_objects[0],\n        selected=loaded_objects\n    )\n\n    # https://blender.stackexchange.com/questions/289245/how-to-make-a-blender-library-override-in-python  # noqa\n    # https://docs.blender.org/api/current/bpy.types.ID.html#bpy.types.ID.override_hierarchy_create  # noqa\n    if bpy.app.version[0] &gt;= 4:\n        with bpy.context.temp_override(**operator_context):\n            loaded_collection.override_hierarchy_create(\n                scene, context.view_layer, do_fully_editable=True\n            )\n\n    scene.collection.children.unlink(loaded_collection)\n\n    if overridden_collections:\n        local_collection = get_local_collection(\n            overridden_collections,\n            loaded_collection,\n        )\n    else:\n        local_collection = loaded_collection\n\n    return local_collection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin_load.html#client.ayon_blender.api.plugin_load.get_local_collection","title":"<code>get_local_collection(overridden_collections, loaded_collection)</code>","text":"<p>Get the local (overridden) collection.</p> <p>To get it we check all collections with a library override and check if they have the loaded collection as their reference. If a collection is not in the provided (known) override collections, we assume it's the newly created one.</p> Source code in <code>client/ayon_blender/api/plugin_load.py</code> <pre><code>def get_local_collection(\n    overridden_collections: list[bpy.types.Collection],\n    loaded_collection: bpy.types.Collection,\n) -&gt; bpy.types.Collection:\n    \"\"\"Get the local (overridden) collection.\n\n    To get it we check all collections with a library override and check if\n    they have the loaded collection as their reference. If a collection is\n    not in the provided (known) override collections, we assume it's the newly\n    created one.\n    \"\"\"\n    local_collections: set[bpy.types.Collection] = set()\n    for collection in get_overridden_collections_from_reference_collection(\n        loaded_collection\n    ):\n        if collection not in overridden_collections:\n            local_collections.add(collection)\n    if len(local_collections) != 1:\n        raise RuntimeError(\"Could not find the overridden collection.\")\n\n    return local_collections.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin_load.html#client.ayon_blender.api.plugin_load.get_overridden_collections_from_reference_collection","title":"<code>get_overridden_collections_from_reference_collection(reference_collection)</code>","text":"<p>Get collections that are overridden versions of the reference collection.</p> <p>Yields:</p> Type Description <code>Collection</code> <p>All collections that have an override library and have the</p> <code>Collection</code> <p><code>reference_collection</code> collection as reference.</p> Source code in <code>client/ayon_blender/api/plugin_load.py</code> <pre><code>def get_overridden_collections_from_reference_collection(\n    reference_collection: bpy.types.Collection,\n) -&gt; Generator[bpy.types.Collection, None, None]:\n    \"\"\"Get collections that are overridden versions of the reference collection.\n\n    Yields:\n        All collections that have an override library and have the\n        `reference_collection` collection as reference.\n    \"\"\"\n    for collection in bpy.data.collections:\n        if not collection.override_library:\n            continue\n        if collection.override_library.reference == reference_collection:\n            yield collection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/plugin_load.html#client.ayon_blender.api.plugin_load.load_collection","title":"<code>load_collection(filepath, link=True, lib_container_name=None, group_name=None)</code>","text":"<p>Load a collection to the scene.</p> Source code in <code>client/ayon_blender/api/plugin_load.py</code> <pre><code>def load_collection(\n    filepath,\n    link=True,\n    lib_container_name = None,\n    group_name = None\n) -&gt; bpy.types.Collection:\n    \"\"\"Load a collection to the scene.\"\"\"\n    loaded_containers = []\n    asset_container = get_collection(group_name)\n    with bpy.data.libraries.load(filepath, link=link, relative=False) as (\n        data_from,\n        data_to,\n    ):\n        for attr in dir(data_to):\n            setattr(data_to, attr, getattr(data_from, attr))\n\n    for coll in data_to.collections:\n        if coll is not None and coll.name not in asset_container.children:\n            asset_container.children.link(coll)\n\n    for obj in data_to.objects:\n        if obj is not None and obj.name not in asset_container.objects:\n            asset_container.objects.link(obj)\n\n    loaded_containers = [asset_container]\n\n    if len(loaded_containers) != 1:\n        for loaded_container in loaded_containers:\n            bpy.data.collections.remove(loaded_container)\n        raise LoadError(\n            \"More then 1 'container' is loaded. That means the publish was \"\n            \"not correct.\"\n        )\n    container_collection = loaded_containers[0]\n\n    return container_collection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html","title":"render_lib","text":""},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.create_render_node_tree","title":"<code>create_render_node_tree(variant_name, render_layer_nodes, project_settings)</code>","text":"<p>Create a Compositor node tree for rendering based on project settings.</p> <p>Parameters:</p> Name Type Description Default <code>variant_name</code> <code>str</code> <p>The name of the variant to use in the output file names.</p> required <code>view_layers</code> <code>list[ViewLayer]</code> <p>The list of view layers to create render layer nodes for.</p> required <code>project_settings</code> <code>dict</code> <p>The project settings dictionary.</p> required Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def create_render_node_tree(\n    variant_name: str,\n    render_layer_nodes: set[\"bpy.types.CompositorNodeRLayers\"],\n    project_settings: dict,\n) -&gt; \"bpy.types.CompositorNodeOutputFile\":\n    \"\"\"Create a Compositor node tree for rendering based on project settings.\n\n    Arguments:\n        variant_name (str): The name of the variant to use in the output file\n            names.\n        view_layers (list[bpy.types.ViewLayer]): The list of view layers to\n            create render layer nodes for.\n        project_settings (dict): The project settings dictionary.\n    \"\"\"\n    aov_sep = get_aov_separator(project_settings)\n    ext = get_image_format(project_settings)\n    multilayer = get_multilayer(project_settings)\n    compositing = get_compositing(project_settings)\n\n    tree = lib.get_scene_node_tree(ensure_exists=True)\n\n    comp_composite_type = \"CompositorNodeComposite\"\n\n    # Find existing 'Composite' node\n    composite_node = None\n    for node in tree.nodes:\n        if node.bl_idname == comp_composite_type:\n            composite_node = node\n            break\n\n    # Create a new output node\n    output: bpy.types.CompositorNodeOutputFile = tree.nodes.new(\n        \"CompositorNodeOutputFile\"\n    )\n    output.name = variant_name\n    output.label = variant_name\n\n    # Multi-exr\n    multi_exr: bool = ext == \"exr\" and multilayer\n    blender_version = lib.get_blender_version()\n    if blender_version &gt;= (5, 0, 0):\n        output.format.media_type = (\n            \"MULTI_LAYER_IMAGE\" if multi_exr else \"IMAGE\"\n        )\n    # By default, match output format from scene file format\n    image_settings = bpy.context.scene.render.image_settings\n    output.format.file_format = image_settings.file_format\n\n    # Define the base path for the File Output node.\n    base_path = get_base_render_output_path(\n        variant_name, project_settings=project_settings\n    )\n    if blender_version &gt;= (5, 0, 0):\n        base_path_dir, base_path_filename = os.path.split(base_path)\n        if not multi_exr:\n            base_path_filename += aov_sep\n\n        output.directory = base_path_dir\n        output.file_name = base_path_filename\n        slots = output.file_output_items\n    else:\n        output.base_path = base_path\n        slots = output.layer_slots if multi_exr else output.file_slots\n\n    def _create_aov_slot(\n        renderpass_name: str,\n        render_layer: str,\n        socket_type: str = \"FLOAT\",\n    ) -&gt; \"bpy.types.RenderSlot\":\n        \"\"\"Add a new render output slot to the slots.\n\n        The slots usually are the file slots of the compositor output node.\n        The filepath is based on the render layer, variant name and render pass.\n\n        If it's multi-exr, the slot will be named after the render pass only.\n\n        Returns:\n            The created slot\n\n        \"\"\"\n        if lib.get_blender_version() &gt;= (5, 0, 0):\n            new_output_item = output.file_output_items.new(\n                socket_type, renderpass_name\n            )\n            return output.inputs[new_output_item.name]\n\n        filename: str = (\n            f\"{render_layer}/\"\n            f\"{variant_name}_{render_layer}{aov_sep}{renderpass_name}.####\"\n        )\n        return slots.new(renderpass_name if multi_exr else filename)\n\n    slots.clear()\n\n    # Create a new socket for the Beauty output\n    pass_name = \"Beauty\"\n    for render_layer_node in render_layer_nodes:\n        render_layer = render_layer_node.layer\n        slot = _create_aov_slot(pass_name, render_layer, socket_type=\"RGBA\")\n        tree.links.new(render_layer_node.outputs[\"Image\"], slot)\n\n    last_found_renderlayer_node = next(\n        (node for node in reversed(list(render_layer_nodes))), None\n    )\n    if compositing and last_found_renderlayer_node:\n        # Create a new socket for the Composite output\n        # with only the one view layer\n        pass_name = \"Composite\"\n        render_layer = last_found_renderlayer_node.layer\n        slot = _create_aov_slot(pass_name, render_layer)\n        # If there's a composite node, we connect its 'Image' input with the\n        # new slot on the output\n        if composite_node:\n            for link in composite_node.inputs[\"Image\"].links:\n                tree.links.new(link.from_socket, slot)\n                break\n\n    # For each active render pass, we add a new socket to the output node\n    # and link it\n    exclude_sockets: set[str] = {\"Image\", \"Alpha\", \"Noisy Image\"}\n    for render_layer_node in render_layer_nodes:\n        # Get the enabled output sockets, that are the active passes for the\n        # render.\n        render_layer = render_layer_node.layer\n        for output_socket in render_layer_node.outputs:\n            if output_socket.name in exclude_sockets:\n                continue\n\n            if not output_socket.enabled:\n                continue\n\n            socket_type: str = \"FLOAT\"  # Only relevant for Blender 5+\n            if lib.get_blender_version() &gt;= (5, 0, 0):\n                socket_type = output_socket.type\n                if socket_type == \"VALUE\":\n                    socket_type = \"FLOAT\"\n\n            slot = _create_aov_slot(\n                output_socket.name,\n                render_layer,\n                socket_type=socket_type\n            )\n            tree.links.new(output_socket, slot)\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_aov_options","title":"<code>get_aov_options(renderer)</code>","text":"<p>Return the available AOV options based on the renderer name.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_aov_options(renderer: str) -&gt; dict[str, str]:\n    \"\"\"Return the available AOV options based on the renderer name.\"\"\"\n    aov_options = {\n        \"combined\": \"use_pass_combined\",\n        \"z\": \"use_pass_z\",\n        \"mist\": \"use_pass_mist\",\n        \"normal\": \"use_pass_normal\",\n        \"diffuse_light\": \"use_pass_diffuse_direct\",\n        \"diffuse_color\": \"use_pass_diffuse_color\",\n        \"specular_light\": \"use_pass_glossy_direct\",\n        \"specular_color\": \"use_pass_glossy_color\",\n        \"emission\": \"use_pass_emit\",\n        \"environment\": \"use_pass_environment\",\n        \"ao\": \"use_pass_ambient_occlusion\",\n        \"cryptomatte_object\": \"use_pass_cryptomatte_object\",\n        \"cryptomatte_material\": \"use_pass_cryptomatte_material\",\n        \"cryptomatte_asset\": \"use_pass_cryptomatte_asset\",\n    }\n    if renderer == \"BLENDER_EEVEE\":\n        eevee_options = {\n            \"shadow\": \"use_pass_shadow\",\n            \"volume_light\": \"use_pass_volume_direct\",\n            \"bloom\": \"use_pass_bloom\",\n            \"transparent\": \"use_pass_transparent\",\n            \"cryptomatte_accurate\": \"use_pass_cryptomatte_accurate\",\n        }\n        aov_options.update(eevee_options)\n    elif renderer == \"CYCLES\":\n        cycles_options = {\n            \"position\": \"use_pass_position\",\n            \"vector\": \"use_pass_vector\",\n            \"uv\": \"use_pass_uv\",\n            \"denoising\": \"denoising_store_passes\",\n            \"object_index\": \"use_pass_object_index\",\n            \"material_index\": \"use_pass_material_index\",\n            \"sample_count\": \"pass_debug_sample_count\",\n            \"diffuse_indirect\": \"use_pass_diffuse_indirect\",\n            \"specular_indirect\": \"use_pass_glossy_indirect\",\n            \"transmission_direct\": \"use_pass_transmission_direct\",\n            \"transmission_indirect\": \"use_pass_transmission_indirect\",\n            \"transmission_color\": \"use_pass_transmission_color\",\n            \"volume_light\": \"use_pass_volume_direct\",\n            \"volume_indirect\": \"use_pass_volume_indirect\",\n            \"shadow\": \"use_pass_shadow_catcher\",\n        }\n        aov_options.update(cycles_options)\n\n    return aov_options\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_aov_separator","title":"<code>get_aov_separator(project_settings)</code>","text":"<p>Get aov separator from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_aov_separator(project_settings) -&gt; str:\n    \"\"\"Get aov separator from blender settings.\"\"\"\n    aov_sep = project_settings[\"blender\"][\"RenderSettings\"][\"aov_separator\"]\n\n    if aov_sep == \"dash\":\n        return \"-\"\n    elif aov_sep == \"underscore\":\n        return \"_\"\n    elif aov_sep == \"dot\":\n        return \".\"\n    else:\n        raise ValueError(f\"Invalid aov separator: {aov_sep}\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_base_render_output_path","title":"<code>get_base_render_output_path(variant_name, multi_exr=None, project_settings=None)</code>","text":"<p>Return the base render output path for the given variant name.</p> <p>The output path is based on the AYON project settings and the current Blender scene workfile path.</p> <p>If the render settings are not set to multi-EXR then only the base path is returned, otherwise the full path to the render output file is returned.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_base_render_output_path(\n    variant_name: str,\n    multi_exr: Optional[bool] = None,\n    project_settings: Optional[dict] = None\n) -&gt; str:\n    \"\"\"Return the base render output path for the given variant name.\n\n    The output path is based on the AYON project settings and the current\n    Blender scene workfile path.\n\n    If the render settings are not set to multi-EXR then only the base path\n    is returned, otherwise the full path to the render output file is returned.\n\n    \"\"\"\n    workfile_filepath = Path(bpy.data.filepath)\n    assert workfile_filepath, \"Workfile not saved. Please save the file first.\"\n\n    render_folder = get_default_render_folder(project_settings)\n    if multi_exr is None:\n        multi_exr = get_multilayer(project_settings)\n\n    workfile_dir = workfile_filepath.parent\n    workfile_filename = Path(workfile_filepath.name).stem\n    base_folder = Path.joinpath(workfile_dir, render_folder, workfile_filename)\n    if not multi_exr:\n        # If not multi-exr, we only supply the root folder to render to.\n        return str(base_folder)\n\n    filename = f\"{variant_name}.####\"\n    filepath = base_folder / filename\n    return str(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_compositing","title":"<code>get_compositing(project_settings)</code>","text":"<p>Get whether 'Composite' render is enabled from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_compositing(project_settings) -&gt; bool:\n    \"\"\"Get whether 'Composite' render is enabled from blender settings.\"\"\"\n    # Blender 5+ does not have the \"Composite\" node, so it's always False\n    if lib.get_blender_version() &gt;= (5, 0, 0):\n        return False\n\n    return project_settings[\"blender\"][\"RenderSettings\"][\"compositing\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_default_render_folder","title":"<code>get_default_render_folder(project_settings)</code>","text":"<p>Get default render folder from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_default_render_folder(project_settings) -&gt; str:\n    \"\"\"Get default render folder from blender settings.\"\"\"\n    return project_settings[\"blender\"][\"RenderSettings\"][\n        \"default_render_image_folder\"\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_file_format_extension","title":"<code>get_file_format_extension(file_format)</code>","text":"<p>Convert Blender file format to file extension.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_file_format_extension(file_format: str) -&gt; str:\n    \"\"\"Convert Blender file format to file extension.\"\"\"\n    # TODO: Figure out if Blender has a native way to convert to extensions\n    if file_format == \"OPEN_EXR_MULTILAYER\":\n        return \"exr\"\n    elif file_format == \"OPEN_EXR\":\n        return \"exr\"\n    elif file_format == \"BMP\":\n        return \"bmp\"\n    elif file_format == \"IRIS\":\n        return \"rgb\"\n    elif file_format == \"PNG\":\n        return \"png\"\n    elif file_format == \"JPEG\":\n        return \"jpeg\"\n    elif file_format == \"JPEG2000\":\n        return \"jp2\"\n    elif file_format == \"TARGA\" or file_format == \"TARGA_RAW\":\n        return \"tga\"\n    elif file_format == \"TIFF\":\n        return \"tif\"\n    # Blender 5+\n    elif file_format == \"CINEON\":\n        return \"cin\"\n    elif file_format == \"DPX\":\n        return \"dpx\"\n    elif file_format == \"WEBP\":\n        return \"webp\"\n    elif file_format == \"HDR\":\n        return \"hdr\"\n    else:\n        raise ValueError(f\"Unsupported file format: {file_format}\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_image_format","title":"<code>get_image_format(project_settings)</code>","text":"<p>Get image format from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_image_format(project_settings) -&gt; str:\n    \"\"\"Get image format from blender settings.\"\"\"\n    return project_settings[\"blender\"][\"RenderSettings\"][\"image_format\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_multilayer","title":"<code>get_multilayer(project_settings)</code>","text":"<p>Get multilayer from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_multilayer(project_settings) -&gt; bool:\n    \"\"\"Get multilayer from blender settings.\"\"\"\n    return project_settings[\"blender\"][\"RenderSettings\"][\"multilayer_exr\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_or_create_render_layer_nodes","title":"<code>get_or_create_render_layer_nodes(view_layers)</code>","text":"<p>Get existing render layer nodes or create new ones.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_or_create_render_layer_nodes(\n    view_layers: list[\"bpy.types.ViewLayer\"],\n) -&gt; set[bpy.types.CompositorNodeRLayers]:\n    \"\"\"Get existing render layer nodes or create new ones.\"\"\"\n    tree = lib.get_scene_node_tree(ensure_exists=True)\n\n    view_layer_names: set[str] = {\n        view_layer.name for view_layer in view_layers\n    }\n\n    # Find existing render layer nodes for each view layer\n    render_layer_nodes: set[bpy.types.CompositorNodeRLayers] = set()\n    found_view_layer_names: set[str] = set()\n    for node in tree.nodes:\n        if node.bl_idname != \"CompositorNodeRLayers\":\n            continue\n\n        # Skip if already found a render layer node for this view layer.\n        if node.layer in found_view_layer_names:\n            continue\n\n        # Skip if the view layer is not meant to be included.\n        if node.layer not in view_layer_names:\n            continue\n\n        found_view_layer_names.add(node.layer)\n        render_layer_nodes.add(node)\n\n    # Generate the missing render layer nodes\n    missing_view_layer_names: set[str] = (\n        view_layer_names - found_view_layer_names\n    )\n    for view_layer_name in missing_view_layer_names:\n        render_layer_node = tree.nodes.new(\"CompositorNodeRLayers\")\n        render_layer_node.layer = view_layer_name\n        render_layer_nodes.add(render_layer_node)\n\n    return render_layer_nodes\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_renderer","title":"<code>get_renderer(project_settings)</code>","text":"<p>Get renderer from blender settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_renderer(project_settings) -&gt; str:\n    \"\"\"Get renderer from blender settings.\"\"\"\n    return project_settings[\"blender\"][\"RenderSettings\"][\"renderer\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.get_tmp_scene_render_output_path","title":"<code>get_tmp_scene_render_output_path(project_settings)</code>","text":"<p>Get the render output path for the current scene.</p> <p>This is the scene-wide render path that AYON essentially does not use, but it cannot be disabled in Blender. So we store at least a unique temporary path for the scene render output.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def get_tmp_scene_render_output_path(project_settings: dict) -&gt; str:\n    \"\"\"Get the render output path for the current scene.\n\n    This is the scene-wide render path that AYON essentially does not use,\n    but it cannot be disabled in Blender. So we store at least a unique\n    temporary path for the scene render output.\n    \"\"\"\n    render_folder = get_default_render_folder(project_settings)\n\n    workfile_filepath: str = bpy.data.filepath\n    if not workfile_filepath:\n        raise RuntimeError(\"Workfile not saved. Please save the file first.\")\n\n    workfile_filename = os.path.basename(workfile_filepath)\n    workfile_filename_no_ext, _ext = os.path.splitext(workfile_filename)\n\n    # Even though we render a `tmp` file we still want to write into\n    # a unique folder or filename per folder to avoid conflicts on\n    # potential simultaneous renders on the farm trying to write into\n    # the same folder and have them unable to write due to file locks.\n    # TODO: Starting in Blender 4.5 we can use {blend_name} in the render path\n    #   so that we do not need to set this again for every workfile version\n    #   increase.\n    path = os.path.join(\n        os.getenv(\"AYON_WORKDIR\"),\n        render_folder,\n        workfile_filename_no_ext,\n        \"tmp\",\n        \"tmp\"\n    )\n    return path.replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.prepare_rendering","title":"<code>prepare_rendering(variant_name, project_settings=None)</code>","text":"<p>Initialize render setup using render settings from project settings.</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def prepare_rendering(\n    variant_name: str, project_settings: Optional[dict] = None\n) -&gt; \"bpy.types.CompositorNodeOutputFile\":\n    \"\"\"Initialize render setup using render settings from project settings.\"\"\"\n    assert bpy.data.filepath, \"Workfile not saved. Please save the file first.\"\n\n    if project_settings is None:\n        project_name: str = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n\n    ext = get_image_format(project_settings)\n    multilayer = get_multilayer(project_settings)\n    renderer = get_renderer(project_settings)\n    ver_major, ver_minor, _ = lib.get_blender_version()\n    if renderer == \"BLENDER_EEVEE\" and (\n        ver_major &gt;= 4 and ver_minor &gt;=2\n    ):\n        renderer = \"BLENDER_EEVEE_NEXT\"\n\n    # Set scene render settings\n    set_render_format(ext, multilayer)\n    bpy.context.scene.render.engine = renderer\n    view_layers = bpy.context.scene.view_layers\n    set_render_passes(project_settings, renderer, view_layers)\n\n    # Use selected renderlayer nodes, or assume we want a renderlayer node for\n    # each view layer so we retrieve all of them.\n    node_tree = lib.get_scene_node_tree(ensure_exists=True)\n    selected_renderlayer_nodes = []\n\n    # Check if node_tree is available before accessing nodes\n    if node_tree is not None:\n        for node in node_tree.nodes:\n            if node.bl_idname == \"CompositorNodeRLayers\" and node.select:\n                selected_renderlayer_nodes.append(node)\n\n    if selected_renderlayer_nodes:\n        render_layer_nodes = selected_renderlayer_nodes\n    else:\n        render_layer_nodes = get_or_create_render_layer_nodes(view_layers)\n\n    # Generate Compositing nodes\n    output_node = create_render_node_tree(\n        variant_name,\n        render_layer_nodes,\n        project_settings\n    )\n\n    set_tmp_scene_render_output_path(project_settings)\n    bpy.context.scene.render.use_overwrite = True\n\n    return output_node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.set_render_format","title":"<code>set_render_format(ext, multilayer)</code>","text":"<p>Set Blender scene to save render file with the right extension</p> Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def set_render_format(ext: str, multilayer: bool):\n    \"\"\"Set Blender scene to save render file with the right extension\"\"\"\n    bpy.context.scene.render.use_file_extension = True\n    image_settings = bpy.context.scene.render.image_settings\n\n    if multilayer and lib.get_blender_version() &gt;= (5, 0, 0):\n        image_settings.media_type = \"MULTI_LAYER_IMAGE\"\n\n    if ext == \"exr\":\n        file_format = \"OPEN_EXR_MULTILAYER\" if multilayer else \"OPEN_EXR\"\n        image_settings.file_format = file_format\n    elif ext == \"bmp\":\n        image_settings.file_format = \"BMP\"\n    elif ext == \"rgb\":\n        image_settings.file_format = \"IRIS\"\n    elif ext == \"png\":\n        image_settings.file_format = \"PNG\"\n    elif ext == \"jpeg\":\n        image_settings.file_format = \"JPEG\"\n    elif ext == \"jp2\":\n        image_settings.file_format = \"JPEG2000\"\n    elif ext == \"tga\":\n        image_settings.file_format = \"TARGA\"\n    elif ext == \"tif\":\n        image_settings.file_format = \"TIFF\"\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/render_lib.html#client.ayon_blender.api.render_lib.set_render_passes","title":"<code>set_render_passes(settings, renderer, view_layers)</code>","text":"<p>Set render passes for the current view layer</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>The project settings.</p> required <code>renderer</code> <code>str</code> <p>The renderer to use, either CYCLES or BLENDER_EEVEE.</p> required <code>view_layers</code> <code>list[ViewLayer]</code> <p>The list of view layers to</p> required Source code in <code>client/ayon_blender/api/render_lib.py</code> <pre><code>def set_render_passes(settings, renderer, view_layers):\n    \"\"\"Set render passes for the current view layer\n\n    Args:\n        settings (dict): The project settings.\n        renderer (str): The renderer to use, either CYCLES or BLENDER_EEVEE.\n        view_layers (list[bpy.types.ViewLayer]): The list of view layers to\n        set the passes for.\n    \"\"\"\n    aov_list = set(settings[\"blender\"][\"RenderSettings\"][\"aov_list\"])\n    existing_aov_list = set(existing_aov_options(renderer, view_layers))\n    aov_list = aov_list.union(existing_aov_list)\n    custom_passes = settings[\"blender\"][\"RenderSettings\"][\"custom_passes\"]\n    # Common passes for both renderers\n    for vl in view_layers:\n        if renderer == \"BLENDER_EEVEE\":\n            # Eevee exclusive passes\n            aov_options = get_aov_options(renderer)\n            eevee_attrs: set[str] = {\n                \"use_pass_bloom\",\n                \"use_pass_transparent\",\n                \"use_pass_volume_direct\"\n            }\n            for pass_name, attr in aov_options.items():\n                target = vl.eevee if attr in eevee_attrs else vl\n                ver_major, ver_minor, _ = lib.get_blender_version()\n                if ver_major &gt;= 3 and ver_minor &gt; 6:\n                    if attr == \"use_pass_bloom\":\n                        continue\n                setattr(target, attr, pass_name in aov_list)\n        elif renderer == \"CYCLES\":\n            # Cycles exclusive passes\n            aov_options = get_aov_options(renderer)\n            cycle_attrs: set[str] = {\n                \"denoising_store_passes\", \"pass_debug_sample_count\",\n                \"use_pass_volume_direct\", \"use_pass_volume_indirect\",\n                \"use_pass_shadow_catcher\"\n            }\n            for pass_name, attr in aov_options.items():\n                target = vl.cycles if attr in cycle_attrs else vl\n                setattr(target, attr, pass_name in aov_list)\n\n        aovs_names: set[str] = {aov.name for aov in vl.aovs}\n        for custom_pass in custom_passes:\n            custom_pass_name = custom_pass[\"attribute\"]\n            if custom_pass_name not in aovs_names:\n                aov = vl.aovs.add()\n                aov.name = custom_pass_name\n            else:\n                aov = vl.aovs[custom_pass_name]\n            aov.type = custom_pass[\"value\"]\n\n    return list(aov_list), custom_passes\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html","title":"workio","text":"<p>Host API required for Work Files.</p>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.OpenFileCacher","title":"<code>OpenFileCacher</code>","text":"<p>Store information about opening file.</p> <p>When file is opening QApplcation events should not be processed.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>class OpenFileCacher:\n    \"\"\"Store information about opening file.\n\n    When file is opening QApplcation events should not be processed.\n    \"\"\"\n    opening_file = False\n\n    @classmethod\n    def post_load(cls):\n        cls.opening_file = False\n\n    @classmethod\n    def set_opening(cls):\n        cls.opening_file = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.current_file","title":"<code>current_file()</code>","text":"<p>Return the path of the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def current_file() -&gt; Optional[str]:\n    \"\"\"Return the path of the open scene file.\"\"\"\n\n    current_filepath = bpy.data.filepath\n    if Path(current_filepath).is_file():\n        return current_filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.file_extensions","title":"<code>file_extensions()</code>","text":"<p>Return the supported file extensions for Blender scene files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def file_extensions() -&gt; List[str]:\n    \"\"\"Return the supported file extensions for Blender scene files.\"\"\"\n\n    return [\".blend\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.has_unsaved_changes","title":"<code>has_unsaved_changes()</code>","text":"<p>Does the open scene file have unsaved changes?</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def has_unsaved_changes() -&gt; bool:\n    \"\"\"Does the open scene file have unsaved changes?\"\"\"\n\n    return bpy.data.is_dirty\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Open the scene file in Blender.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def open_file(filepath: str) -&gt; Optional[str]:\n    \"\"\"Open the scene file in Blender.\"\"\"\n    OpenFileCacher.set_opening()\n\n    preferences = bpy.context.preferences\n    load_ui = preferences.filepaths.use_load_ui\n    use_scripts = preferences.filepaths.use_scripts_auto_execute\n    result = bpy.ops.wm.open_mainfile(\n        filepath=filepath,\n        load_ui=load_ui,\n        use_scripts=use_scripts,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.save_file","title":"<code>save_file(filepath, copy=False)</code>","text":"<p>Save the open scene file.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def save_file(filepath: str, copy: bool = False) -&gt; Optional[str]:\n    \"\"\"Save the open scene file.\"\"\"\n\n    preferences = bpy.context.preferences\n    compress = preferences.filepaths.use_file_compression\n    relative_remap = preferences.filepaths.use_relative_paths\n    result = bpy.ops.wm.save_as_mainfile(\n        filepath=filepath,\n        compress=compress,\n        relative_remap=relative_remap,\n        copy=copy,\n    )\n\n    if result == {'FINISHED'}:\n        return filepath\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/api/workio.html#client.ayon_blender.api.workio.work_root","title":"<code>work_root(session)</code>","text":"<p>Return the default root to browse for work files.</p> Source code in <code>client/ayon_blender/api/workio.py</code> <pre><code>def work_root(session: dict) -&gt; str:\n    \"\"\"Return the default root to browse for work files.\"\"\"\n\n    work_dir = session[\"AYON_WORKDIR\"]\n    scene_dir = session.get(\"AVALON_SCENEDIR\")\n    if scene_dir:\n        return str(Path(work_dir, scene_dir))\n    return work_dir\n</code></pre>"},{"location":"autoapi/client/ayon_blender/blender_addon/index.html","title":"blender_addon","text":""},{"location":"autoapi/client/ayon_blender/blender_addon/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_blender/blender_addon/startup/init.html","title":"init","text":""},{"location":"autoapi/client/ayon_blender/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_add_run_python_script_arg.html","title":"pre_add_run_python_script_arg","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_add_run_python_script_arg.html#client.ayon_blender.hooks.pre_add_run_python_script_arg.AddPythonScriptToLaunchArgs","title":"<code>AddPythonScriptToLaunchArgs</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Add python script to be executed before Blender launch.</p> Source code in <code>client/ayon_blender/hooks/pre_add_run_python_script_arg.py</code> <pre><code>class AddPythonScriptToLaunchArgs(PreLaunchHook):\n    \"\"\"Add python script to be executed before Blender launch.\"\"\"\n\n    # Append after file argument\n    order = 15\n    app_groups = {\"blender\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        if not self.launch_context.data.get(\"python_scripts\"):\n            return\n\n        # Add path to workfile to arguments\n        for python_script_path in self.launch_context.data[\"python_scripts\"]:\n            self.log.info(\n                f\"Adding python script {python_script_path} to launch\"\n            )\n            # Test script path exists\n            python_script_path = Path(python_script_path)\n            if not python_script_path.exists():\n                self.log.warning(\n                    f\"Python script {python_script_path} doesn't exist. \"\n                    \"Skipped...\"\n                )\n                continue\n\n            if \"--\" in self.launch_context.launch_args:\n                # Insert before separator\n                separator_index = self.launch_context.launch_args.index(\"--\")\n                self.launch_context.launch_args.insert(\n                    separator_index,\n                    \"-P\",\n                )\n                self.launch_context.launch_args.insert(\n                    separator_index + 1,\n                    python_script_path.as_posix(),\n                )\n            else:\n                self.launch_context.launch_args.extend(\n                    [\"-P\", python_script_path.as_posix()]\n                )\n\n        # Ensure separator\n        if \"--\" not in self.launch_context.launch_args:\n            self.launch_context.launch_args.append(\"--\")\n\n        self.launch_context.launch_args.extend(\n            [*self.launch_context.data.get(\"script_args\", [])]\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html","title":"pre_pyside_install","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender","title":"<code>InstallPySideToBlender</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Install Qt binding to blender's python packages.</p> <p>Prelaunch hook does 2 things: 1.) Blender's python packages are pushed to the beginning of PYTHONPATH. 2.) Check if blender has installed PySide2 and will try to install if not.</p> <p>For pipeline implementation is required to have Qt binding installed in blender's python packages.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>class InstallPySideToBlender(PreLaunchHook):\n    \"\"\"Install Qt binding to blender's python packages.\n\n    Prelaunch hook does 2 things:\n    1.) Blender's python packages are pushed to the beginning of PYTHONPATH.\n    2.) Check if blender has installed PySide2 and will try to install if not.\n\n    For pipeline implementation is required to have Qt binding installed in\n    blender's python packages.\n    \"\"\"\n\n    app_groups = {\"blender\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Prelaunch hook is not crucial\n        try:\n            self.inner_execute()\n        except Exception:\n            self.log.warning(\n                \"Processing of {} crashed.\".format(self.__class__.__name__),\n                exc_info=True\n            )\n\n    def inner_execute(self):\n        # Get blender's python directory\n        version_regex = re.compile(r\"^([2-5])\\.[0-9]+$\")\n\n        platform = system().lower()\n        executable = self.launch_context.executable.executable_path\n        expected_executable = \"blender\"\n        if platform == \"windows\":\n            expected_executable += \".exe\"\n\n        if os.path.basename(executable).lower() != expected_executable:\n            self.log.info((\n                f\"Executable does not lead to {expected_executable} file.\"\n                \"Can't determine blender's python to check/install\"\n                \" Qt binding.\"\n            ))\n            return\n\n        versions_dir = os.path.dirname(executable)\n        if platform == \"darwin\":\n            versions_dir = os.path.join(\n                os.path.dirname(versions_dir), \"Resources\"\n            )\n        version_subfolders = []\n        for dir_entry in os.scandir(versions_dir):\n            if dir_entry.is_dir() and version_regex.match(dir_entry.name):\n                version_subfolders.append(dir_entry.name)\n\n        if not version_subfolders:\n            self.log.info(\n                \"Didn't find version subfolder next to Blender executable\"\n            )\n            return\n\n        if len(version_subfolders) &gt; 1:\n            self.log.info((\n                \"Found more than one version subfolder next\"\n                \" to blender executable. {}\"\n            ).format(\", \".join([\n                '\"./{}\"'.format(name)\n                for name in version_subfolders\n            ])))\n            return\n\n        version_subfolder = version_subfolders[0]\n        before_blender_4 = False\n        if int(version_regex.match(version_subfolder).group(1)) &lt; 4:\n            before_blender_4 = True\n        # Blender 4 has Python 3.11 which does not support 'PySide2'\n        # QUESTION could we always install PySide6?\n        qt_binding = \"PySide2\" if before_blender_4 else \"PySide6\"\n        # Use PySide6 6.6.3 because 6.7.0 had a bug\n        #   - 'QTextEdit' can't be added to 'QBoxLayout'\n        qt_binding_version = None if before_blender_4 else \"6.6.3\"\n\n        python_dir = os.path.join(versions_dir, version_subfolder, \"python\")\n        python_lib = os.path.join(python_dir, \"lib\")\n        python_version = \"python\"\n\n        if platform != \"windows\":\n            for dir_entry in os.scandir(python_lib):\n                if dir_entry.is_dir() and dir_entry.name.startswith(\"python\"):\n                    python_lib = dir_entry.path\n                    python_version = dir_entry.name\n                    break\n\n        # Change PYTHONPATH to contain blender's packages as first\n        python_paths = [\n            python_lib,\n            os.path.join(python_lib, \"site-packages\"),\n        ]\n        python_path = self.launch_context.env.get(\"PYTHONPATH\") or \"\"\n        for path in python_path.split(os.pathsep):\n            if path:\n                python_paths.append(path)\n\n        self.launch_context.env[\"PYTHONPATH\"] = os.pathsep.join(python_paths)\n\n        # Get blender's python executable\n        python_bin = os.path.join(python_dir, \"bin\")\n        if platform == \"windows\":\n            python_executable = os.path.join(python_bin, \"python.exe\")\n        else:\n            python_executable = os.path.join(python_bin, python_version)\n            # Check for python with enabled 'pymalloc'\n            if not os.path.exists(python_executable):\n                python_executable += \"m\"\n\n        if not os.path.exists(python_executable):\n            self.log.warning(\n                \"Couldn't find python executable for blender. {}\".format(\n                    executable\n                )\n            )\n            return\n\n        # Check if PySide2 is installed and skip if yes\n        if self.is_pyside_installed(python_executable, qt_binding):\n            self.log.debug(\"Blender has already installed PySide2.\")\n            return\n\n        # Install PySide2 in blender's python\n        if platform == \"windows\":\n            result = self.install_pyside_windows(\n                python_executable,\n                qt_binding,\n                qt_binding_version,\n                before_blender_4,\n            )\n        else:\n            result = self.install_pyside(\n                python_executable,\n                qt_binding,\n                qt_binding_version,\n            )\n\n        if result:\n            self.log.info(\n                f\"Successfully installed {qt_binding} module to blender.\"\n            )\n        else:\n            self.log.warning(\n                f\"Failed to install {qt_binding} module to blender.\"\n            )\n\n    def install_pyside_windows(\n        self,\n        python_executable,\n        qt_binding,\n        qt_binding_version,\n        before_blender_4,\n    ):\n        \"\"\"Install PySide2 python module to blender's python.\n\n        Installation requires administration rights that's why it is required\n        to use \"pywin32\" module which can execute command's and ask for\n        administration rights.\n        \"\"\"\n        try:\n            import win32con\n            import win32process\n            import win32event\n            import pywintypes\n            from win32comext.shell.shell import ShellExecuteEx\n            from win32comext.shell import shellcon\n        except Exception:\n            self.log.warning(\"Couldn't import \\\"pywin32\\\" modules\")\n            return\n\n        if qt_binding_version:\n            qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide2 and argument\n            #   \"--ignore-installed\" is to force install module to blender's\n            #   site-packages and make sure it is binary compatible\n            fake_exe = \"fake.exe\"\n            site_packages_prefix = os.path.dirname(\n                os.path.dirname(python_executable)\n            )\n            args = [\n                fake_exe,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"--ignore-installed\",\n                qt_binding,\n            ]\n            if not before_blender_4:\n                # Define prefix for site package\n                # Python in blender 4.x is installing packages in AppData and\n                #   not in blender's directory.\n                args.extend([\"--prefix\", site_packages_prefix])\n\n            parameters = (\n                subprocess.list2cmdline(args)\n                .lstrip(fake_exe)\n                .lstrip(\" \")\n            )\n\n            # Execute command and ask for administrator's rights\n            process_info = ShellExecuteEx(\n                nShow=win32con.SW_SHOWNORMAL,\n                fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n                lpVerb=\"runas\",\n                lpFile=python_executable,\n                lpParameters=parameters,\n                lpDirectory=os.path.dirname(python_executable)\n            )\n            process_handle = process_info[\"hProcess\"]\n            win32event.WaitForSingleObject(process_handle, win32event.INFINITE)\n            returncode = win32process.GetExitCodeProcess(process_handle)\n            return returncode == 0\n        except pywintypes.error:\n            pass\n\n    def install_pyside(\n        self,\n        python_executable,\n        qt_binding,\n        qt_binding_version,\n    ):\n        \"\"\"Install Qt binding python module to blender's python.\"\"\"\n        if qt_binding_version:\n            qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install qt binding and argument\n            #   \"--ignore-installed\" is to force install module to blender's\n            #   site-packages and make sure it is binary compatible\n            # TODO find out if blender 4.x on linux/darwin does install\n            #   qt binding to correct place.\n            args = [\n                python_executable,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"--ignore-installed\",\n                qt_binding,\n            ]\n            process = subprocess.Popen(\n                args, stdout=subprocess.PIPE, universal_newlines=True\n            )\n            process.communicate()\n            return process.returncode == 0\n        except PermissionError:\n            self.log.warning(\n                \"Permission denied with command:\"\n                \"\\\"{}\\\".\".format(\" \".join(args))\n            )\n        except OSError as error:\n            self.log.warning(f\"OS error has occurred: \\\"{error}\\\".\")\n        except subprocess.SubprocessError:\n            pass\n\n    def is_pyside_installed(self, python_executable, qt_binding):\n        \"\"\"Check if PySide2 module is in blender's pip list.\n\n        Check that PySide2 is installed directly in blender's site-packages.\n        It is possible that it is installed in user's site-packages but that\n        may be incompatible with blender's python.\n        \"\"\"\n\n        qt_binding_low = qt_binding.lower()\n        # Get pip list from blender's python executable\n        args = [python_executable, \"-m\", \"pip\", \"list\"]\n        process = subprocess.Popen(args, stdout=subprocess.PIPE)\n        stdout, _ = process.communicate()\n        lines = stdout.decode().split(os.linesep)\n        # Second line contain dashes that define maximum length of module name.\n        #   Second column of dashes define maximum length of module version.\n        package_dashes, *_ = lines[1].split(\" \")\n        package_len = len(package_dashes)\n\n        # Got through printed lines starting at line 3\n        for idx in range(2, len(lines)):\n            line = lines[idx]\n            if not line:\n                continue\n            package_name = line[0:package_len].strip()\n            if package_name.lower() == qt_binding_low:\n                return True\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender.install_pyside","title":"<code>install_pyside(python_executable, qt_binding, qt_binding_version)</code>","text":"<p>Install Qt binding python module to blender's python.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>def install_pyside(\n    self,\n    python_executable,\n    qt_binding,\n    qt_binding_version,\n):\n    \"\"\"Install Qt binding python module to blender's python.\"\"\"\n    if qt_binding_version:\n        qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n    try:\n        # Parameters\n        # - use \"-m pip\" as module pip to install qt binding and argument\n        #   \"--ignore-installed\" is to force install module to blender's\n        #   site-packages and make sure it is binary compatible\n        # TODO find out if blender 4.x on linux/darwin does install\n        #   qt binding to correct place.\n        args = [\n            python_executable,\n            \"-m\",\n            \"pip\",\n            \"install\",\n            \"--ignore-installed\",\n            qt_binding,\n        ]\n        process = subprocess.Popen(\n            args, stdout=subprocess.PIPE, universal_newlines=True\n        )\n        process.communicate()\n        return process.returncode == 0\n    except PermissionError:\n        self.log.warning(\n            \"Permission denied with command:\"\n            \"\\\"{}\\\".\".format(\" \".join(args))\n        )\n    except OSError as error:\n        self.log.warning(f\"OS error has occurred: \\\"{error}\\\".\")\n    except subprocess.SubprocessError:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender.install_pyside_windows","title":"<code>install_pyside_windows(python_executable, qt_binding, qt_binding_version, before_blender_4)</code>","text":"<p>Install PySide2 python module to blender's python.</p> <p>Installation requires administration rights that's why it is required to use \"pywin32\" module which can execute command's and ask for administration rights.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>def install_pyside_windows(\n    self,\n    python_executable,\n    qt_binding,\n    qt_binding_version,\n    before_blender_4,\n):\n    \"\"\"Install PySide2 python module to blender's python.\n\n    Installation requires administration rights that's why it is required\n    to use \"pywin32\" module which can execute command's and ask for\n    administration rights.\n    \"\"\"\n    try:\n        import win32con\n        import win32process\n        import win32event\n        import pywintypes\n        from win32comext.shell.shell import ShellExecuteEx\n        from win32comext.shell import shellcon\n    except Exception:\n        self.log.warning(\"Couldn't import \\\"pywin32\\\" modules\")\n        return\n\n    if qt_binding_version:\n        qt_binding = f\"{qt_binding}=={qt_binding_version}\"\n\n    try:\n        # Parameters\n        # - use \"-m pip\" as module pip to install PySide2 and argument\n        #   \"--ignore-installed\" is to force install module to blender's\n        #   site-packages and make sure it is binary compatible\n        fake_exe = \"fake.exe\"\n        site_packages_prefix = os.path.dirname(\n            os.path.dirname(python_executable)\n        )\n        args = [\n            fake_exe,\n            \"-m\",\n            \"pip\",\n            \"install\",\n            \"--ignore-installed\",\n            qt_binding,\n        ]\n        if not before_blender_4:\n            # Define prefix for site package\n            # Python in blender 4.x is installing packages in AppData and\n            #   not in blender's directory.\n            args.extend([\"--prefix\", site_packages_prefix])\n\n        parameters = (\n            subprocess.list2cmdline(args)\n            .lstrip(fake_exe)\n            .lstrip(\" \")\n        )\n\n        # Execute command and ask for administrator's rights\n        process_info = ShellExecuteEx(\n            nShow=win32con.SW_SHOWNORMAL,\n            fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n            lpVerb=\"runas\",\n            lpFile=python_executable,\n            lpParameters=parameters,\n            lpDirectory=os.path.dirname(python_executable)\n        )\n        process_handle = process_info[\"hProcess\"]\n        win32event.WaitForSingleObject(process_handle, win32event.INFINITE)\n        returncode = win32process.GetExitCodeProcess(process_handle)\n        return returncode == 0\n    except pywintypes.error:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_pyside_install.html#client.ayon_blender.hooks.pre_pyside_install.InstallPySideToBlender.is_pyside_installed","title":"<code>is_pyside_installed(python_executable, qt_binding)</code>","text":"<p>Check if PySide2 module is in blender's pip list.</p> <p>Check that PySide2 is installed directly in blender's site-packages. It is possible that it is installed in user's site-packages but that may be incompatible with blender's python.</p> Source code in <code>client/ayon_blender/hooks/pre_pyside_install.py</code> <pre><code>def is_pyside_installed(self, python_executable, qt_binding):\n    \"\"\"Check if PySide2 module is in blender's pip list.\n\n    Check that PySide2 is installed directly in blender's site-packages.\n    It is possible that it is installed in user's site-packages but that\n    may be incompatible with blender's python.\n    \"\"\"\n\n    qt_binding_low = qt_binding.lower()\n    # Get pip list from blender's python executable\n    args = [python_executable, \"-m\", \"pip\", \"list\"]\n    process = subprocess.Popen(args, stdout=subprocess.PIPE)\n    stdout, _ = process.communicate()\n    lines = stdout.decode().split(os.linesep)\n    # Second line contain dashes that define maximum length of module name.\n    #   Second column of dashes define maximum length of module version.\n    package_dashes, *_ = lines[1].split(\" \")\n    package_len = len(package_dashes)\n\n    # Got through printed lines starting at line 3\n    for idx in range(2, len(lines)):\n        line = lines[idx]\n        if not line:\n            continue\n        package_name = line[0:package_len].strip()\n        if package_name.lower() == qt_binding_low:\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_blender/hooks/pre_windows_console.html","title":"pre_windows_console","text":""},{"location":"autoapi/client/ayon_blender/hooks/pre_windows_console.html#client.ayon_blender.hooks.pre_windows_console.BlenderConsoleWindows","title":"<code>BlenderConsoleWindows</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Foundry applications have specific way how to launch them.</p> <p>Blender is executed \"like\" python process so it is required to pass <code>CREATE_NEW_CONSOLE</code> flag on windows to trigger creation of new console. At the same time the newly created console won't create it's own stdout and stderr handlers so they should not be redirected to DEVNULL.</p> Source code in <code>client/ayon_blender/hooks/pre_windows_console.py</code> <pre><code>class BlenderConsoleWindows(PreLaunchHook):\n    \"\"\"Foundry applications have specific way how to launch them.\n\n    Blender is executed \"like\" python process so it is required to pass\n    `CREATE_NEW_CONSOLE` flag on windows to trigger creation of new console.\n    At the same time the newly created console won't create it's own stdout\n    and stderr handlers so they should not be redirected to DEVNULL.\n    \"\"\"\n\n    # Should be as last hook because must change launch arguments to string\n    order = 1000\n    app_groups = {\"blender\"}\n    platforms = {\"windows\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Change `creationflags` to CREATE_NEW_CONSOLE\n        # - on Windows will blender create new window using it's console\n        # Set `stdout` and `stderr` to None so new created console does not\n        #   have redirected output to DEVNULL in build\n        self.launch_context.kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE,\n            \"stdout\": None,\n            \"stderr\": None\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_blender/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html","title":"convert_legacy","text":"<p>Converter for legacy Blender products.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html#client.ayon_blender.plugins.create.convert_legacy.BlenderLegacyConvertor","title":"<code>BlenderLegacyConvertor</code>","text":"<p>               Bases: <code>ProductConvertorPlugin</code></p> <p>Find and convert any legacy products in the scene.</p> <p>This Converter will find all legacy products in the scene and will transform them to the current system. Since the old products doesn't retain any information about their original creators, the only mapping we can do is based on their product types.</p> <p>Its limitation is that you can have multiple creators creating product of the same product type and there is no way to handle it. This code should nevertheless cover all creators that came with ayon.</p> Source code in <code>client/ayon_blender/plugins/create/convert_legacy.py</code> <pre><code>class BlenderLegacyConvertor(ProductConvertorPlugin):\n    \"\"\"Find and convert any legacy products in the scene.\n\n    This Converter will find all legacy products in the scene and will\n    transform them to the current system. Since the old products doesn't\n    retain any information about their original creators, the only mapping\n    we can do is based on their product types.\n\n    Its limitation is that you can have multiple creators creating product\n    of the same product type and there is no way to handle it. This code\n    should nevertheless cover all creators that came with ayon.\n\n    \"\"\"\n    identifier = \"io.ayon.creators.blender.legacy\"\n    product_type_to_id = {\n        \"action\": \"io.ayon.creators.blender.action\",\n        \"camera\": \"io.ayon.creators.blender.camera\",\n        \"animation\": \"io.ayon.creators.blender.animation\",\n        \"blendScene\": \"io.ayon.creators.blender.blendscene\",\n        \"layout\": \"io.ayon.creators.blender.layout\",\n        \"model\": \"io.ayon.creators.blender.model\",\n        \"pointcache\": \"io.ayon.creators.blender.pointcache\",\n        \"render\": \"io.ayon.creators.blender.render\",\n        \"review\": \"io.ayon.creators.blender.review\",\n        \"rig\": \"io.ayon.creators.blender.rig\",\n        \"workfile\": \"io.ayon.creators.blender.workfile\",\n    }\n\n    def __init__(self, *args, **kwargs):\n        super(BlenderLegacyConvertor, self).__init__(*args, **kwargs)\n        self.legacy_instances = {}\n\n    def find_instances(self):\n        \"\"\"Find legacy products in the scene.\n\n        Legacy products are the ones that doesn't have `creator_identifier`\n        parameter on them.\n\n        This is using cached entries done in\n        :py:meth:`~BlenderCreator.cache_instance_data()`\n\n        \"\"\"\n        self.legacy_instances = self.collection_shared_data.get(\n            \"blender_cached_legacy_instances\")\n        if not self.legacy_instances:\n            return\n        self.add_convertor_item(\n            \"Found {} incompatible product{}\".format(\n                len(self.legacy_instances),\n                \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n            )\n        )\n\n    def convert(self):\n        \"\"\"Convert all legacy products to current.\n\n        It is enough to add `creator_identifier` and `instance_node`.\n\n        \"\"\"\n        if not self.legacy_instances:\n            return\n\n        for product_type, instance_nodes in self.legacy_instances.items():\n            if product_type in self.product_type_to_id:\n                for instance_node in instance_nodes:\n                    creator_identifier = self.product_type_to_id[product_type]\n                    self.log.info(\n                        \"Converting {} to {}\".format(instance_node.name,\n                                                     creator_identifier)\n                    )\n                    imprint(instance_node, data={\n                        \"creator_identifier\": creator_identifier\n                    })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html#client.ayon_blender.plugins.create.convert_legacy.BlenderLegacyConvertor.convert","title":"<code>convert()</code>","text":"<p>Convert all legacy products to current.</p> <p>It is enough to add <code>creator_identifier</code> and <code>instance_node</code>.</p> Source code in <code>client/ayon_blender/plugins/create/convert_legacy.py</code> <pre><code>def convert(self):\n    \"\"\"Convert all legacy products to current.\n\n    It is enough to add `creator_identifier` and `instance_node`.\n\n    \"\"\"\n    if not self.legacy_instances:\n        return\n\n    for product_type, instance_nodes in self.legacy_instances.items():\n        if product_type in self.product_type_to_id:\n            for instance_node in instance_nodes:\n                creator_identifier = self.product_type_to_id[product_type]\n                self.log.info(\n                    \"Converting {} to {}\".format(instance_node.name,\n                                                 creator_identifier)\n                )\n                imprint(instance_node, data={\n                    \"creator_identifier\": creator_identifier\n                })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/convert_legacy.html#client.ayon_blender.plugins.create.convert_legacy.BlenderLegacyConvertor.find_instances","title":"<code>find_instances()</code>","text":"<p>Find legacy products in the scene.</p> <p>Legacy products are the ones that doesn't have <code>creator_identifier</code> parameter on them.</p> <p>This is using cached entries done in :py:meth:<code>~BlenderCreator.cache_instance_data()</code></p> Source code in <code>client/ayon_blender/plugins/create/convert_legacy.py</code> <pre><code>def find_instances(self):\n    \"\"\"Find legacy products in the scene.\n\n    Legacy products are the ones that doesn't have `creator_identifier`\n    parameter on them.\n\n    This is using cached entries done in\n    :py:meth:`~BlenderCreator.cache_instance_data()`\n\n    \"\"\"\n    self.legacy_instances = self.collection_shared_data.get(\n        \"blender_cached_legacy_instances\")\n    if not self.legacy_instances:\n        return\n    self.add_convertor_item(\n        \"Found {} incompatible product{}\".format(\n            len(self.legacy_instances),\n            \"s\" if len(self.legacy_instances) &gt; 1 else \"\"\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_action.html","title":"create_action","text":"<p>Create an animation asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_action.html#client.ayon_blender.plugins.create.create_action.CreateAction","title":"<code>CreateAction</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Action output for character rig</p> Source code in <code>client/ayon_blender/plugins/create/create_action.py</code> <pre><code>class CreateAction(plugin.BlenderCreator):\n    \"\"\"Action output for character rig\"\"\"\n\n    identifier = \"io.ayon.creators.blender.action\"\n    label = \"Action\"\n    description = __doc__\n    product_type = \"action\"\n    product_base_type = \"action\"\n    icon = \"male\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n        if pre_create_data.get(\"use_selection\"):\n            for obj in lib.get_selection():\n                if (\n                    obj.animation_data is not None\n                    and obj.animation_data.action is not None\n                    and obj.animation_data.action.name != product_name\n                ):\n\n                    empty_obj = bpy.data.objects.new(name=product_name,\n                                                     object_data=None)\n                    empty_obj.animation_data_create()\n                    empty_obj.animation_data.action = obj.animation_data.action\n                    empty_obj.animation_data.action.name = product_name\n                    obj.animation_data.action.name = product_name\n\n                if isinstance(obj, bpy.types.Object):\n                    collection.objects.link(obj)\n\n\n        return collection\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_animation.html","title":"create_animation","text":"<p>Create an animation asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_animation.html#client.ayon_blender.plugins.create.create_animation.CreateAnimation","title":"<code>CreateAnimation</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Animation output for character rig</p> Source code in <code>client/ayon_blender/plugins/create/create_animation.py</code> <pre><code>class CreateAnimation(plugin.BlenderCreator):\n    \"\"\"Animation output for character rig\"\"\"\n\n    identifier = \"io.ayon.creators.blender.animation\"\n    label = \"Animation\"\n    description = __doc__\n    product_type = \"animation\"\n    product_base_type = \"animation\"\n    icon = \"male\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            selected_objects = lib.get_selection()\n            for selected_object in selected_objects:\n                collection.objects.link(selected_object)\n\n            selected_collections = lib.get_selected_collections()\n            for selected_collection in selected_collections:\n                collection.children.link(selected_collection)\n        elif pre_create_data.get(\"asset_group\"):\n            # Use for Load Blend automated creation of animation instances\n            # upon loading rig files\n            obj = pre_create_data.get(\"asset_group\")\n            collection.objects.link(obj)\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context,\n                                          step=False)\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_blendScene.html","title":"create_blendScene","text":"<p>Create a Blender scene asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_blendScene.html#client.ayon_blender.plugins.create.create_blendScene.CreateBlendScene","title":"<code>CreateBlendScene</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Generic .blend export writing datablocks</p> Source code in <code>client/ayon_blender/plugins/create/create_blendScene.py</code> <pre><code>class CreateBlendScene(plugin.BlenderCreator):\n    \"\"\"Generic .blend export writing datablocks\"\"\"\n\n    identifier = \"io.ayon.creators.blender.blendscene\"\n    label = \"Blender Scene\"\n    product_type = \"blendScene\"\n    product_base_type = \"blendScene\"\n    icon = \"cubes\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n\n        instance_node = super().create(product_name,\n                                       instance_data,\n                                       pre_create_data)\n\n        if pre_create_data.get(\"use_selection\"):\n            selected_objects = lib.get_selection()\n            for selected_object in selected_objects:\n                instance_node.objects.link(selected_object)\n\n            selected_collections = lib.get_selected_collections()\n            for selected_collection in selected_collections:\n                instance_node.children.link(selected_collection)\n\n        return instance_node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_camera.html","title":"create_camera","text":"<p>Create a camera asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_camera.html#client.ayon_blender.plugins.create.create_camera.CreateCamera","title":"<code>CreateCamera</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Single baked camera</p> Source code in <code>client/ayon_blender/plugins/create/create_camera.py</code> <pre><code>class CreateCamera(plugin.BlenderCreator):\n    \"\"\"Single baked camera\"\"\"\n\n    identifier = \"io.ayon.creators.blender.camera\"\n    label = \"Camera\"\n    description = __doc__\n    product_type = \"camera\"\n    product_base_type = \"camera\"\n    icon = \"video-camera\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            selected_objects = lib.get_selection()\n            for selected_object in selected_objects:\n                collection.objects.link(selected_object)\n\n            selected_collections = lib.get_selected_collections()\n            for selected_collection in selected_collections:\n                collection.children.link(selected_collection)\n        else:\n            # Create a camera\n            plugin.deselect_all()\n            camera = bpy.data.cameras.new(product_name)\n            camera_obj = bpy.data.objects.new(product_name, camera)\n            collection.objects.link(camera_obj)\n\n            bpy.context.view_layer.objects.active = camera_obj\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_layout.html","title":"create_layout","text":"<p>Create a layout asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_layout.html#client.ayon_blender.plugins.create.create_layout.CreateLayout","title":"<code>CreateLayout</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Layout output for character rigs</p> Source code in <code>client/ayon_blender/plugins/create/create_layout.py</code> <pre><code>class CreateLayout(plugin.BlenderCreator):\n    \"\"\"Layout output for character rigs\"\"\"\n\n    identifier = \"io.ayon.creators.blender.layout\"\n    label = \"Layout\"\n    description = __doc__\n    product_type = \"layout\"\n    product_base_type = \"layout\"\n    icon = \"cubes\"\n\n    create_as_asset_group = True\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n\n        asset_group = super().create(product_name,\n                                     instance_data,\n                                     pre_create_data)\n\n        # Add selected objects to instance\n        if pre_create_data.get(\"use_selection\"):\n            bpy.context.view_layer.objects.active = asset_group\n            for obj in lib.get_selection():\n                obj.parent = asset_group\n\n        return asset_group\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_model.html","title":"create_model","text":"<p>Create a model asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_model.html#client.ayon_blender.plugins.create.create_model.CreateModel","title":"<code>CreateModel</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Polygonal static geometry</p> Source code in <code>client/ayon_blender/plugins/create/create_model.py</code> <pre><code>class CreateModel(plugin.BlenderCreator):\n    \"\"\"Polygonal static geometry\"\"\"\n\n    identifier = \"io.ayon.creators.blender.model\"\n    label = \"Model\"\n    description = __doc__\n    product_type = \"model\"\n    product_base_type = \"model\"\n    icon = \"cube\"\n\n    create_as_asset_group = True\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        asset_group = super().create(product_name,\n                                     instance_data,\n                                     pre_create_data)\n\n        # Add selected objects to instance\n        if pre_create_data.get(\"use_selection\"):\n            bpy.context.view_layer.objects.active = asset_group\n            for obj in lib.get_selection():\n                obj.parent = asset_group\n\n        return asset_group\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_pointcache.html","title":"create_pointcache","text":"<p>Create a pointcache asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_pointcache.html#client.ayon_blender.plugins.create.create_pointcache.CreatePointcache","title":"<code>CreatePointcache</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Geometrical pointcache data</p> Source code in <code>client/ayon_blender/plugins/create/create_pointcache.py</code> <pre><code>class CreatePointcache(plugin.BlenderCreator):\n    \"\"\"Geometrical pointcache data\"\"\"\n\n    identifier = \"io.ayon.creators.blender.pointcache\"\n    label = \"Point Cache\"\n    description = __doc__\n    product_type = \"pointcache\"\n    product_base_type = \"pointcache\"\n    icon = \"cubes\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            selected_objects = lib.get_selection()\n            for selected_object in selected_objects:\n                collection.objects.link(selected_object)\n\n            selected_collections = lib.get_selected_collections()\n            for selected_collection in selected_collections:\n                collection.children.link(selected_collection)\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context,\n                                          step=False)\n\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_render.html","title":"create_render","text":"<p>Create render.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_render.html#client.ayon_blender.plugins.create.create_render.CreateRender","title":"<code>CreateRender</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Create render from Compositor File Output node</p> Source code in <code>client/ayon_blender/plugins/create/create_render.py</code> <pre><code>class CreateRender(plugin.BlenderCreator):\n    \"\"\"Create render from Compositor File Output node\"\"\"\n\n    identifier = \"io.ayon.creators.blender.render\"\n    label = \"Render\"\n    description = __doc__\n    product_type = \"render\"\n    product_base_type = \"render\"\n    icon = \"eye\"\n\n    render_target = \"farm\"\n\n    def _find_compositor_node_from_create_render_setup(self) -&gt; Optional[\"bpy.types.CompositorNodeOutputFile\"]:\n        tree = lib.get_scene_node_tree()\n        for node in tree.nodes:\n            if (\n                    node.bl_idname == \"CompositorNodeOutputFile\"\n                    and node.name == \"AYON File Output\"\n            ):\n                return node\n        return None\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        tree = lib.get_scene_node_tree(ensure_exists=True)\n\n        variant: str = instance_data.get(\"variant\", self.default_variant)\n\n        if pre_create_data.get(\"create_render_setup\", False):\n            # TODO: Prepare rendering setup should always generate a new\n            #  setup, and return the relevant compositor node instead of\n            #  guessing afterwards\n            node = render_lib.prepare_rendering(variant_name=variant)\n        else:\n            # Create a Compositor node\n            node: bpy.types.CompositorNodeOutputFile = tree.nodes.new(\n                \"CompositorNodeOutputFile\"\n            )\n            project_settings = (\n                self.create_context.get_current_project_settings()\n            )\n            base_path = render_lib.get_base_render_output_path(\n                variant_name=variant,\n                # For now enforce multi-exr here since we are not connecting\n                # any inputs and it at least ensures a full path is set.\n                multi_exr=True,\n                project_settings=project_settings,\n            )\n            node.format.file_format = \"OPEN_EXR_MULTILAYER\"\n            if BLENDER_VERSION &gt;= (5, 0, 0):\n                directory, filename = os.path.split(base_path)\n                node.directory = directory\n                node.file_name = filename\n            else:\n                node.base_path = base_path\n\n        node.name = variant\n        node.label = variant\n\n        self.set_instance_data(product_name, instance_data)\n        instance = CreatedInstance(\n            self.product_type, product_name, instance_data, self\n        )\n        instance.transient_data[\"instance_node\"] = node\n        self._add_instance_to_context(instance)\n\n        self.imprint(node, instance_data)\n\n        return instance\n\n    def collect_instances(self):\n        node_tree = lib.get_scene_node_tree()\n        if not node_tree:\n            # Blender 5.0 may not have created and set a compositor group\n            return\n\n        super().collect_instances()\n\n        # TODO: Collect all Compositor nodes - even those that are not\n        #   imprinted with any data.\n        collected_nodes = {\n            created_instance.transient_data.get(\"instance_node\")\n            for created_instance in self.create_context.instances\n        }\n        collected_nodes.discard(None)\n\n        # Convert legacy instances that did not yet imprint on the\n        # compositor node itself\n        for instance in self.create_context.instances:\n            instance: CreatedInstance\n\n            # Ignore instances from other creators\n            if instance.creator_identifier != self.identifier:\n                continue\n\n            # Check if node type is the old object type\n            node = instance.transient_data[\"instance_node\"]\n\n            if not isinstance(node, bpy.types.Collection):\n                # Already new-style node\n                continue\n\n            self.log.info(f\"Converting legacy render instance: {node}\")\n            # Find the related compositor node\n            # TODO: Find the actual relevant compositor node instead of just\n            #  any\n            comp_node = self._find_compositor_node_from_create_render_setup()\n            if not comp_node:\n                raise RuntimeError(\"No compositor node found\")\n\n            instance.transient_data[\"instance_node\"] = comp_node\n            self.imprint(comp_node, instance.data_to_store())\n\n            # Delete the original object\n            bpy.data.collections.remove(node)\n\n        # Collect all remaining compositor output nodes\n        unregistered_output_nodes = [\n            node for node in node_tree.nodes\n            if node.bl_idname == \"CompositorNodeOutputFile\"\n            and node not in collected_nodes\n        ]\n        if not unregistered_output_nodes:\n            return\n\n        project_name = self.create_context.get_current_project_name()\n        project_entity = self.create_context.get_current_project_entity()\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n        for node in unregistered_output_nodes:\n            self.log.info(\"Found unregistered render output node: %s\",\n                          node.name)\n            variant = clean_name(node.name)\n            product_name = self.get_product_name(\n                project_name=project_name,\n                project_entity=project_entity,\n                folder_entity=folder_entity,\n                task_entity=task_entity,\n                variant=variant,\n                host_name=self.create_context.host_name,\n            )\n            instance_data = self.read(node)\n            instance_data.update({\n                \"folderPath\": folder_entity[\"path\"],\n                \"task\": task_entity[\"name\"],\n                \"productName\": product_name,\n                \"variant\": variant,\n            })\n\n            instance = CreatedInstance(\n                self.product_type,\n                product_name,\n                data=instance_data,\n                creator=self,\n                transient_data={\n                    \"instance_node\": node\n                }\n            )\n            self._add_instance_to_context(instance)\n\n    def get_instance_attr_defs(self):\n\n        render_target_items: dict[str, str] = {\n            \"local\": \"Local machine rendering\",\n            \"local_no_render\": \"Use existing frames (local)\",\n            \"farm\": \"Farm Rendering\",\n        }\n\n        defs: list[AbstractAttrDef] = lib.collect_animation_defs(\n            self.create_context\n        )\n        defs.extend([\n            EnumDef(\"render_target\",\n                    items=render_target_items,\n                    label=\"Render target\",\n                    default=self.render_target),\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=True),\n        ])\n        return defs\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\n                \"create_render_setup\",\n                label=\"Create Render Setup\",\n                default=False,\n                tooltip=\"Create Render Setup\",\n            ),\n\n        ]\n\n    def imprint(self, node: bpy.types.CompositorNodeOutputFile, data: dict):\n        # Use the node `mute` state to define the active state of the instance.\n        active = data.pop(\"active\", True)\n        node.mute = not active\n        super().imprint(node, data)\n\n    def read(self, node: bpy.types.CompositorNodeOutputFile) -&gt; dict:\n        # Read the active state from the node `mute` state.\n        data = super().read(node)\n\n        # On super().collect_instances() it may collect legacy render instances\n        # that are not Compositor nodes but Collection objects.\n        if isinstance(node, bpy.types.CompositorNodeOutputFile):\n            data[\"active\"] = not node.mute\n\n        return data\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_render.html#client.ayon_blender.plugins.create.create_render.clean_name","title":"<code>clean_name(name)</code>","text":"<p>Ensure variant name is valid, e.g. strip spaces from name</p> Source code in <code>client/ayon_blender/plugins/create/create_render.py</code> <pre><code>def clean_name(name: str) -&gt; str:\n    \"\"\"Ensure variant name is valid, e.g. strip spaces from name\"\"\"\n    # Entity name regex taken from server code which also applies to\n    # product names (which usually\n    name_regex = r\"^[a-zA-Z0-9_]([a-zA-Z0-9_\\.\\-]*[a-zA-Z0-9_])?$\"\n\n    # Replace space with underscore\n    clean = name.replace(\" \", \"\")\n    # Strip out any remaining invalid characters\n    clean = re.sub(r\"[^a-zA-Z0-9_.-]\", \"\", clean)\n    # Ensure start and end characters are not a dot or dash\n    clean = clean.strip(\".-\")\n    # Ensure name is at least 1 character long\n    if not clean:\n        # Fallback to a default name\n        clean = \"Main\"\n\n    if not re.match(name_regex, clean):\n        raise ValueError(f\"Failed to create valid name for {name}\")\n    return clean\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_review.html","title":"create_review","text":"<p>Create review.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_review.html#client.ayon_blender.plugins.create.create_review.CreateReview","title":"<code>CreateReview</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Render viewport preview for review purposes</p> Source code in <code>client/ayon_blender/plugins/create/create_review.py</code> <pre><code>class CreateReview(plugin.BlenderCreator):\n    \"\"\"Render viewport preview for review purposes\"\"\"\n\n    identifier = \"io.ayon.creators.blender.review\"\n    label = \"Review\"\n    description = __doc__\n    product_type = \"review\"\n    product_base_type = \"review\"\n    icon = \"video-camera\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        if pre_create_data.get(\"use_selection\"):\n            selected_objects = lib.get_selection()\n            for selected_object in selected_objects:\n                collection.objects.link(selected_object)\n\n            selected_collections = lib.get_selected_collections()\n            for selected_collection in selected_collections:\n                collection.children.link(selected_collection)\n\n        return collection\n\n    def get_instance_attr_defs(self):\n        defs = lib.collect_animation_defs(self.create_context)\n\n        return defs\n\n    def get_publish_families(self):\n        return [\"review\", \"review.playblast\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_rig.html","title":"create_rig","text":"<p>Create a rig asset.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_rig.html#client.ayon_blender.plugins.create.create_rig.CreateRig","title":"<code>CreateRig</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Artist-friendly rig with controls to direct motion</p> Source code in <code>client/ayon_blender/plugins/create/create_rig.py</code> <pre><code>class CreateRig(plugin.BlenderCreator):\n    \"\"\"Artist-friendly rig with controls to direct motion\"\"\"\n\n    identifier = \"io.ayon.creators.blender.rig\"\n    label = \"Rig\"\n    description = __doc__\n    product_type = \"rig\"\n    product_base_type = \"rig\"\n    icon = \"wheelchair\"\n\n    create_as_asset_group = True\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        asset_group = super().create(product_name,\n                                     instance_data,\n                                     pre_create_data)\n\n        # Add selected objects to instance\n        if pre_create_data.get(\"use_selection\"):\n            bpy.context.view_layer.objects.active = asset_group\n            for obj in lib.get_selection():\n                obj.parent = asset_group\n\n        return asset_group\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_usd.html","title":"create_usd","text":"<p>Create a USD Export.</p>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_usd.html#client.ayon_blender.plugins.create.create_usd.CreateUSD","title":"<code>CreateUSD</code>","text":"<p>               Bases: <code>BlenderCreator</code></p> <p>Create USD Export</p> Source code in <code>client/ayon_blender/plugins/create/create_usd.py</code> <pre><code>class CreateUSD(plugin.BlenderCreator):\n    \"\"\"Create USD Export\"\"\"\n\n    identifier = \"io.ayon.creators.blender.usd\"\n    name = \"usdMain\"\n    label = \"USD\"\n    description = __doc__\n    product_type = \"usd\"\n    product_base_type = \"usd\"\n    icon = \"gears\"\n\n    def create(\n        self, product_name: str, instance_data: dict, pre_create_data: dict\n    ):\n        # Run parent create method\n        collection = super().create(\n            product_name, instance_data, pre_create_data\n        )\n\n        objects = []\n        selected_collections = []\n        if pre_create_data.get(\"use_selection\"):\n            objects = lib.get_selection()\n            selected_collections = lib.get_selected_collections()\n\n        # Create template hierarchy\n        if pre_create_data.get(\"createAssetTemplateHierarchy\", False):\n            folder_path = instance_data[\"folderPath\"]\n            folder_name = folder_path.rsplit(\"/\", 1)[-1]\n\n            root = bpy.data.objects.new(folder_name, object_data=None)\n            bpy.context.scene.collection.objects.link(root)\n\n            geo = bpy.data.objects.new(\"geo\", object_data=None)\n            bpy.context.scene.collection.objects.link(geo)\n            geo.parent = root\n\n            # Parent members with geo.\n            for obj in objects:\n                obj.parent = geo\n\n            # Override the objects list to include only the root object.\n            objects = [root]\n\n        for obj in objects:\n            collection.objects.link(obj)\n\n        for selected_collection in selected_collections:\n            collection.children.link(selected_collection)\n\n        return collection\n\n    def get_pre_create_attr_defs(self):\n        defs = super().get_pre_create_attr_defs()\n        defs.extend([\n            BoolDef(\"createAssetTemplateHierarchy\",\n                    label=\"Create asset hierarchy\",\n                    tooltip=(\n                        \"Create the root hierarchy for '{folder_name}/geo'\"\n                        \" as per the USD Asset Structure guidelines to\"\n                        \" add your geometry into.\"\n                    ),\n                    default=False)\n        ])\n        return defs\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_blender/plugins/create/create_workfile.html#client.ayon_blender.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>BlenderCreator</code>, <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> <p>The workfile instance stores its data on the <code>AYON_WORKFILE</code> collection as custom attributes, because unlike other instances it doesn't have an instance node of its own.</p> Source code in <code>client/ayon_blender/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(BlenderCreator, AutoCreator):\n    \"\"\"Workfile auto-creator.\n\n    The workfile instance stores its data on the `AYON_WORKFILE` collection\n    as custom attributes, because unlike other instances it doesn't have an\n    instance node of its own.\n\n    \"\"\"\n    identifier = \"io.ayon.creators.blender.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    product_base_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    def create(self):\n        \"\"\"Create workfile instances.\"\"\"\n        workfile_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ),\n            None,\n        )\n\n        project_entity = self.create_context.get_current_project_entity()\n        project_name = project_entity[\"name\"]\n        folder_entity = self.create_context.get_current_folder_entity()\n        folder_path = folder_entity[\"path\"]\n        task_entity = self.create_context.get_current_task_entity()\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        if not workfile_instance:\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                task_name,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": self.default_variant,\n            }\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    task_name,\n                    host_name,\n                    workfile_instance,\n                )\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            workfile_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(workfile_instance)\n\n        elif (\n            workfile_instance[\"folderPath\"]  != folder_path\n            or workfile_instance[\"task\"] != task_name\n        ):\n            # Update instance context if it's different\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n            )\n\n            workfile_instance[\"folderPath\"] = folder_path\n            workfile_instance[\"task\"] = task_name\n            workfile_instance[\"productName\"] = product_name\n\n    def collect_instances(self):\n        instance_node = bpy.data.collections.get(AYON_INSTANCES)\n        if not instance_node:\n            return\n\n        property = instance_node.get(AYON_PROPERTY)\n        if not property:\n            return\n\n        # Create instance object from existing data\n        instance = CreatedInstance.from_existing(\n            instance_data=property.to_dict(),\n            creator=self\n        )\n        instance.transient_data[\"instance_node\"] = instance_node\n\n        # Add instance to create context\n        self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        \"\"\"Override abstract method from BlenderCreator.\n        Store changes of existing instances so they can be recollected.\n\n        Args:\n            update_list(List[UpdateData]): Changed instances\n                and their changes, as a list of tuples.\n        \"\"\"\n\n        for created_instance, _ in update_list:\n            data = created_instance.data_to_store()\n            node = created_instance.transient_data.get(\"instance_node\")\n            if not node:\n                node = self._ensure_ayon_instances_collection()\n            else:\n                node = self._transfer_workfile_property(node)\n\n            self.imprint(node, data)\n\n            created_instance.transient_data[\"instance_node\"] = node\n\n    def _transfer_workfile_property(\n            self, node: bpy.types.Collection)-&gt; bpy.types.Collection:\n        \"\"\"Transfer all workfile-related instance data from\n        AYON_CONTAINERS to AYON_INSTANCES if any. Backward\n        compatibility only.\n\n        Args:\n            node (bpy.types.Collection): instance node\n\n        Returns:\n            bpy.types.Collection: instance node\n        \"\"\"\n        if (\n            not isinstance(node, bpy.types.Collection)\n            or node.name != AYON_CONTAINERS\n            or AYON_PROPERTY not in node\n        ):\n            return node\n\n        instance_node = self._ensure_ayon_instances_collection()\n        instance_node[AYON_PROPERTY] = node.get(AYON_PROPERTY)\n        del node[AYON_PROPERTY]\n        return instance_node\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            node = instance.transient_data.get(\"instance_node\")\n            if node:\n                if node.children or node.objects:\n                    # If it has members, keep collection around\n                    # but only remove imprinted data\n                    del node[AYON_PROPERTY]\n                else:\n                    # Delete the collection\n                    bpy.data.collections.remove(node)\n\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_workfile.html#client.ayon_blender.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create()</code>","text":"<p>Create workfile instances.</p> Source code in <code>client/ayon_blender/plugins/create/create_workfile.py</code> <pre><code>def create(self):\n    \"\"\"Create workfile instances.\"\"\"\n    workfile_instance = next(\n        (\n            instance for instance in self.create_context.instances\n            if instance.creator_identifier == self.identifier\n        ),\n        None,\n    )\n\n    project_entity = self.create_context.get_current_project_entity()\n    project_name = project_entity[\"name\"]\n    folder_entity = self.create_context.get_current_folder_entity()\n    folder_path = folder_entity[\"path\"]\n    task_entity = self.create_context.get_current_task_entity()\n    task_name = task_entity[\"name\"]\n    host_name = self.create_context.host_name\n\n    if not workfile_instance:\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            task_name,\n            host_name,\n        )\n        data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": self.default_variant,\n        }\n        data.update(\n            self.get_dynamic_data(\n                project_name,\n                folder_entity,\n                task_entity,\n                task_name,\n                host_name,\n                workfile_instance,\n            )\n        )\n        self.log.info(\"Auto-creating workfile instance...\")\n        workfile_instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self._add_instance_to_context(workfile_instance)\n\n    elif (\n        workfile_instance[\"folderPath\"]  != folder_path\n        or workfile_instance[\"task\"] != task_name\n    ):\n        # Update instance context if it's different\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            self.default_variant,\n            host_name,\n        )\n\n        workfile_instance[\"folderPath\"] = folder_path\n        workfile_instance[\"task\"] = task_name\n        workfile_instance[\"productName\"] = product_name\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/create/create_workfile.html#client.ayon_blender.plugins.create.create_workfile.CreateWorkfile.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Override abstract method from BlenderCreator. Store changes of existing instances so they can be recollected.</p> <p>Parameters:</p> Name Type Description Default <code>update_list</code> <code>List[UpdateData]</code> <p>Changed instances and their changes, as a list of tuples.</p> required Source code in <code>client/ayon_blender/plugins/create/create_workfile.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Override abstract method from BlenderCreator.\n    Store changes of existing instances so they can be recollected.\n\n    Args:\n        update_list(List[UpdateData]): Changed instances\n            and their changes, as a list of tuples.\n    \"\"\"\n\n    for created_instance, _ in update_list:\n        data = created_instance.data_to_store()\n        node = created_instance.transient_data.get(\"instance_node\")\n        if not node:\n            node = self._ensure_ayon_instances_collection()\n        else:\n            node = self._transfer_workfile_property(node)\n\n        self.imprint(node, data)\n\n        created_instance.transient_data[\"instance_node\"] = node\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/import_workfile.html","title":"import_workfile","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/import_workfile.html#client.ayon_blender.plugins.load.import_workfile.AppendBlendLoader","title":"<code>AppendBlendLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Append workfile in Blender (unmanaged)</p> Warning <p>The loaded content will be unmanaged and is not visible in the scene inventory. It's purely intended to merge content into your scene so you could also use it as a new base.</p> Source code in <code>client/ayon_blender/plugins/load/import_workfile.py</code> <pre><code>class AppendBlendLoader(plugin.BlenderLoader):\n    \"\"\"Append workfile in Blender (unmanaged)\n\n    Warning:\n        The loaded content will be unmanaged and is *not* visible in the\n        scene inventory. It's purely intended to merge content into your scene\n        so you could also use it as a new base.\n    \"\"\"\n\n    representations = {\"blend\"}\n    product_types = {\"workfile\"}\n\n    label = \"Append Workfile\"\n    order = 9\n    icon = \"arrow-circle-down\"\n    color = \"#775555\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        path = self.filepath_from_context(context)\n        append_workfile(context, path, False)\n\n        # We do not containerize imported content, it remains unmanaged\n        return\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html","title":"load_action","text":"<p>Load an action in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader","title":"<code>BlendActionLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load action from a .blend file.</p> Warning <p>Loading the same asset more then once is not properly supported at the moment.</p> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>class BlendActionLoader(plugin.BlenderLoader):\n    \"\"\"Load action from a .blend file.\n\n    Warning:\n        Loading the same asset more then once is not properly supported at the\n        moment.\n    \"\"\"\n\n    product_types = {\"action\"}\n    representations = {\"blend\"}\n\n    label = \"Link Action\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    options = [\n        BoolDef(\n            \"use_fake_user\",\n            label=\"Use Fake User\",\n            default=True,\n            tooltip=\"Set the fake user for the loaded asset.\",\n        )\n    ]\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        lib_container = plugin.prepare_scene_name(folder_name, product_name)\n\n        container = bpy.data.collections.new(lib_container)\n        containerise_existing(\n            container,\n            name,\n            namespace,\n            context,\n            self.__class__.__name__,\n        )\n\n        container_metadata = container.get(AYON_PROPERTY)\n\n\n        relative = bpy.context.preferences.filepaths.use_relative_paths\n        with bpy.data.libraries.load(\n            libpath, link=True, relative=relative\n        ) as (data_from, data_to):\n            data_to.actions = data_from.actions\n        if not data_to.actions:\n            raise LoadError(\n                \"No action found in the file, please check if \"\n                \"there is any action datablock in the blend file.\"\n            )\n        container = data_to.actions[0]\n\n        empty_obj = bpy.data.objects.new(name=name, object_data=None)\n        empty_obj.animation_data_create()\n        empty_obj.animation_data.action = container\n        empty_obj.animation_data.action.use_fake_user = options.get(\n            \"use_fake_user\", True\n        )\n        # Save the list of objects in the metadata container\n        container_metadata[\"libpath\"] = libpath\n        container_metadata[\"lib_container\"] = lib_container\n        container_metadata[\"objects\"] = empty_obj\n        container_metadata[\"action\"] = empty_obj.animation_data.action\n\n        metadata_update(container, container_metadata)\n        bpy.ops.object.select_all(action='DESELECT')\n        self[:] = [empty_obj]\n\n        return container\n\n    def update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        collection = container[\"node\"]\n        libpath = self.filepath_from_context(context)\n        action = container[\"action\"]\n        if action.library:\n            action.library.name = os.path.basename(libpath)\n            action.library.filepath = libpath\n\n        metadata_update(\n            collection, {\"representation\": str(repre_entity[\"id\"])}\n        )\n\n    def remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (ayon:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n\n        collection = bpy.data.collections.get(\n            container[\"objectName\"]\n        )\n        if not collection:\n            return False\n\n        action = container[\"action\"]\n        bpy.data.actions.remove(action)\n        bpy.data.collections.remove(collection)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n    lib_container = plugin.prepare_scene_name(folder_name, product_name)\n\n    container = bpy.data.collections.new(lib_container)\n    containerise_existing(\n        container,\n        name,\n        namespace,\n        context,\n        self.__class__.__name__,\n    )\n\n    container_metadata = container.get(AYON_PROPERTY)\n\n\n    relative = bpy.context.preferences.filepaths.use_relative_paths\n    with bpy.data.libraries.load(\n        libpath, link=True, relative=relative\n    ) as (data_from, data_to):\n        data_to.actions = data_from.actions\n    if not data_to.actions:\n        raise LoadError(\n            \"No action found in the file, please check if \"\n            \"there is any action datablock in the blend file.\"\n        )\n    container = data_to.actions[0]\n\n    empty_obj = bpy.data.objects.new(name=name, object_data=None)\n    empty_obj.animation_data_create()\n    empty_obj.animation_data.action = container\n    empty_obj.animation_data.action.use_fake_user = options.get(\n        \"use_fake_user\", True\n    )\n    # Save the list of objects in the metadata container\n    container_metadata[\"libpath\"] = libpath\n    container_metadata[\"lib_container\"] = lib_container\n    container_metadata[\"objects\"] = empty_obj\n    container_metadata[\"action\"] = empty_obj.animation_data.action\n\n    metadata_update(container, container_metadata)\n    bpy.ops.object.select_all(action='DESELECT')\n    self[:] = [empty_obj]\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>def remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (ayon:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n\n    collection = bpy.data.collections.get(\n        container[\"objectName\"]\n    )\n    if not collection:\n        return False\n\n    action = container[\"action\"]\n    bpy.data.actions.remove(action)\n    bpy.data.collections.remove(collection)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_action.html#client.ayon_blender.plugins.load.load_action.BlendActionLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_action.py</code> <pre><code>def update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    collection = container[\"node\"]\n    libpath = self.filepath_from_context(context)\n    action = container[\"action\"]\n    if action.library:\n        action.library.name = os.path.basename(libpath)\n        action.library.filepath = libpath\n\n    metadata_update(\n        collection, {\"representation\": str(repre_entity[\"id\"])}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html","title":"load_audio","text":"<p>Load audio in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader","title":"<code>AudioLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load audio in Blender.</p> Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>class AudioLoader(plugin.BlenderLoader):\n    \"\"\"Load audio in Blender.\"\"\"\n\n    product_types = {\"audio\"}\n    representations = {\"wav\"}\n\n    label = \"Load Audio\"\n    icon = \"volume-up\"\n    color = \"orange\"\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        add_to_ayon_container(asset_group)\n\n        # Blender needs the Sequence Editor in the current window, to be able\n        # to load the audio. We take one of the areas in the window, save its\n        # type, and switch to the Sequence Editor. After loading the audio,\n        # we switch back to the previous area.\n        window_manager = bpy.context.window_manager\n        old_type = window_manager.windows[-1].screen.areas[0].type\n        window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n        # We override the context to load the audio in the sequence editor.\n        oc = bpy.context.copy()\n        oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n        with bpy.context.temp_override(**oc):\n            bpy.ops.sequencer.sound_strip_add(filepath=libpath, frame_start=1)\n\n        window_manager.windows[-1].screen.areas[0].type = old_type\n\n        p = Path(libpath)\n        audio = p.name\n\n        asset_group[AYON_PROPERTY] = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"audio\": audio,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        objects = []\n        self[:] = objects\n        return [objects]\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update an audio strip in the sequence editor.\n\n        Arguments:\n            container (ayon:container-1.0): Container to update,\n                from `host.ls()`.\n            representation (ayon:representation-1.0): Representation to\n                update, from `host.ls()`.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(self.filepath_from_context(context))\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n\n        metadata = asset_group.get(AYON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        old_audio = container[\"audio\"]\n        p = Path(libpath)\n        new_audio = p.name\n\n        # Blender needs the Sequence Editor in the current window, to be able\n        # to update the audio. We take one of the areas in the window, save its\n        # type, and switch to the Sequence Editor. After updating the audio,\n        # we switch back to the previous area.\n        window_manager = bpy.context.window_manager\n        old_type = window_manager.windows[-1].screen.areas[0].type\n        window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n        # We override the context to load the audio in the sequence editor.\n        oc = bpy.context.copy()\n        oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n        with bpy.context.temp_override(**oc):\n            # We deselect all sequencer strips, and then select the one we\n            # need to remove.\n            bpy.ops.sequencer.select_all(action='DESELECT')\n            scene = bpy.context.scene\n            scene.sequence_editor.sequences_all[old_audio].select = True\n\n            bpy.ops.sequencer.delete()\n            bpy.data.sounds.remove(bpy.data.sounds[old_audio])\n\n            bpy.ops.sequencer.sound_strip_add(\n                filepath=str(libpath), frame_start=1)\n\n        window_manager.windows[-1].screen.areas[0].type = old_type\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"parent\"] = repre_entity[\"versionId\"]\n        metadata[\"audio\"] = new_audio\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an audio strip from the sequence editor and the container.\n\n        Arguments:\n            container (ayon:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        audio = container[\"audio\"]\n\n        # Blender needs the Sequence Editor in the current window, to be able\n        # to remove the audio. We take one of the areas in the window, save its\n        # type, and switch to the Sequence Editor. After removing the audio,\n        # we switch back to the previous area.\n        window_manager = bpy.context.window_manager\n        old_type = window_manager.windows[-1].screen.areas[0].type\n        window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n        # We override the context to load the audio in the sequence editor.\n        oc = bpy.context.copy()\n        oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n        with bpy.context.temp_override(**oc):\n            # We deselect all sequencer strips, and then select the one we\n            # need to remove.\n            bpy.ops.sequencer.select_all(action='DESELECT')\n            scene = bpy.context.scene\n            scene.sequence_editor.sequences_all[audio].select = True\n            bpy.ops.sequencer.delete()\n\n        window_manager.windows[-1].screen.areas[0].type = old_type\n\n        bpy.data.sounds.remove(bpy.data.sounds[audio])\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an audio strip from the sequence editor and the container.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an audio strip from the sequence editor and the container.\n\n    Arguments:\n        container (ayon:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    audio = container[\"audio\"]\n\n    # Blender needs the Sequence Editor in the current window, to be able\n    # to remove the audio. We take one of the areas in the window, save its\n    # type, and switch to the Sequence Editor. After removing the audio,\n    # we switch back to the previous area.\n    window_manager = bpy.context.window_manager\n    old_type = window_manager.windows[-1].screen.areas[0].type\n    window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n    # We override the context to load the audio in the sequence editor.\n    oc = bpy.context.copy()\n    oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n    with bpy.context.temp_override(**oc):\n        # We deselect all sequencer strips, and then select the one we\n        # need to remove.\n        bpy.ops.sequencer.select_all(action='DESELECT')\n        scene = bpy.context.scene\n        scene.sequence_editor.sequences_all[audio].select = True\n        bpy.ops.sequencer.delete()\n\n    window_manager.windows[-1].screen.areas[0].type = old_type\n\n    bpy.data.sounds.remove(bpy.data.sounds[audio])\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update an audio strip in the sequence editor.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to update, from <code>host.ls()</code>.</p> required <code>representation (ayon</code> <p>representation-1.0): Representation to update, from <code>host.ls()</code>.</p> required Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update an audio strip in the sequence editor.\n\n    Arguments:\n        container (ayon:container-1.0): Container to update,\n            from `host.ls()`.\n        representation (ayon:representation-1.0): Representation to\n            update, from `host.ls()`.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(self.filepath_from_context(context))\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n\n    metadata = asset_group.get(AYON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    old_audio = container[\"audio\"]\n    p = Path(libpath)\n    new_audio = p.name\n\n    # Blender needs the Sequence Editor in the current window, to be able\n    # to update the audio. We take one of the areas in the window, save its\n    # type, and switch to the Sequence Editor. After updating the audio,\n    # we switch back to the previous area.\n    window_manager = bpy.context.window_manager\n    old_type = window_manager.windows[-1].screen.areas[0].type\n    window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n    # We override the context to load the audio in the sequence editor.\n    oc = bpy.context.copy()\n    oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n    with bpy.context.temp_override(**oc):\n        # We deselect all sequencer strips, and then select the one we\n        # need to remove.\n        bpy.ops.sequencer.select_all(action='DESELECT')\n        scene = bpy.context.scene\n        scene.sequence_editor.sequences_all[old_audio].select = True\n\n        bpy.ops.sequencer.delete()\n        bpy.data.sounds.remove(bpy.data.sounds[old_audio])\n\n        bpy.ops.sequencer.sound_strip_add(\n            filepath=str(libpath), frame_start=1)\n\n    window_manager.windows[-1].screen.areas[0].type = old_type\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"parent\"] = repre_entity[\"versionId\"]\n    metadata[\"audio\"] = new_audio\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_audio.html#client.ayon_blender.plugins.load.load_audio.AudioLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_audio.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    add_to_ayon_container(asset_group)\n\n    # Blender needs the Sequence Editor in the current window, to be able\n    # to load the audio. We take one of the areas in the window, save its\n    # type, and switch to the Sequence Editor. After loading the audio,\n    # we switch back to the previous area.\n    window_manager = bpy.context.window_manager\n    old_type = window_manager.windows[-1].screen.areas[0].type\n    window_manager.windows[-1].screen.areas[0].type = \"SEQUENCE_EDITOR\"\n\n    # We override the context to load the audio in the sequence editor.\n    oc = bpy.context.copy()\n    oc[\"area\"] = window_manager.windows[-1].screen.areas[0]\n\n    with bpy.context.temp_override(**oc):\n        bpy.ops.sequencer.sound_strip_add(filepath=libpath, frame_start=1)\n\n    window_manager.windows[-1].screen.areas[0].type = old_type\n\n    p = Path(libpath)\n    audio = p.name\n\n    asset_group[AYON_PROPERTY] = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"audio\": audio,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    objects = []\n    self[:] = objects\n    return [objects]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html","title":"load_blend","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader","title":"<code>BlendLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load assets from a .blend file.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>class BlendLoader(plugin.BlenderLoader):\n    \"\"\"Load assets from a .blend file.\"\"\"\n\n    product_types = {\"model\", \"rig\", \"layout\", \"camera\", \"animation\"}\n    representations = {\"blend\"}\n\n    label = \"Append Blend\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    # From settings\n    create_animation_instance_on_load = True\n\n    @staticmethod\n    def _get_asset_container(objects):\n        \"\"\"Return the root 'asset' group from the loaded objects.\n\n        If not found, we create an asset group to manage the objects in\n        instead. So that we encapsulate all loaded data under one object that\n        will act as the container.\n        \"\"\"\n        empties = [obj for obj in objects if obj.type == 'EMPTY']\n\n        for empty in empties:\n            # datablock is not allowed to\n            empty_ayon_property = get_ayon_property(empty)\n            if empty_ayon_property and empty.parent is None:\n                return empty\n\n        # In this case - the loaded objects have no asset group. And we really\n        # want to create an asset group so that we can manage the objects\n        # inside it. So, in this case - we create one and make it the root.\n        root = bpy.data.objects.new(\"root\", None)\n\n        # In this case we reparent all root objects to our root\n        for obj in objects:\n            if not obj.parent:\n                obj.parent = root\n\n        return root\n\n    @staticmethod\n    def get_all_container_parents(asset_group):\n        parent_containers = []\n        parent = asset_group.parent\n        while parent:\n            if parent.get(AYON_PROPERTY):\n                parent_containers.append(parent)\n            parent = parent.parent\n\n        return parent_containers\n\n    def _post_process_layout(self, container, asset, representation):\n\n        rigs = [\n            obj for obj in container.children_recursive\n            if (\n                obj.type == 'EMPTY' and\n                obj.get(AYON_PROPERTY) and\n                obj.get(AYON_PROPERTY).get('family') == 'rig'\n            )\n        ]\n        if not rigs:\n            return\n        # Create animation instances for each rig\n        for rig in rigs:\n            create_animation_instance(rig)\n\n    def _process_data(self, libpath, group_name):\n        # Append all the data from the .blend file\n        names_by_attr: dict[str, list[str]] = {}\n        with bpy.data.libraries.load(\n            libpath, link=False, relative=False\n        ) as (data_from, data_to):\n            for attr in dir(data_to):\n                values = getattr(data_from, attr)\n                # store copy of list of names because the main list will\n                # be replaced with the data from the library after the context\n                names_by_attr[attr] = list(values)\n                setattr(data_to, attr, values)\n\n        # Rename the object to add the asset name\n        members = []\n        for attr in dir(data_to):\n            from_names: list[str] = names_by_attr[attr]\n            for from_name, data in zip(from_names, getattr(data_to, attr)):\n                data.name = f\"{group_name}:{from_name}\"\n                members.append(data)\n\n        container = self._get_asset_container(data_to.objects)\n        container.name = group_name\n        container.empty_display_type = 'SINGLE_ARROW'\n\n        # Link the collection to the scene\n        bpy.context.scene.collection.objects.link(container)\n\n        # Link all the container children to the collection\n        for obj in container.children_recursive:\n            bpy.context.scene.collection.objects.link(obj)\n\n        # Remove the library from the blend file\n        filepath = bpy.path.basename(libpath)\n        # Blender has a limit of 63 characters for any data name.\n        # If the filename is longer, it will be truncated for blender\n        # version elder than 5.0\n        if get_blender_version() &lt; (5, 0, 0) and len(filepath) &gt; 63:\n            filepath = filepath[:63]\n        library = bpy.data.libraries.get(filepath)\n        bpy.data.libraries.remove(library)\n\n        return container, members\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[dict] = None\n    ) -&gt; Optional[list]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        try:\n            product_type = context[\"product\"][\"productType\"]\n        except ValueError:\n            product_type = \"model\"\n\n        representation = context[\"representation\"][\"id\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        container, members = self._process_data(libpath, group_name)\n\n        if self.create_animation_instance_on_load:\n            if product_type == \"layout\":\n                self._post_process_layout(container, folder_name, representation)\n\n            if product_type == \"rig\":\n                create_animation_instance(container)\n\n        add_to_ayon_container(container)\n\n        data = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        container[AYON_PROPERTY] = data\n\n        objects = [\n            obj for obj in bpy.data.objects\n            if obj.name.startswith(f\"{group_name}:\")\n        ]\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: dict, context: dict):\n        \"\"\"\n        Update the loaded asset.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(group_name)\n        libpath = Path(self.filepath_from_context(context)).as_posix()\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n\n        transform = asset_group.matrix_basis.copy()\n        old_data = dict(asset_group.get(AYON_PROPERTY))\n        old_members = old_data.get(\"members\", [])\n        parent = asset_group.parent\n        users_collections = asset_group.users_collection\n\n        actions = {}\n        objects_with_anim = [\n            obj for obj in asset_group.children_recursive\n            if obj.animation_data]\n        for obj in objects_with_anim:\n            # Check if the object has an action and, if so, add it to a dict\n            # so we can restore it later. Save and restore the action only\n            # if it wasn't originally loaded from the current asset.\n            if obj.animation_data.action not in old_members:\n                actions[obj.name] = obj.animation_data.action\n\n        self.exec_remove(container)\n\n        asset_group, members = self._process_data(libpath, group_name)\n\n        add_to_ayon_container(asset_group)\n\n        asset_group.matrix_basis = transform\n        asset_group.parent = parent\n\n        # Restore the actions\n        for obj in asset_group.children_recursive:\n            if obj.name in actions:\n                if not obj.animation_data:\n                    obj.animation_data_create()\n                obj.animation_data.action = actions[obj.name]\n\n        # Restore the old data, but reset members, as they don't exist anymore\n        # This avoids a crash, because the memory addresses of those members\n        # are not valid anymore\n        old_data[\"members\"] = []\n        asset_group[AYON_PROPERTY] = old_data\n\n        new_data = {\n            \"libpath\": libpath,\n            \"representation\": repre_entity[\"id\"],\n            \"parent\": repre_entity[\"versionId\"],\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        imprint(asset_group, new_data)\n\n        all_objects = [asset_group] + list(asset_group.children_recursive)\n        for users_collection in users_collections:\n            if asset_group.name not in users_collection.objects:\n                for obj in all_objects:\n                    users_collection.objects.link(obj)\n        if bpy.context.scene.collection not in users_collections:\n            for obj in all_objects:\n                bpy.context.scene.collection.objects.unlink(obj)\n\n        # We need to update all the parent container members\n        parent_containers = self.get_all_container_parents(asset_group)\n\n        for parent_container in parent_containers:\n            parent_members = parent_container[AYON_PROPERTY][\"members\"]\n            parent_container[AYON_PROPERTY][\"members\"] = (\n                parent_members + members)\n\n    def exec_remove(self, container: dict) -&gt; bool:\n        \"\"\"\n        Remove an existing container from a Blender scene.\n        \"\"\"\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(group_name)\n\n        attrs = [\n            attr for attr in dir(bpy.data)\n            if isinstance(\n                getattr(bpy.data, attr),\n                bpy.types.bpy_prop_collection\n            )\n        ]\n\n        members = asset_group.get(AYON_PROPERTY).get(\"members\", [])\n\n        # We need to update all the parent container members\n        parent_containers = self.get_all_container_parents(asset_group)\n\n        for parent in parent_containers:\n            parent.get(AYON_PROPERTY)[\"members\"] = list(filter(\n                lambda i: i not in members,\n                parent.get(AYON_PROPERTY).get(\"members\", [])))\n\n        for attr in attrs:\n            for data in getattr(bpy.data, attr):\n                if data in members:\n                    # Skip the asset group\n                    if data == asset_group:\n                        continue\n                    getattr(bpy.data, attr).remove(data)\n\n        bpy.data.objects.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>def exec_remove(self, container: dict) -&gt; bool:\n    \"\"\"\n    Remove an existing container from a Blender scene.\n    \"\"\"\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(group_name)\n\n    attrs = [\n        attr for attr in dir(bpy.data)\n        if isinstance(\n            getattr(bpy.data, attr),\n            bpy.types.bpy_prop_collection\n        )\n    ]\n\n    members = asset_group.get(AYON_PROPERTY).get(\"members\", [])\n\n    # We need to update all the parent container members\n    parent_containers = self.get_all_container_parents(asset_group)\n\n    for parent in parent_containers:\n        parent.get(AYON_PROPERTY)[\"members\"] = list(filter(\n            lambda i: i not in members,\n            parent.get(AYON_PROPERTY).get(\"members\", [])))\n\n    for attr in attrs:\n        for data in getattr(bpy.data, attr):\n            if data in members:\n                # Skip the asset group\n                if data == asset_group:\n                    continue\n                getattr(bpy.data, attr).remove(data)\n\n    bpy.data.objects.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>def exec_update(self, container: dict, context: dict):\n    \"\"\"\n    Update the loaded asset.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(group_name)\n    libpath = Path(self.filepath_from_context(context)).as_posix()\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n\n    transform = asset_group.matrix_basis.copy()\n    old_data = dict(asset_group.get(AYON_PROPERTY))\n    old_members = old_data.get(\"members\", [])\n    parent = asset_group.parent\n    users_collections = asset_group.users_collection\n\n    actions = {}\n    objects_with_anim = [\n        obj for obj in asset_group.children_recursive\n        if obj.animation_data]\n    for obj in objects_with_anim:\n        # Check if the object has an action and, if so, add it to a dict\n        # so we can restore it later. Save and restore the action only\n        # if it wasn't originally loaded from the current asset.\n        if obj.animation_data.action not in old_members:\n            actions[obj.name] = obj.animation_data.action\n\n    self.exec_remove(container)\n\n    asset_group, members = self._process_data(libpath, group_name)\n\n    add_to_ayon_container(asset_group)\n\n    asset_group.matrix_basis = transform\n    asset_group.parent = parent\n\n    # Restore the actions\n    for obj in asset_group.children_recursive:\n        if obj.name in actions:\n            if not obj.animation_data:\n                obj.animation_data_create()\n            obj.animation_data.action = actions[obj.name]\n\n    # Restore the old data, but reset members, as they don't exist anymore\n    # This avoids a crash, because the memory addresses of those members\n    # are not valid anymore\n    old_data[\"members\"] = []\n    asset_group[AYON_PROPERTY] = old_data\n\n    new_data = {\n        \"libpath\": libpath,\n        \"representation\": repre_entity[\"id\"],\n        \"parent\": repre_entity[\"versionId\"],\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    imprint(asset_group, new_data)\n\n    all_objects = [asset_group] + list(asset_group.children_recursive)\n    for users_collection in users_collections:\n        if asset_group.name not in users_collection.objects:\n            for obj in all_objects:\n                users_collection.objects.link(obj)\n    if bpy.context.scene.collection not in users_collections:\n        for obj in all_objects:\n            bpy.context.scene.collection.objects.unlink(obj)\n\n    # We need to update all the parent container members\n    parent_containers = self.get_all_container_parents(asset_group)\n\n    for parent_container in parent_containers:\n        parent_members = parent_container[AYON_PROPERTY][\"members\"]\n        parent_container[AYON_PROPERTY][\"members\"] = (\n            parent_members + members)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend.html#client.ayon_blender.plugins.load.load_blend.BlendLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_blend.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[dict] = None\n) -&gt; Optional[list]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    try:\n        product_type = context[\"product\"][\"productType\"]\n    except ValueError:\n        product_type = \"model\"\n\n    representation = context[\"representation\"][\"id\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    container, members = self._process_data(libpath, group_name)\n\n    if self.create_animation_instance_on_load:\n        if product_type == \"layout\":\n            self._post_process_layout(container, folder_name, representation)\n\n        if product_type == \"rig\":\n            create_animation_instance(container)\n\n    add_to_ayon_container(container)\n\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    container[AYON_PROPERTY] = data\n\n    objects = [\n        obj for obj in bpy.data.objects\n        if obj.name.startswith(f\"{group_name}:\")\n    ]\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend_link.html","title":"load_blend_link","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend_link.html#client.ayon_blender.plugins.load.load_blend_link.BlendLinkLoader","title":"<code>BlendLinkLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Link assets from a .blend file.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend_link.py</code> <pre><code>class BlendLinkLoader(plugin.BlenderLoader):\n    \"\"\"Link assets from a .blend file.\"\"\"\n\n    product_types = {\n        \"model\", \"camera\", \"rig\",\n        \"layout\", \"blendScene\",\n        \"animation\", \"workfile\"\n    }\n    representations = {\"blend\"}\n\n    label = \"Link Blend\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    options = [\n        BoolDef(\n            \"addOverride\",\n            label=\"Add Override\",\n            default=False,\n            tooltip=\"Add a library override for the loaded asset.\",\n        )\n    ]\n\n    def process_asset(\n        self,\n        context: dict,\n        name: str,\n        namespace: Optional[str] = None,\n        options: Optional[Dict] = None,\n    ) -&gt; Optional[List]:\n        filepath = self.filepath_from_context(context)\n\n        # Load a single Collection from the .blend file\n        # TODO: Disallow loading same collection?\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n        container_name = get_container_name(\n            name, namespace, context, suffix=\"CON\"\n        )\n        loaded_collection = bpy.data.collections.get(container_name)\n        scene_collection = bpy.context.scene.collection\n\n        if loaded_collection and group_name in scene_collection.children:\n\n            message = (\n                f\"Collection {group_name} already loaded, \"\n                f\"instance to {group_name} is created instead of \"\n                \"linking new collection\"\n            )\n            show_message(f\"Collection {group_name} already loaded\", message)\n            instance = bpy.data.objects.new(name=group_name, object_data=None)\n            instance.instance_type = 'COLLECTION'\n            instance.instance_collection = loaded_collection\n            # Link the instance to the active scene\n            bpy.context.scene.collection.objects.link(instance)\n            return\n\n        loaded_collection = load_collection(\n            filepath,\n            link=True,\n            group_name=group_name\n        )\n\n        options = options or dict()\n        if options.get(\"addOverride\", False):\n            local_copy = add_override(loaded_collection)\n            if local_copy:\n                loaded_collection = local_copy\n\n        container_collection = containerise(\n            name=name,\n            namespace=namespace,\n            nodes=[loaded_collection],\n            context=context,\n            loader=self.__class__.__name__,\n        )\n\n        return container_collection\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset. \"\"\"\n        repre = context[\"representation\"]\n        collection = container[\"node\"]\n        if collection.children:\n            library = self._get_library_from_collection(collection.children[0])\n            filepath = self.filepath_from_context(context)\n            filename = os.path.basename(filepath)\n            if library:\n                library.name = filename\n                library.filepath = filepath\n                library.reload()\n        # refresh UI\n        bpy.context.view_layer.update()\n\n        # Update container metadata\n        metadata_update(\n            collection, {\"representation\": str(repre[\"id\"])}\n        )\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove existing container from the Blender scene.\"\"\"\n\n        collection = container[\"node\"]\n        if collection.children:\n            library = self._get_library_from_collection(collection.children[0])\n            if library:\n                bpy.data.libraries.remove(library)\n            else:\n                # Ensure the collection is linked to the scene's master collection\n                scene_collection = bpy.context.scene.collection\n                for col in collection.children:\n                    scene_collection.children.unlink(col)\n        # remove the container collection\n        bpy.data.collections.remove(collection)\n\n        return True\n\n    def _get_library_from_collection(\n            self, collection: bpy.types.Collection) -&gt; Union[bpy.types.Library, None]:\n        \"\"\"Get the library from the collection.\"\"\"\n\n        for child in collection.children:\n            if child.library:\n                return child.library\n            # With override library\n            elif child.override_library and child.override_library.reference:\n                return child.override_library.reference.library\n\n        for child in collection.objects:\n            if child.library:\n                return child.library\n            # With override library\n            elif child.override_library and child.override_library.reference:\n                return child.override_library.reference.library\n\n        return None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend_link.html#client.ayon_blender.plugins.load.load_blend_link.BlendLinkLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove existing container from the Blender scene.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend_link.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove existing container from the Blender scene.\"\"\"\n\n    collection = container[\"node\"]\n    if collection.children:\n        library = self._get_library_from_collection(collection.children[0])\n        if library:\n            bpy.data.libraries.remove(library)\n        else:\n            # Ensure the collection is linked to the scene's master collection\n            scene_collection = bpy.context.scene.collection\n            for col in collection.children:\n                scene_collection.children.unlink(col)\n    # remove the container collection\n    bpy.data.collections.remove(collection)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blend_link.html#client.ayon_blender.plugins.load.load_blend_link.BlendLinkLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_blend_link.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset. \"\"\"\n    repre = context[\"representation\"]\n    collection = container[\"node\"]\n    if collection.children:\n        library = self._get_library_from_collection(collection.children[0])\n        filepath = self.filepath_from_context(context)\n        filename = os.path.basename(filepath)\n        if library:\n            library.name = filename\n            library.filepath = filepath\n            library.reload()\n    # refresh UI\n    bpy.context.view_layer.update()\n\n    # Update container metadata\n    metadata_update(\n        collection, {\"representation\": str(repre[\"id\"])}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html","title":"load_blendscene","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader","title":"<code>BlendSceneLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load assets from a .blend file.</p> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>class BlendSceneLoader(plugin.BlenderLoader):\n    \"\"\"Load assets from a .blend file.\"\"\"\n\n    product_types = {\"blendScene\"}\n    representations = {\"blend\"}\n\n    label = \"Append Blend\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    @staticmethod\n    def _get_asset_container(collections):\n        for coll in collections:\n            parents = [c for c in collections if c.user_of_id(coll)]\n            coll_ayon_prop = get_ayon_property(coll)\n            if coll_ayon_prop and not parents:\n                return coll\n\n        return None\n\n    def _process_data(self, libpath, group_name, product_type):\n        # Append all the data from the .blend file\n        names_by_attr: dict[str, list[str]] = {}\n        with bpy.data.libraries.load(\n            libpath, link=False, relative=False\n        ) as (data_from, data_to):\n            for attr in dir(data_to):\n                values = getattr(data_from, attr)\n                # store copy of list of names because the main list will\n                # be replaced with the data from the library after the context\n                names_by_attr[attr] = list(values)\n                setattr(data_to, attr, values)\n\n        # Rename the object to add the asset name\n        members = []\n        for attr in dir(data_to):\n            from_names: list[str] = names_by_attr[attr]\n            values = getattr(data_to, attr)\n\n            # Blender 5.0 also has `version` (tuple) and `Done` (bool)\n            # attributes on the data that we do not want to touch\n            # TODO: Find a more reliable way to find the right attributes\n            if not isinstance(values, list):\n                continue\n\n            for from_name, data in zip(from_names, values):\n                data.name = f\"{group_name}:{from_name}\"\n                members.append(data)\n\n        container = self._get_asset_container(\n            data_to.collections)\n        assert container, \"No asset group found\"\n\n        container.name = group_name\n\n        # Link the group to the scene\n        bpy.context.scene.collection.children.link(container)\n\n        # Remove the library from the blend file\n        filepath = bpy.path.basename(libpath)\n        # Blender has a limit of 63 characters for any data name.\n        # If the filepath is longer, it will be truncated for blender\n        # version elder than 5.0\n        if get_blender_version() &lt; (5, 0, 0) and len(filepath) &gt; 63:\n            filepath = filepath[:63]\n        library = bpy.data.libraries.get(filepath)\n        bpy.data.libraries.remove(library)\n\n        return container, members\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[dict] = None\n    ) -&gt; Optional[list]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        try:\n            product_type = context[\"product\"][\"productType\"]\n        except ValueError:\n            product_type = \"model\"\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        container, members = self._process_data(\n            libpath, group_name, product_type\n        )\n\n        add_to_ayon_container(container)\n\n        data = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        container[AYON_PROPERTY] = data\n\n        objects = [\n            obj for obj in bpy.data.objects\n            if obj.name.startswith(f\"{group_name}:\")\n        ]\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: dict, context: dict):\n        \"\"\"\n        Update the loaded asset.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.collections.get(group_name)\n        libpath = Path(self.filepath_from_context(context)).as_posix()\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n\n        # Get the parents of the members of the asset group, so we can\n        # re-link them after the update.\n        # Also gets the transform for each object to reapply after the update.\n        collection_parents = {}\n        member_transforms = {}\n        members = asset_group.get(AYON_PROPERTY).get(\"members\", [])\n        loaded_collections = {c for c in bpy.data.collections if c in members}\n        loaded_collections.add(bpy.data.collections.get(AYON_CONTAINERS))\n        for member in members:\n            if isinstance(member, bpy.types.Object):\n                member_parents = set(member.users_collection)\n                member_transforms[member.name] = member.matrix_basis.copy()\n            elif isinstance(member, bpy.types.Collection):\n                member_parents = {\n                    c for c in bpy.data.collections if c.user_of_id(member)}\n            else:\n                continue\n\n            member_parents = member_parents.difference(loaded_collections)\n            if member_parents:\n                collection_parents[member.name] = list(member_parents)\n\n        old_data = dict(asset_group.get(AYON_PROPERTY))\n\n        self.exec_remove(container)\n\n        product_type = container.get(\"productType\")\n        if product_type is None:\n            product_type = container[\"family\"]\n        asset_group, members = self._process_data(\n            libpath, group_name, product_type\n        )\n\n        for member in members:\n            if member.name in collection_parents:\n                for parent in collection_parents[member.name]:\n                    if isinstance(member, bpy.types.Object):\n                        parent.objects.link(member)\n                    elif isinstance(member, bpy.types.Collection):\n                        parent.children.link(member)\n            if member.name in member_transforms and isinstance(\n                member, bpy.types.Object\n            ):\n                member.matrix_basis = member_transforms[member.name]\n\n        add_to_ayon_container(asset_group)\n        # Restore the old data, but reset members, as they don't exist anymore\n        # This avoids a crash, because the memory addresses of those members\n        # are not valid anymore\n        old_data[\"members\"] = []\n        asset_group[AYON_PROPERTY] = old_data\n\n        new_data = {\n            \"libpath\": libpath,\n            \"representation\": repre_entity[\"id\"],\n            \"parent\": repre_entity[\"versionId\"],\n            \"members\": members,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        imprint(asset_group, new_data)\n        if bpy.context.scene.collection not in loaded_collections:\n            bpy.context.scene.collection.children.unlink(asset_group)\n\n    def exec_remove(self, container: dict) -&gt; bool:\n        \"\"\"\n        Remove an existing container from a Blender scene.\n        \"\"\"\n        group_name = container[\"objectName\"]\n        asset_group = bpy.data.collections.get(group_name)\n\n        members = set(asset_group.get(AYON_PROPERTY).get(\"members\", []))\n\n        if members:\n            for attr_name in dir(bpy.data):\n                attr = getattr(bpy.data, attr_name)\n                if not isinstance(attr, bpy.types.bpy_prop_collection):\n                    continue\n\n                # ensure to make a list copy because we\n                # we remove members as we iterate\n                for data in list(attr):\n                    if data not in members or data == asset_group:\n                        continue\n\n                    attr.remove(data)\n\n        bpy.data.collections.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>def exec_remove(self, container: dict) -&gt; bool:\n    \"\"\"\n    Remove an existing container from a Blender scene.\n    \"\"\"\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.collections.get(group_name)\n\n    members = set(asset_group.get(AYON_PROPERTY).get(\"members\", []))\n\n    if members:\n        for attr_name in dir(bpy.data):\n            attr = getattr(bpy.data, attr_name)\n            if not isinstance(attr, bpy.types.bpy_prop_collection):\n                continue\n\n            # ensure to make a list copy because we\n            # we remove members as we iterate\n            for data in list(attr):\n                if data not in members or data == asset_group:\n                    continue\n\n                attr.remove(data)\n\n    bpy.data.collections.remove(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>def exec_update(self, container: dict, context: dict):\n    \"\"\"\n    Update the loaded asset.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    group_name = container[\"objectName\"]\n    asset_group = bpy.data.collections.get(group_name)\n    libpath = Path(self.filepath_from_context(context)).as_posix()\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n\n    # Get the parents of the members of the asset group, so we can\n    # re-link them after the update.\n    # Also gets the transform for each object to reapply after the update.\n    collection_parents = {}\n    member_transforms = {}\n    members = asset_group.get(AYON_PROPERTY).get(\"members\", [])\n    loaded_collections = {c for c in bpy.data.collections if c in members}\n    loaded_collections.add(bpy.data.collections.get(AYON_CONTAINERS))\n    for member in members:\n        if isinstance(member, bpy.types.Object):\n            member_parents = set(member.users_collection)\n            member_transforms[member.name] = member.matrix_basis.copy()\n        elif isinstance(member, bpy.types.Collection):\n            member_parents = {\n                c for c in bpy.data.collections if c.user_of_id(member)}\n        else:\n            continue\n\n        member_parents = member_parents.difference(loaded_collections)\n        if member_parents:\n            collection_parents[member.name] = list(member_parents)\n\n    old_data = dict(asset_group.get(AYON_PROPERTY))\n\n    self.exec_remove(container)\n\n    product_type = container.get(\"productType\")\n    if product_type is None:\n        product_type = container[\"family\"]\n    asset_group, members = self._process_data(\n        libpath, group_name, product_type\n    )\n\n    for member in members:\n        if member.name in collection_parents:\n            for parent in collection_parents[member.name]:\n                if isinstance(member, bpy.types.Object):\n                    parent.objects.link(member)\n                elif isinstance(member, bpy.types.Collection):\n                    parent.children.link(member)\n        if member.name in member_transforms and isinstance(\n            member, bpy.types.Object\n        ):\n            member.matrix_basis = member_transforms[member.name]\n\n    add_to_ayon_container(asset_group)\n    # Restore the old data, but reset members, as they don't exist anymore\n    # This avoids a crash, because the memory addresses of those members\n    # are not valid anymore\n    old_data[\"members\"] = []\n    asset_group[AYON_PROPERTY] = old_data\n\n    new_data = {\n        \"libpath\": libpath,\n        \"representation\": repre_entity[\"id\"],\n        \"parent\": repre_entity[\"versionId\"],\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    imprint(asset_group, new_data)\n    if bpy.context.scene.collection not in loaded_collections:\n        bpy.context.scene.collection.children.unlink(asset_group)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_blendscene.html#client.ayon_blender.plugins.load.load_blendscene.BlendSceneLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_blendscene.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[dict] = None\n) -&gt; Optional[list]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    try:\n        product_type = context[\"product\"][\"productType\"]\n    except ValueError:\n        product_type = \"model\"\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    container, members = self._process_data(\n        libpath, group_name, product_type\n    )\n\n    add_to_ayon_container(container)\n\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"members\": members,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    container[AYON_PROPERTY] = data\n\n    objects = [\n        obj for obj in bpy.data.objects\n        if obj.name.startswith(f\"{group_name}:\")\n    ]\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html","title":"load_cache","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader","title":"<code>CacheModelLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load cache models.</p> <p>Stores the imported asset in a collection named after the asset.</p> Note <p>At least for now it only supports Alembic files.</p> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>class CacheModelLoader(plugin.BlenderLoader):\n    \"\"\"Load cache models.\n\n    Stores the imported asset in a collection named after the asset.\n\n    Note:\n        At least for now it only supports Alembic files.\n    \"\"\"\n    product_types = {\"model\", \"pointcache\", \"animation\", \"usd\"}\n    representations = {\"abc\", \"usd\", \"obj\"}\n\n    label = \"Load Cache\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _update_transform_cache_path(self, asset_group, libpath, prev_filename):\n        \"\"\"search and update path in the transform cache modifier\n        If there is no transform cache modifier, it will create one\n        to update the filepath of the alembic.\n        \"\"\"\n        bpy.ops.cachefile.open(filepath=libpath.as_posix())\n        for obj in asset_group.children:\n            asset_name = obj.name.rsplit(\":\", 1)[-1]\n            names = [modifier.name for modifier in obj.modifiers\n                     if modifier.type == \"MESH_SEQUENCE_CACHE\"]\n            file_list = [file for file in bpy.data.cache_files\n                         if file.name.startswith(prev_filename)]\n            if names:\n                for name in names:\n                    obj.modifiers.remove(obj.modifiers.get(name))\n            if file_list:\n                bpy.data.batch_remove(file_list)\n\n            obj.modifiers.new(name='MeshSequenceCache', type='MESH_SEQUENCE_CACHE')\n\n            modifiers = lib.get_cache_modifiers(obj)\n            for asset_name, modifier_list in modifiers.items():\n                for modifier in modifier_list:\n                    if modifier.type == \"MESH_SEQUENCE_CACHE\":\n                        modifier.cache_file = bpy.data.cache_files[-1]\n                        cache_file_name = os.path.basename(libpath.as_posix())\n                        modifier.cache_file.name = cache_file_name\n                        modifier.cache_file.filepath = libpath.as_posix()\n                        modifier.cache_file.scale = 1.0\n                        for object_path in modifier.cache_file.object_paths:\n                            base_object_name = os.path.basename(object_path.path)\n                            asset_name = asset_name.rsplit(\":\", 1)[-1]\n                            if base_object_name.endswith(asset_name):\n                                modifier.object_path = object_path.path\n                        bpy.context.evaluated_depsgraph_get()\n\n        return libpath\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n        empties = []\n\n        for obj in objects:\n            if obj.type == 'MESH':\n                for material_slot in list(obj.material_slots):\n                    bpy.data.materials.remove(material_slot.material)\n                bpy.data.meshes.remove(obj.data)\n            elif obj.type == 'EMPTY':\n                objects.extend(obj.children)\n                empties.append(obj)\n\n        for empty in empties:\n            bpy.data.objects.remove(empty)\n\n    def _process(self, libpath, asset_group, group_name):\n        plugin.deselect_all()\n\n        relative = bpy.context.preferences.filepaths.use_relative_paths\n\n        if any(libpath.lower().endswith(ext)\n               for ext in [\".usd\", \".usda\", \".usdc\"]):\n            # USD\n            bpy.ops.wm.usd_import(\n                filepath=libpath,\n                relative_path=relative\n            )\n        elif libpath.lower().endswith(\".obj\"):\n            # OBJ\n            bpy.ops.wm.obj_import(filepath=libpath)\n        else:\n            # Alembic\n            bpy.ops.wm.alembic_import(\n                filepath=libpath,\n                relative_path=relative\n            )\n\n        objects = lib.get_selection()\n\n        for obj in objects:\n            # reparent top object to asset_group\n            if not obj.parent:\n                obj.parent = asset_group\n\n            # Unlink the object from all collections\n            collections = obj.users_collection\n            for collection in collections:\n                collection.objects.unlink(obj)\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != 'EMPTY':\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n                for material_slot in obj.material_slots:\n                    name_mat = material_slot.material.name\n                    material_slot.material.name = f\"{group_name}:{name_mat}\"\n\n            if not obj.get(AYON_PROPERTY):\n                obj[AYON_PROPERTY] = {}\n\n            ayon_info = obj[AYON_PROPERTY]\n            ayon_info.update({\"container_name\": group_name})\n\n        plugin.deselect_all()\n\n        return objects\n\n    def _link_objects(self, objects, collection, container):\n        # Link the imported objects to any collection where the asset group is\n        # linked to, except the AYON_CONTAINERS collection\n        group_collections = [\n            collection\n            for collection in collection.users_collection\n            if collection != container]\n\n        for obj in objects:\n            for collection in group_collections:\n                collection.objects.link(obj)\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        asset_group.empty_display_type = 'SINGLE_ARROW'\n        add_to_ayon_container(asset_group)\n        objects = self._process(libpath, asset_group, group_name)\n\n        # Link the asset group to the active collection\n        collection = bpy.context.view_layer.active_layer_collection.collection\n        collection.objects.link(asset_group)\n        container = get_ayon_container()\n        self._link_objects(objects, asset_group, container)\n\n        product_type = context[\"product\"][\"productType\"]\n        asset_group[AYON_PROPERTY] = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": product_type,\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(self.filepath_from_context(context))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AYON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        if any(str(libpath).lower().endswith(ext)\n               for ext in [\".usd\", \".usda\", \".usdc\"]):\n            mat = asset_group.matrix_basis.copy()\n            self._remove(asset_group)\n\n            objects = self._process(str(libpath), asset_group, object_name)\n\n            container = get_ayon_container()\n            self._link_objects(objects, asset_group, container)\n\n            asset_group.matrix_basis = mat\n        else:\n            prev_filename = os.path.basename(container[\"libpath\"])\n            libpath = self._update_transform_cache_path(asset_group, libpath, prev_filename)\n\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (ayon:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (ayon:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(self.filepath_from_context(context))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AYON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    if any(str(libpath).lower().endswith(ext)\n           for ext in [\".usd\", \".usda\", \".usdc\"]):\n        mat = asset_group.matrix_basis.copy()\n        self._remove(asset_group)\n\n        objects = self._process(str(libpath), asset_group, object_name)\n\n        container = get_ayon_container()\n        self._link_objects(objects, asset_group, container)\n\n        asset_group.matrix_basis = mat\n    else:\n        prev_filename = os.path.basename(container[\"libpath\"])\n        libpath = self._update_transform_cache_path(asset_group, libpath, prev_filename)\n\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_cache.html#client.ayon_blender.plugins.load.load_cache.CacheModelLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_cache.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    asset_group.empty_display_type = 'SINGLE_ARROW'\n    add_to_ayon_container(asset_group)\n    objects = self._process(libpath, asset_group, group_name)\n\n    # Link the asset group to the active collection\n    collection = bpy.context.view_layer.active_layer_collection.collection\n    collection.objects.link(asset_group)\n    container = get_ayon_container()\n    self._link_objects(objects, asset_group, container)\n\n    product_type = context[\"product\"][\"productType\"]\n    asset_group[AYON_PROPERTY] = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": product_type,\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html","title":"load_camera_abc","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader","title":"<code>AbcCameraLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load a camera from Alembic file.</p> <p>Stores the imported asset in an empty named after the asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>class AbcCameraLoader(plugin.BlenderLoader):\n    \"\"\"Load a camera from Alembic file.\n\n    Stores the imported asset in an empty named after the asset.\n    \"\"\"\n\n    product_types = {\"camera\"}\n    representations = {\"abc\"}\n\n    label = \"Load Camera (ABC)\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            if obj.type == \"CAMERA\":\n                bpy.data.cameras.remove(obj.data)\n            elif obj.type == \"EMPTY\":\n                objects.extend(obj.children)\n                bpy.data.objects.remove(obj)\n\n    def _process(self, libpath, asset_group, group_name):\n        plugin.deselect_all()\n\n        # Force the creation of the transform cache even if the camera\n        # doesn't have an animation. We use the cache to update the camera.\n        bpy.ops.wm.alembic_import(\n            filepath=libpath, always_add_cache_reader=True)\n\n        objects = lib.get_selection()\n\n        for obj in objects:\n            obj.parent = asset_group\n\n        for obj in objects:\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != \"EMPTY\":\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n            if not obj.get(AYON_PROPERTY):\n                obj[AYON_PROPERTY] = dict()\n\n            ayon_info = obj[AYON_PROPERTY]\n            ayon_info.update({\"container_name\": group_name})\n\n        plugin.deselect_all()\n\n        return objects\n\n    def process_asset(\n        self,\n        context: dict,\n        name: str,\n        namespace: Optional[str] = None,\n        options: Optional[Dict] = None,\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        add_to_ayon_container(asset_group)\n        self._process(libpath, asset_group, group_name)\n\n        objects = []\n        nodes = list(asset_group.children)\n\n        for obj in nodes:\n            objects.append(obj)\n            nodes.extend(list(obj.children))\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AYON_PROPERTY] = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or \"\",\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(self.filepath_from_context(context))\n        prev_filename = os.path.basename(container[\"libpath\"])\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\")\n        assert libpath, (\n            f\"No existing library file found for {container['objectName']}\")\n        assert libpath.is_file(), f\"The file doesn't exist: {libpath}\"\n        assert extension in VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\")\n\n        metadata = asset_group.get(AYON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = str(\n            Path(bpy.path.abspath(group_libpath)).resolve())\n        normalized_libpath = str(\n            Path(bpy.path.abspath(str(libpath))).resolve())\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        bpy.ops.cachefile.open(filepath=libpath.as_posix())\n        for obj in asset_group.children:\n            names = [constraint.name for constraint in obj.constraints\n                     if constraint.type == \"TRANSFORM_CACHE\"]\n            file_list = [file for file in bpy.data.cache_files\n                        if file.name.startswith(prev_filename)]\n            if names:\n                for name in names:\n                    obj.constraints.remove(obj.constraints.get(name))\n            if file_list:\n                bpy.data.batch_remove(file_list)\n\n            constraint = obj.constraints.new(\"TRANSFORM_CACHE\")\n            constraint.cache_file = bpy.data.cache_files[-1]\n            constraint.cache_file.name = os.path.basename(libpath)\n            constraint.cache_file.filepath = libpath.as_posix()\n            constraint.cache_file.scale = 1.0\n            bpy.context.evaluated_depsgraph_get()\n\n            # Find the deepest hierarchy level in object paths\n            if constraint.cache_file.object_paths:\n                # Count slashes to determine hierarchy depth\n                object_paths_list = constraint.cache_file.object_paths\n                max_depth = max(\n                    path.path.count('/') for path in object_paths_list\n                )\n                # Assign only the deepest hierarchies\n                for object_path in object_paths_list:\n                    if object_path.path.count('/') == max_depth:\n                        constraint.object_path = object_path.path\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (ayon:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (ayon:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(self.filepath_from_context(context))\n    prev_filename = os.path.basename(container[\"libpath\"])\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\")\n    assert libpath, (\n        f\"No existing library file found for {container['objectName']}\")\n    assert libpath.is_file(), f\"The file doesn't exist: {libpath}\"\n    assert extension in VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\")\n\n    metadata = asset_group.get(AYON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = str(\n        Path(bpy.path.abspath(group_libpath)).resolve())\n    normalized_libpath = str(\n        Path(bpy.path.abspath(str(libpath))).resolve())\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    bpy.ops.cachefile.open(filepath=libpath.as_posix())\n    for obj in asset_group.children:\n        names = [constraint.name for constraint in obj.constraints\n                 if constraint.type == \"TRANSFORM_CACHE\"]\n        file_list = [file for file in bpy.data.cache_files\n                    if file.name.startswith(prev_filename)]\n        if names:\n            for name in names:\n                obj.constraints.remove(obj.constraints.get(name))\n        if file_list:\n            bpy.data.batch_remove(file_list)\n\n        constraint = obj.constraints.new(\"TRANSFORM_CACHE\")\n        constraint.cache_file = bpy.data.cache_files[-1]\n        constraint.cache_file.name = os.path.basename(libpath)\n        constraint.cache_file.filepath = libpath.as_posix()\n        constraint.cache_file.scale = 1.0\n        bpy.context.evaluated_depsgraph_get()\n\n        # Find the deepest hierarchy level in object paths\n        if constraint.cache_file.object_paths:\n            # Count slashes to determine hierarchy depth\n            object_paths_list = constraint.cache_file.object_paths\n            max_depth = max(\n                path.path.count('/') for path in object_paths_list\n            )\n            # Assign only the deepest hierarchies\n            for object_path in object_paths_list:\n                if object_path.path.count('/') == max_depth:\n                    constraint.object_path = object_path.path\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_abc.html#client.ayon_blender.plugins.load.load_camera_abc.AbcCameraLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_camera_abc.py</code> <pre><code>def process_asset(\n    self,\n    context: dict,\n    name: str,\n    namespace: Optional[str] = None,\n    options: Optional[Dict] = None,\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    add_to_ayon_container(asset_group)\n    self._process(libpath, asset_group, group_name)\n\n    objects = []\n    nodes = list(asset_group.children)\n\n    for obj in nodes:\n        objects.append(obj)\n        nodes.extend(list(obj.children))\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AYON_PROPERTY] = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or \"\",\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html","title":"load_camera_fbx","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader","title":"<code>FbxCameraLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load a camera from FBX.</p> <p>Stores the imported asset in an empty named after the asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>class FbxCameraLoader(plugin.BlenderLoader):\n    \"\"\"Load a camera from FBX.\n\n    Stores the imported asset in an empty named after the asset.\n    \"\"\"\n\n    product_types = {\"camera\"}\n    representations = {\"fbx\"}\n\n    label = \"Load Camera (FBX)\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            if obj.type == 'CAMERA':\n                bpy.data.cameras.remove(obj.data)\n            elif obj.type == 'EMPTY':\n                objects.extend(obj.children)\n                bpy.data.objects.remove(obj)\n\n    def _process(self, libpath, asset_group, group_name):\n        plugin.deselect_all()\n\n        collection = bpy.context.view_layer.active_layer_collection.collection\n\n        bpy.ops.import_scene.fbx(filepath=libpath)\n\n        parent = bpy.context.scene.collection\n\n        objects = lib.get_selection()\n\n        for obj in objects:\n            # Parent root to asset group\n            if not obj.parent:\n                obj.parent = asset_group\n\n            # Prefix loaded objects with a namespace\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != 'EMPTY':\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n            # Store `container_name` on the object in the AYON property\n            if not obj.get(AYON_PROPERTY):\n                obj[AYON_PROPERTY] = dict()\n\n            ayon_info = obj[AYON_PROPERTY]\n            ayon_info.update({\"container_name\": group_name})\n\n            # Unlink from the active collection, instead link to the scene\n            # collection. (Note: scene collection may be the active collection)\n            collection.objects.unlink(obj)\n            parent.objects.link(obj)\n\n        plugin.deselect_all()\n\n        return objects\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        add_to_ayon_container(asset_group)\n\n        self._process(libpath, asset_group, group_name)\n\n        objects = [asset_group]\n        objects.extend(asset_group.children_recursive)\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AYON_PROPERTY] = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(self.filepath_from_context(context))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AYON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        mat = asset_group.matrix_basis.copy()\n\n        self._remove(asset_group)\n        self._process(str(libpath), asset_group, object_name)\n\n        asset_group.matrix_basis = mat\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (ayon:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (ayon:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(self.filepath_from_context(context))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AYON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    mat = asset_group.matrix_basis.copy()\n\n    self._remove(asset_group)\n    self._process(str(libpath), asset_group, object_name)\n\n    asset_group.matrix_basis = mat\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_camera_fbx.html#client.ayon_blender.plugins.load.load_camera_fbx.FbxCameraLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_camera_fbx.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    add_to_ayon_container(asset_group)\n\n    self._process(libpath, asset_group, group_name)\n\n    objects = [asset_group]\n    objects.extend(asset_group.children_recursive)\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AYON_PROPERTY] = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html","title":"load_fbx","text":"<p>Load an asset in Blender from an Alembic file.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader","title":"<code>FbxModelLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load FBX models.</p> <p>Stores the imported asset in an empty named after the asset.</p> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>class FbxModelLoader(plugin.BlenderLoader):\n    \"\"\"Load FBX models.\n\n    Stores the imported asset in an empty named after the asset.\n    \"\"\"\n\n    product_types = {\"model\", \"rig\"}\n    representations = {\"fbx\"}\n\n    label = \"Load FBX\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            if obj.type == 'MESH':\n                for material_slot in list(obj.material_slots):\n                    if material_slot.material:\n                        bpy.data.materials.remove(material_slot.material)\n                bpy.data.meshes.remove(obj.data)\n            elif obj.type == 'ARMATURE':\n                objects.extend(obj.children)\n                bpy.data.armatures.remove(obj.data)\n            elif obj.type == 'CURVE':\n                bpy.data.curves.remove(obj.data)\n            elif obj.type == 'EMPTY':\n                objects.extend(obj.children)\n                bpy.data.objects.remove(obj)\n\n    def _process(self, libpath, asset_group, group_name, action):\n        plugin.deselect_all()\n\n        blender_version = lib.get_blender_version()\n        # bpy.ops.wm.fbx_import would be the new python command for\n        # fbx loader and it would fully replace its old version of\n        # bpy.ops.import_scene.fbx to be the default import command\n        # in 5.0\n        if blender_version &gt;= (4, 5, 0):\n            bpy.ops.wm.fbx_import(filepath=libpath)\n        else:\n            # TODO: make sure it works with the color management\n            # in 4.4 or elder version\n            bpy.ops.import_scene.fbx(filepath=libpath)\n\n        parent = bpy.context.scene.collection\n\n        imported_objects = lib.get_selection()\n        container = None\n\n        for imported_object in imported_objects:\n            if not imported_object.parent:\n                container = imported_object\n                break\n\n        assert container, \"No asset group found\"\n\n        # Children must be linked before parents,\n        # otherwise the hierarchy will break\n        objects = []\n        nodes = list(container.children)\n\n        for obj in nodes:\n            obj.parent = asset_group\n\n        bpy.data.objects.remove(container)\n\n        for obj in nodes:\n            objects.append(obj)\n            nodes.extend(list(obj.children))\n\n        objects.reverse()\n\n        for obj in objects:\n            if obj.name not in parent.objects:\n                parent.objects.link(obj)\n\n        for obj in objects:\n            name = obj.name\n            obj.name = f\"{group_name}:{name}\"\n            if obj.type != 'EMPTY':\n                name_data = obj.data.name\n                obj.data.name = f\"{group_name}:{name_data}\"\n\n            if obj.type == 'MESH':\n                for material_slot in obj.material_slots:\n                    name_mat = material_slot.material.name\n                    material_slot.material.name = f\"{group_name}:{name_mat}\"\n            elif obj.type == 'ARMATURE':\n                anim_data = obj.animation_data\n                if action is not None:\n                    anim_data.action = action\n                elif anim_data and anim_data.action:\n                    name_action = anim_data.action.name\n                    anim_data.action.name = f\"{group_name}:{name_action}\"\n\n            if not obj.get(AYON_PROPERTY):\n                obj[AYON_PROPERTY] = dict()\n\n            ayon_info = obj[AYON_PROPERTY]\n            ayon_info.update({\"container_name\": group_name})\n\n        plugin.deselect_all()\n\n        return objects\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        add_to_ayon_container(asset_group)\n\n        objects = self._process(libpath, asset_group, group_name, None)\n\n        objects = []\n        nodes = list(asset_group.children)\n\n        for obj in nodes:\n            objects.append(obj)\n            nodes.extend(list(obj.children))\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AYON_PROPERTY] = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"objectName\": group_name,\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n\n        self[:] = objects\n        return objects\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(self.filepath_from_context(context))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AYON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        # Get the armature of the rig\n        objects = asset_group.children\n        armatures = [obj for obj in objects if obj.type == 'ARMATURE']\n        action = None\n\n        if armatures:\n            armature = armatures[0]\n\n            if armature.animation_data and armature.animation_data.action:\n                action = armature.animation_data.action\n\n        mat = asset_group.matrix_basis.copy()\n        self._remove(asset_group)\n\n        self._process(str(libpath), asset_group, object_name, action)\n\n        asset_group.matrix_basis = mat\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (ayon:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n\n        Warning:\n            No nested collections are supported at the moment!\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (ayon:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Warning <p>No nested collections are supported at the moment!</p> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n\n    Warning:\n        No nested collections are supported at the moment!\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(self.filepath_from_context(context))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AYON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    # Get the armature of the rig\n    objects = asset_group.children\n    armatures = [obj for obj in objects if obj.type == 'ARMATURE']\n    action = None\n\n    if armatures:\n        armature = armatures[0]\n\n        if armature.animation_data and armature.animation_data.action:\n            action = armature.animation_data.action\n\n    mat = asset_group.matrix_basis.copy()\n    self._remove(asset_group)\n\n    self._process(str(libpath), asset_group, object_name, action)\n\n    asset_group.matrix_basis = mat\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_fbx.html#client.ayon_blender.plugins.load.load_fbx.FbxModelLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_fbx.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    add_to_ayon_container(asset_group)\n\n    objects = self._process(libpath, asset_group, group_name, None)\n\n    objects = []\n    nodes = list(asset_group.children)\n\n    for obj in nodes:\n        objects.append(obj)\n        nodes.extend(list(obj.children))\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AYON_PROPERTY] = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"objectName\": group_name,\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n\n    self[:] = objects\n    return objects\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html","title":"load_image_compositor","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor","title":"<code>LoadImageCompositor</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load media to the compositor.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>class LoadImageCompositor(plugin.BlenderLoader):\n    \"\"\"Load media to the compositor.\"\"\"\n\n    product_types = {\"render\", \"image\", \"plate\"}\n    representations = {\"*\"}\n\n    label = \"Load in Compositor\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        # Get the scene's compositor node tree\n        node_tree = lib.get_scene_node_tree(ensure_exists=True)\n\n        # Load the image in data\n        path = self.filepath_from_context(context)\n        image = bpy.data.images.load(path, check_existing=True)\n\n        # Create a new image node\n        img_comp_node = node_tree.nodes.new(type='CompositorNodeImage')\n        img_comp_node.image = image\n        self.set_source_and_colorspace(context, img_comp_node)\n\n        data = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"project_name\": context[\"project\"][\"name\"],\n        }\n        lib.imprint(img_comp_node, data)\n\n        return [img_comp_node]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove the image comp node\"\"\"\n        img_comp_node = container[\"node\"]\n        image: Optional[bpy.types.Image] = img_comp_node.image\n\n        # Delete the compositor node\n        node_tree = lib.get_scene_node_tree()\n        node_tree.nodes.remove(img_comp_node)\n\n        # Delete the image if it remains unused\n        self.remove_image_if_unused(image)\n\n        return True\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the image comp node to new context version.\"\"\"\n        path = self.filepath_from_context(context)\n        img_comp_node = container[\"node\"]\n\n        old_image: Optional[bpy.types.Image] = img_comp_node.image\n\n        new_image = bpy.data.images.load(path, check_existing=True)\n        img_comp_node.image = new_image\n\n        self.set_source_and_colorspace(context, img_comp_node)\n        self.remove_image_if_unused(old_image)\n\n        # Update representation id\n        lib.imprint(img_comp_node, {\n            \"representation\": context[\"representation\"][\"id\"],\n            \"project_name\": context[\"project\"][\"name\"],\n        })\n\n    def set_source_and_colorspace(\n        self,\n        context: dict,\n        image_comp_node: bpy.types.CompositorNodeImage\n    ):\n        \"\"\"\n        Set the image source (e.g. SEQUENCE or FILE), set the duration for\n        a sequence and set colorspace if representation has colorspace data.\n        \"\"\"\n\n        image = image_comp_node.image\n        representation: dict = context[\"representation\"]\n\n        # Set image source\n        source = \"FILE\"  # Single image file\n        if representation[\"context\"].get(\"udim\"):\n            source = \"UDIM\"\n        elif representation[\"context\"].get(\"frame\"):\n            source = \"SEQUENCE\"\n        else:\n            ext = os.path.splitext(image.filepath)[-1]\n            if ext in VIDEO_EXTENSIONS:\n                source = \"MOVIE\"\n\n        image.source = source\n\n        # Set duration on the compositor node if sequence is used\n        if source in {\"SEQUENCE\", \"MOVIE\"}:\n            version_attrib: dict = context[\"version\"][\"attrib\"]\n            frame_start = version_attrib.get(\"frameStart\", 0)\n            frame_end = version_attrib.get(\"frameEnd\", 0)\n            handle_start = version_attrib.get(\"handleStart\", 0)\n            handle_end = version_attrib.get(\"handleEnd\", 0)\n            frame_start_handle = frame_start - handle_start\n            frame_end_handle = frame_end + handle_end\n            duration: int = frame_end_handle - frame_start_handle + 1\n            image_comp_node.frame_duration = duration\n            if source == \"SEQUENCE\":\n                image_comp_node.frame_start = frame_start_handle\n                image_comp_node.frame_offset = frame_start_handle - 1\n            else:\n                image_comp_node.frame_start = frame_start_handle\n                image_comp_node.frame_offset = 0\n\n        # Set colorspace if representation has colorspace data\n        colorspace_data = representation.get(\"data\", {}).get(\n            \"colorspaceData\", {})\n        if colorspace_data:\n            colorspace: str = colorspace_data[\"colorspace\"]\n            if colorspace:\n                try:\n                    image.colorspace_settings.name = colorspace\n                except TypeError as exc:\n                    self.log.warning(\n                        f\"Colorspace '{colorspace}' not found in \"\n                        f\"current color management. See:\\n{exc}\"\n                    )\n\n    def remove_image_if_unused(self, image: bpy.types.Image):\n        if image and not image.users:\n            self.log.debug(\"Removing unused image: %s\", image.name)\n            bpy.data.images.remove(image)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove the image comp node</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove the image comp node\"\"\"\n    img_comp_node = container[\"node\"]\n    image: Optional[bpy.types.Image] = img_comp_node.image\n\n    # Delete the compositor node\n    node_tree = lib.get_scene_node_tree()\n    node_tree.nodes.remove(img_comp_node)\n\n    # Delete the image if it remains unused\n    self.remove_image_if_unused(image)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the image comp node to new context version.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the image comp node to new context version.\"\"\"\n    path = self.filepath_from_context(context)\n    img_comp_node = container[\"node\"]\n\n    old_image: Optional[bpy.types.Image] = img_comp_node.image\n\n    new_image = bpy.data.images.load(path, check_existing=True)\n    img_comp_node.image = new_image\n\n    self.set_source_and_colorspace(context, img_comp_node)\n    self.remove_image_if_unused(old_image)\n\n    # Update representation id\n    lib.imprint(img_comp_node, {\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    # Get the scene's compositor node tree\n    node_tree = lib.get_scene_node_tree(ensure_exists=True)\n\n    # Load the image in data\n    path = self.filepath_from_context(context)\n    image = bpy.data.images.load(path, check_existing=True)\n\n    # Create a new image node\n    img_comp_node = node_tree.nodes.new(type='CompositorNodeImage')\n    img_comp_node.image = image\n    self.set_source_and_colorspace(context, img_comp_node)\n\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n    }\n    lib.imprint(img_comp_node, data)\n\n    return [img_comp_node]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_compositor.html#client.ayon_blender.plugins.load.load_image_compositor.LoadImageCompositor.set_source_and_colorspace","title":"<code>set_source_and_colorspace(context, image_comp_node)</code>","text":"<p>Set the image source (e.g. SEQUENCE or FILE), set the duration for a sequence and set colorspace if representation has colorspace data.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_compositor.py</code> <pre><code>def set_source_and_colorspace(\n    self,\n    context: dict,\n    image_comp_node: bpy.types.CompositorNodeImage\n):\n    \"\"\"\n    Set the image source (e.g. SEQUENCE or FILE), set the duration for\n    a sequence and set colorspace if representation has colorspace data.\n    \"\"\"\n\n    image = image_comp_node.image\n    representation: dict = context[\"representation\"]\n\n    # Set image source\n    source = \"FILE\"  # Single image file\n    if representation[\"context\"].get(\"udim\"):\n        source = \"UDIM\"\n    elif representation[\"context\"].get(\"frame\"):\n        source = \"SEQUENCE\"\n    else:\n        ext = os.path.splitext(image.filepath)[-1]\n        if ext in VIDEO_EXTENSIONS:\n            source = \"MOVIE\"\n\n    image.source = source\n\n    # Set duration on the compositor node if sequence is used\n    if source in {\"SEQUENCE\", \"MOVIE\"}:\n        version_attrib: dict = context[\"version\"][\"attrib\"]\n        frame_start = version_attrib.get(\"frameStart\", 0)\n        frame_end = version_attrib.get(\"frameEnd\", 0)\n        handle_start = version_attrib.get(\"handleStart\", 0)\n        handle_end = version_attrib.get(\"handleEnd\", 0)\n        frame_start_handle = frame_start - handle_start\n        frame_end_handle = frame_end + handle_end\n        duration: int = frame_end_handle - frame_start_handle + 1\n        image_comp_node.frame_duration = duration\n        if source == \"SEQUENCE\":\n            image_comp_node.frame_start = frame_start_handle\n            image_comp_node.frame_offset = frame_start_handle - 1\n        else:\n            image_comp_node.frame_start = frame_start_handle\n            image_comp_node.frame_offset = 0\n\n    # Set colorspace if representation has colorspace data\n    colorspace_data = representation.get(\"data\", {}).get(\n        \"colorspaceData\", {})\n    if colorspace_data:\n        colorspace: str = colorspace_data[\"colorspace\"]\n        if colorspace:\n            try:\n                image.colorspace_settings.name = colorspace\n            except TypeError as exc:\n                self.log.warning(\n                    f\"Colorspace '{colorspace}' not found in \"\n                    f\"current color management. See:\\n{exc}\"\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html","title":"load_image_shader","text":""},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor","title":"<code>LoadImageShaderEditor</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load a product to the Shader Editor for selected mesh in Blender.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>class LoadImageShaderEditor(plugin.BlenderLoader):\n    \"\"\"Load a product to the Shader Editor for selected mesh in Blender.\"\"\"\n\n    product_types = {\"render\", \"image\", \"plate\", \"texture\"}\n    representations = {\"*\"}\n\n    label = \"Load to Shader Editor\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    CREATE_NEW = \"create_new\"\n\n    @classmethod\n    def get_options(cls, contexts):\n\n        selected_object = cls.get_selected_object()\n        if not selected_object:\n            return []\n\n        slot_materials = [\n            (i, material) for i, material\n            in enumerate(selected_object.data.materials)\n            # Ignore empty material slots\n            if material is not None\n        ]\n        items = [\n            {\"value\": i, \"label\": material.name}\n            for i, material in slot_materials\n        ]\n        items.append(\n            {\"value\": cls.CREATE_NEW, \"label\": \"New Material\"}\n        )\n        return [\n            EnumDef(\n                \"material_slot\",\n                label=\"Material Slot\",\n                items=items,\n                default=items[0][\"value\"]\n            )\n        ]\n\n    @staticmethod\n    def get_selected_object():\n        selected_objects = lib.get_selection()\n        for obj in selected_objects:\n            if obj.type in {'MESH', 'SURFACE'}:\n                return obj\n\n    def process_asset(\n            self, context: dict, name: str, namespace: Optional[str] = None,\n            options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        # In the current objects selection, I get the first one that is a\n        # MESH or a SURFACE.\n        # TODO: We tend to avoid acting on 'user selection' so that the loaders\n        #  can run completely automatically, without user interaction or popups\n        #  So we may want to investigate different approaches to this.\n        cur_obj = self.get_selected_object()\n        if cur_obj is None:\n            self.log.info(\n                \"Load in Shader Editor: The process (image load) was \"\n                \"cancelled, because no object (mesh or surface) was selected \"\n                \"in Blender.\")\n            self.display_warning(\n                \"You did not select any object in Blender.\\n\"\n                \"So this process is cancelled.\")\n            return []\n\n        # If the currently selected object has one or more materials, let's use\n        # the first one. If it has no material, let's create a new one.\n        material_slot = options.get(\"material_slot\")\n        if material_slot is None:\n            # Get first slot with a material\n            material_slot = next(\n                (\n                    i for i, material in enumerate(cur_obj.data.materials)\n                    # Ignore empty material slots\n                    if material is not None\n                ), None\n            )\n        if material_slot is None or material_slot == self.CREATE_NEW:\n            # Create a new material\n            current_material = bpy.data.materials.new(name=\"material\")\n            cur_obj.data.materials.append(current_material)\n        else:\n            current_material = cur_obj.data.materials[material_slot]\n\n        if not hasattr(current_material, \"node_tree\"):\n            # Enable nodes in a deferred way to avoid ID class write restrictions\n            self._enable_material_nodes(current_material)\n\n        nodes = current_material.node_tree.nodes\n\n        # Create an \"Image Texture\" node. It will appear in the Shader Editor\n        # (which appears when you are in the \"Shading\" workspace tab), when you\n        # select the \"Object\" filter (among this choice: Object, World,\n        # Line Style).\n        image_texture_node = nodes.new(type='ShaderNodeTexImage')\n\n        # Load the image in data and assign it safely\n        path = self.filepath_from_context(context)\n        image = bpy.data.images.load(path, check_existing=True)\n        # Use safe context for shader operations\n        with self._safe_shader_operations():\n            # Assign image to node using deferred execution to avoid ID class write restrictions\n            self._assign_image_to_node(image_texture_node, image)\n            self.set_colorspace(context, image_texture_node)\n\n        data = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n        }\n        lib.imprint(image_texture_node, data)\n\n        return [image_texture_node]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove the Image Texture node.\"\"\"\n\n        image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n        image: Optional[bpy.types.Image] = image_texture_node.image\n\n        # Delete the node\n        image_texture_node.id_data.nodes.remove(image_texture_node)\n\n        # Delete the image if it remains unused\n        self.remove_image_if_unused(image)\n\n        return True\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the Image Texture node to new context version.\"\"\"\n\n        path = self.filepath_from_context(context)\n        image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n\n        old_image: Optional[bpy.types.Image] = image_texture_node.image\n\n        new_image = bpy.data.images.load(path, check_existing=True)\n        # Use safe context for shader operations\n        with self._safe_shader_operations():\n            # Assign image to node using deferred execution to avoid ID class write restrictions\n            self._assign_image_to_node(image_texture_node, new_image)\n            self.set_colorspace(context, image_texture_node)\n        self.remove_image_if_unused(old_image)\n\n        # Update representation id\n        lib.imprint(image_texture_node, {\n            \"representation\": context[\"representation\"][\"id\"]\n        })\n\n    def set_colorspace(\n            self,\n            context: dict,\n            image_texture_node: bpy.types.ShaderNodeTexImage\n    ):\n        \"\"\"\n        Set colorspace if representation has colorspace data.\n        \"\"\"\n\n        image = image_texture_node.image\n        representation: dict = context[\"representation\"]\n\n        colorspace_data = representation.get(\"data\", {}).get(\n            \"colorspaceData\", {})\n        if colorspace_data:\n            colorspace: str = colorspace_data[\"colorspace\"]\n            if colorspace and hasattr(image, \"colorspace_settings\"):\n                image.colorspace_settings.name = colorspace\n\n    def _assign_image_to_node(self, node: bpy.types.ShaderNodeTexImage, image: bpy.types.Image):\n        \"\"\"\n        Safely assign an image to a shader node, handling ID class write restrictions.\n\n        Args:\n            node: The shader node texture node\n            image: The image to assign to the node\n        \"\"\"\n        self.log.debug(\"Using deferred assignment due to ID class write restriction\")\n        bpy.app.timers.register(\n            partial(self._deferred_image_assignment, node, image),\n            first_interval=0.001\n        )\n\n    def _enable_material_nodes(self, material: bpy.types.Material):\n        \"\"\"\n        Safely enable nodes on a material, handling ID class write restrictions.\n\n        Args:\n            material: The material to enable nodes for\n        \"\"\"\n        self.log.debug(\"Using deferred node enabling due to ID class write restriction\")\n        bpy.app.timers.register(\n            partial(self._deferred_enable_nodes, material),\n            first_interval=0.001\n        )\n\n    def _deferred_image_assignment(self, node: bpy.types.ShaderNodeTexImage, image: bpy.types.Image):\n        \"\"\"\n        Deferred image assignment callback for timer execution.\n        Args:\n            node: The shader node texture node\n            image: The image to assign to the node\n        Returns:\n            None to prevent timer repetition\n        \"\"\"\n        if node and image:\n            node.image = image\n            return None\n        # Return 0.001 to retry the timer\n        return 0.001\n\n    def _deferred_enable_nodes(self, material: bpy.types.Material):\n        \"\"\"\n        Deferred material nodes enabling callback for timer execution.\n        Args:\n            material: The material to enable nodes for\n        Returns:\n            None to prevent timer repetition\n        \"\"\"\n        if material:\n            material.use_nodes = True\n            return None\n        # Return 0.001 to retry the timer\n        return 0.001\n\n    def _is_safe_context_for_id_writes(self):\n        \"\"\"\n        Check if the current context allows writing to ID classes.\n\n        Returns:\n            bool: True if ID writes are allowed, False otherwise\n        \"\"\"\n        try:\n            # Try a harmless operation that would trigger the same error\n            # We'll create a temporary test to see if ID writes are allowed\n            test_material = bpy.data.materials.get(\"__temp_context_test__\")\n            if test_material is None:\n                test_material = bpy.data.materials.new(\"__temp_context_test__\")\n                # Clean up immediately\n                bpy.data.materials.remove(test_material)\n            else:\n                # Material already exists, remove it\n                bpy.data.materials.remove(test_material)\n            return True\n\n        except RuntimeError as e:\n            if \"Writing to ID classes in this context is not allowed\" in str(e):\n                self.log.debug(\"ID class writes are not allowed in the current context.\")\n\n            return False\n\n    @contextlib.contextmanager\n    def _safe_shader_operations(self):\n        \"\"\"\n        Context manager for safely performing shader node operations.\n\n        This ensures operations are performed in a context where ID classes\n        can be safely modified.\n        \"\"\"\n        # Check if we're already in a safe context\n        if self._is_safe_context_for_id_writes():\n            # Already safe, just yield\n            yield\n            return\n        # Store the current context mode to restore later if needed\n        original_mode = None\n        mode_changed = False\n        try:\n            # Get current area and space types\n            for area in bpy.context.screen.areas:\n                if area.type == 'NODE_EDITOR':\n                    for space in area.spaces:\n                        if space.type == 'NODE_EDITOR':\n                            original_mode = space.tree_type\n                            if original_mode != 'ShaderNodeTree':\n                                continue\n                            space.tree_type = 'ShaderNodeTree'\n                            mode_changed = True\n                            break\n            yield\n        finally:\n            # Restore original mode if it was changed\n            if mode_changed and original_mode is not None:\n                for area in bpy.context.screen.areas:\n                    if area.type == 'NODE_EDITOR':\n                        for space in area.spaces:\n                            if space.type == 'NODE_EDITOR':\n                                space.tree_type = original_mode\n                                break\n\n    def remove_image_if_unused(self, image: bpy.types.Image):\n        if image and not image.users:\n            self.log.debug(\"Removing unused image: %s\", image.name)\n            bpy.data.images.remove(image)\n\n    def display_warning(self, message):\n        loader_gui_window = host_tools.get_tool_by_name(\"loader\")\n\n        QtWidgets.QMessageBox.warning(\n            loader_gui_window,\n            \"Warning\",\n            message,\n            buttons=QtWidgets.QMessageBox.Ok,\n            defaultButton=QtWidgets.QMessageBox.Ok)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove the Image Texture node.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove the Image Texture node.\"\"\"\n\n    image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n    image: Optional[bpy.types.Image] = image_texture_node.image\n\n    # Delete the node\n    image_texture_node.id_data.nodes.remove(image_texture_node)\n\n    # Delete the image if it remains unused\n    self.remove_image_if_unused(image)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the Image Texture node to new context version.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the Image Texture node to new context version.\"\"\"\n\n    path = self.filepath_from_context(context)\n    image_texture_node: bpy.types.ShaderNodeTexImage = container[\"node\"]\n\n    old_image: Optional[bpy.types.Image] = image_texture_node.image\n\n    new_image = bpy.data.images.load(path, check_existing=True)\n    # Use safe context for shader operations\n    with self._safe_shader_operations():\n        # Assign image to node using deferred execution to avoid ID class write restrictions\n        self._assign_image_to_node(image_texture_node, new_image)\n        self.set_colorspace(context, image_texture_node)\n    self.remove_image_if_unused(old_image)\n\n    # Update representation id\n    lib.imprint(image_texture_node, {\n        \"representation\": context[\"representation\"][\"id\"]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    # In the current objects selection, I get the first one that is a\n    # MESH or a SURFACE.\n    # TODO: We tend to avoid acting on 'user selection' so that the loaders\n    #  can run completely automatically, without user interaction or popups\n    #  So we may want to investigate different approaches to this.\n    cur_obj = self.get_selected_object()\n    if cur_obj is None:\n        self.log.info(\n            \"Load in Shader Editor: The process (image load) was \"\n            \"cancelled, because no object (mesh or surface) was selected \"\n            \"in Blender.\")\n        self.display_warning(\n            \"You did not select any object in Blender.\\n\"\n            \"So this process is cancelled.\")\n        return []\n\n    # If the currently selected object has one or more materials, let's use\n    # the first one. If it has no material, let's create a new one.\n    material_slot = options.get(\"material_slot\")\n    if material_slot is None:\n        # Get first slot with a material\n        material_slot = next(\n            (\n                i for i, material in enumerate(cur_obj.data.materials)\n                # Ignore empty material slots\n                if material is not None\n            ), None\n        )\n    if material_slot is None or material_slot == self.CREATE_NEW:\n        # Create a new material\n        current_material = bpy.data.materials.new(name=\"material\")\n        cur_obj.data.materials.append(current_material)\n    else:\n        current_material = cur_obj.data.materials[material_slot]\n\n    if not hasattr(current_material, \"node_tree\"):\n        # Enable nodes in a deferred way to avoid ID class write restrictions\n        self._enable_material_nodes(current_material)\n\n    nodes = current_material.node_tree.nodes\n\n    # Create an \"Image Texture\" node. It will appear in the Shader Editor\n    # (which appears when you are in the \"Shading\" workspace tab), when you\n    # select the \"Object\" filter (among this choice: Object, World,\n    # Line Style).\n    image_texture_node = nodes.new(type='ShaderNodeTexImage')\n\n    # Load the image in data and assign it safely\n    path = self.filepath_from_context(context)\n    image = bpy.data.images.load(path, check_existing=True)\n    # Use safe context for shader operations\n    with self._safe_shader_operations():\n        # Assign image to node using deferred execution to avoid ID class write restrictions\n        self._assign_image_to_node(image_texture_node, image)\n        self.set_colorspace(context, image_texture_node)\n\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n    }\n    lib.imprint(image_texture_node, data)\n\n    return [image_texture_node]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_image_shader.html#client.ayon_blender.plugins.load.load_image_shader.LoadImageShaderEditor.set_colorspace","title":"<code>set_colorspace(context, image_texture_node)</code>","text":"<p>Set colorspace if representation has colorspace data.</p> Source code in <code>client/ayon_blender/plugins/load/load_image_shader.py</code> <pre><code>def set_colorspace(\n        self,\n        context: dict,\n        image_texture_node: bpy.types.ShaderNodeTexImage\n):\n    \"\"\"\n    Set colorspace if representation has colorspace data.\n    \"\"\"\n\n    image = image_texture_node.image\n    representation: dict = context[\"representation\"]\n\n    colorspace_data = representation.get(\"data\", {}).get(\n        \"colorspaceData\", {})\n    if colorspace_data:\n        colorspace: str = colorspace_data[\"colorspace\"]\n        if colorspace and hasattr(image, \"colorspace_settings\"):\n            image.colorspace_settings.name = colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html","title":"load_layout_json","text":"<p>Load a layout in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader","title":"<code>JsonLayoutLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load layout published from Unreal.</p> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>class JsonLayoutLoader(plugin.BlenderLoader):\n    \"\"\"Load layout published from Unreal.\"\"\"\n\n    product_types = {\"layout\"}\n    representations = {\"json\"}\n\n    label = \"Load Layout\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    animation_creator_name = \"CreateAnimation\"\n\n    def _remove(self, asset_group):\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            remove_container(obj.get(AYON_PROPERTY))\n\n    def _remove_animation_instances(self, asset_group):\n        instances = bpy.data.collections.get(AYON_INSTANCES)\n        if instances:\n            for obj in list(asset_group.children):\n                anim_collection = instances.children.get(\n                    obj.name + \"_animation\")\n                if anim_collection:\n                    bpy.data.collections.remove(anim_collection)\n\n    def _get_loader(self, loaders, product_type):\n        name = \"\"\n        if product_type == 'rig':\n            name = \"BlendRigLoader\"\n        elif product_type == 'model':\n            name = \"BlendModelLoader\"\n\n        if name == \"\":\n            return None\n\n        for loader in loaders:\n            if loader.__name__ == name:\n                return loader\n\n        return None\n\n    def _process(self, libpath, asset, asset_group, actions):\n        plugin.deselect_all()\n\n        with open(libpath, \"r\") as fp:\n            data = json.load(fp)\n\n        all_loaders = discover_loader_plugins()\n\n        for element in data:\n            reference = element.get('reference')\n            product_type = element.get(\"product_type\")\n            if product_type is None:\n                product_type = element.get(\"family\")\n\n            loaders = loaders_from_representation(all_loaders, reference)\n            loader = self._get_loader(loaders, product_type)\n\n            if not loader:\n                continue\n\n            instance_name = element.get('instance_name')\n\n            action = None\n\n            if actions:\n                action = actions.get(instance_name, None)\n\n            options = {\n                'parent': asset_group,\n                'transform': element.get('transform'),\n                'action': action,\n                'create_animation': True if product_type == 'rig' else False,\n                'animation_asset': asset\n            }\n\n            if element.get('animation'):\n                options['animation_file'] = str(Path(libpath).with_suffix(\n                    '')) + \".\" + element.get('animation')\n\n            # This should return the loaded asset, but the load call will be\n            # added to the queue to run in the Blender main thread, so\n            # at this time it will not return anything. The assets will be\n            # loaded in the next Blender cycle, so we use the options to\n            # set the transform, parent and assign the action, if there is one.\n            load_container(\n                loader,\n                reference,\n                namespace=instance_name,\n                options=options\n            )\n\n        # Camera creation when loading a layout is not necessary for now,\n        # but the code is worth keeping in case we need it in the future.\n        # # Create the camera asset and the camera instance\n        # creator_plugin = get_legacy_creator_by_name(\"CreateCamera\")\n        # if not creator_plugin:\n        #     raise ValueError(\"Creator plugin \\\"CreateCamera\\\" was \"\n        #                      \"not found.\")\n\n        # TODO: Refactor legacy create usage to new style creators\n        # legacy_create(\n        #     creator_plugin,\n        #     name=\"camera\",\n        #     # name=f\"{unique_number}_{product[name]}_animation\",\n        #     asset=asset,\n        #     options={\"useSelection\": False}\n        #     # data={\"dependencies\": context[\"representation\"][\"id\"]}\n        # )\n\n    def process_asset(self,\n                      context: dict,\n                      name: str,\n                      namespace: Optional[str] = None,\n                      options: Optional[Dict] = None):\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        asset_name = plugin.prepare_scene_name(folder_name, product_name)\n        unique_number = plugin.get_unique_number(folder_name, product_name)\n        group_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n        asset_group = bpy.data.objects.new(group_name, object_data=None)\n        asset_group.empty_display_type = 'SINGLE_ARROW'\n        add_to_ayon_container(asset_group)\n\n        self._process(libpath, asset_name, asset_group, None)\n\n        bpy.context.scene.collection.objects.link(asset_group)\n\n        asset_group[AYON_PROPERTY] = {\n            \"schema\": \"ayon:container-3.0\",\n            \"id\": AYON_CONTAINER_ID,\n            \"name\": name,\n            \"namespace\": namespace or '',\n            \"loader\": str(self.__class__.__name__),\n            \"representation\": context[\"representation\"][\"id\"],\n            \"libpath\": libpath,\n            \"asset_name\": asset_name,\n            \"parent\": context[\"representation\"][\"versionId\"],\n            \"productType\": context[\"product\"][\"productType\"],\n            \"project_name\": context[\"project\"][\"name\"],\n            \"objectName\": group_name,\n        }\n\n        self[:] = asset_group.children\n        return asset_group.children\n\n    def exec_update(self, container: Dict, context: Dict):\n        \"\"\"Update the loaded asset.\n\n        This will remove all objects of the current collection, load the new\n        ones and add them to the collection.\n        If the objects of the collection are used in another collection they\n        will not be removed, only unlinked. Normally this should not be the\n        case though.\n        \"\"\"\n        repre_entity = context[\"representation\"]\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n        libpath = Path(self.filepath_from_context(context))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert asset_group, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        metadata = asset_group.get(AYON_PROPERTY)\n        group_libpath = metadata[\"libpath\"]\n\n        normalized_group_libpath = (\n            str(Path(bpy.path.abspath(group_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_group_libpath,\n            normalized_libpath,\n        )\n        if normalized_group_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        actions = {}\n\n        for obj in asset_group.children:\n            obj_meta = obj.get(AYON_PROPERTY)\n            product_type = obj_meta.get(\"productType\")\n            if product_type is None:\n                product_type = obj_meta.get(\"family\")\n            if product_type == \"rig\":\n                rig = None\n                for child in obj.children:\n                    if child.type == 'ARMATURE':\n                        rig = child\n                        break\n                if not rig:\n                    raise Exception(\"No armature in the rig asset group.\")\n                if rig.animation_data and rig.animation_data.action:\n                    namespace = obj_meta.get('namespace')\n                    actions[namespace] = rig.animation_data.action\n\n        mat = asset_group.matrix_basis.copy()\n\n        self._remove_animation_instances(asset_group)\n\n        self._remove(asset_group)\n\n        self._process(str(libpath), asset_group, actions)\n\n        asset_group.matrix_basis = mat\n\n        metadata[\"libpath\"] = str(libpath)\n        metadata[\"representation\"] = repre_entity[\"id\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def exec_remove(self, container: Dict) -&gt; bool:\n        \"\"\"Remove an existing container from a Blender scene.\n\n        Arguments:\n            container (ayon:container-1.0): Container to remove,\n                from `host.ls()`.\n\n        Returns:\n            bool: Whether the container was deleted.\n        \"\"\"\n        object_name = container[\"objectName\"]\n        asset_group = bpy.data.objects.get(object_name)\n\n        if not asset_group:\n            return False\n\n        self._remove_animation_instances(asset_group)\n\n        self._remove(asset_group)\n\n        bpy.data.objects.remove(asset_group)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader.exec_remove","title":"<code>exec_remove(container)</code>","text":"<p>Remove an existing container from a Blender scene.</p> <p>Parameters:</p> Name Type Description Default <code>container (ayon</code> <p>container-1.0): Container to remove, from <code>host.ls()</code>.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the container was deleted.</p> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>def exec_remove(self, container: Dict) -&gt; bool:\n    \"\"\"Remove an existing container from a Blender scene.\n\n    Arguments:\n        container (ayon:container-1.0): Container to remove,\n            from `host.ls()`.\n\n    Returns:\n        bool: Whether the container was deleted.\n    \"\"\"\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n\n    if not asset_group:\n        return False\n\n    self._remove_animation_instances(asset_group)\n\n    self._remove(asset_group)\n\n    bpy.data.objects.remove(asset_group)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader.exec_update","title":"<code>exec_update(container, context)</code>","text":"<p>Update the loaded asset.</p> <p>This will remove all objects of the current collection, load the new ones and add them to the collection. If the objects of the collection are used in another collection they will not be removed, only unlinked. Normally this should not be the case though.</p> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>def exec_update(self, container: Dict, context: Dict):\n    \"\"\"Update the loaded asset.\n\n    This will remove all objects of the current collection, load the new\n    ones and add them to the collection.\n    If the objects of the collection are used in another collection they\n    will not be removed, only unlinked. Normally this should not be the\n    case though.\n    \"\"\"\n    repre_entity = context[\"representation\"]\n    object_name = container[\"objectName\"]\n    asset_group = bpy.data.objects.get(object_name)\n    libpath = Path(self.filepath_from_context(context))\n    extension = libpath.suffix.lower()\n\n    self.log.info(\n        \"Container: %s\\nRepresentation: %s\",\n        pformat(container, indent=2),\n        pformat(repre_entity, indent=2),\n    )\n\n    assert asset_group, (\n        f\"The asset is not loaded: {container['objectName']}\"\n    )\n    assert libpath, (\n        \"No existing library file found for {container['objectName']}\"\n    )\n    assert libpath.is_file(), (\n        f\"The file doesn't exist: {libpath}\"\n    )\n    assert extension in VALID_EXTENSIONS, (\n        f\"Unsupported file: {libpath}\"\n    )\n\n    metadata = asset_group.get(AYON_PROPERTY)\n    group_libpath = metadata[\"libpath\"]\n\n    normalized_group_libpath = (\n        str(Path(bpy.path.abspath(group_libpath)).resolve())\n    )\n    normalized_libpath = (\n        str(Path(bpy.path.abspath(str(libpath))).resolve())\n    )\n    self.log.debug(\n        \"normalized_group_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n        normalized_group_libpath,\n        normalized_libpath,\n    )\n    if normalized_group_libpath == normalized_libpath:\n        self.log.info(\"Library already loaded, not updating...\")\n        return\n\n    actions = {}\n\n    for obj in asset_group.children:\n        obj_meta = obj.get(AYON_PROPERTY)\n        product_type = obj_meta.get(\"productType\")\n        if product_type is None:\n            product_type = obj_meta.get(\"family\")\n        if product_type == \"rig\":\n            rig = None\n            for child in obj.children:\n                if child.type == 'ARMATURE':\n                    rig = child\n                    break\n            if not rig:\n                raise Exception(\"No armature in the rig asset group.\")\n            if rig.animation_data and rig.animation_data.action:\n                namespace = obj_meta.get('namespace')\n                actions[namespace] = rig.animation_data.action\n\n    mat = asset_group.matrix_basis.copy()\n\n    self._remove_animation_instances(asset_group)\n\n    self._remove(asset_group)\n\n    self._process(str(libpath), asset_group, actions)\n\n    asset_group.matrix_basis = mat\n\n    metadata[\"libpath\"] = str(libpath)\n    metadata[\"representation\"] = repre_entity[\"id\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_layout_json.html#client.ayon_blender.plugins.load.load_layout_json.JsonLayoutLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_layout_json.py</code> <pre><code>def process_asset(self,\n                  context: dict,\n                  name: str,\n                  namespace: Optional[str] = None,\n                  options: Optional[Dict] = None):\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    asset_name = plugin.prepare_scene_name(folder_name, product_name)\n    unique_number = plugin.get_unique_number(folder_name, product_name)\n    group_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n\n    asset_group = bpy.data.objects.new(group_name, object_data=None)\n    asset_group.empty_display_type = 'SINGLE_ARROW'\n    add_to_ayon_container(asset_group)\n\n    self._process(libpath, asset_name, asset_group, None)\n\n    bpy.context.scene.collection.objects.link(asset_group)\n\n    asset_group[AYON_PROPERTY] = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or '',\n        \"loader\": str(self.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"libpath\": libpath,\n        \"asset_name\": asset_name,\n        \"parent\": context[\"representation\"][\"versionId\"],\n        \"productType\": context[\"product\"][\"productType\"],\n        \"project_name\": context[\"project\"][\"name\"],\n        \"objectName\": group_name,\n    }\n\n    self[:] = asset_group.children\n    return asset_group.children\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_look.html","title":"load_look","text":"<p>Load a model asset in Blender.</p>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_look.html#client.ayon_blender.plugins.load.load_look.BlendLookLoader","title":"<code>BlendLookLoader</code>","text":"<p>               Bases: <code>BlenderLoader</code></p> <p>Load models from a .blend file.</p> <p>Because they come from a .blend file we can simply link the collection that contains the model. There is no further need to 'containerise' it.</p> Source code in <code>client/ayon_blender/plugins/load/load_look.py</code> <pre><code>class BlendLookLoader(plugin.BlenderLoader):\n    \"\"\"Load models from a .blend file.\n\n    Because they come from a .blend file we can simply link the collection that\n    contains the model. There is no further need to 'containerise' it.\n    \"\"\"\n\n    product_types = {\"look\"}\n    representations = {\"json\"}\n\n    label = \"Load Look\"\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def get_all_children(self, obj):\n        children = list(obj.children)\n\n        for child in children:\n            children.extend(child.children)\n\n        return children\n\n    def _process(self, libpath, container_name, objects):\n        with open(libpath, \"r\") as fp:\n            data = json.load(fp)\n\n        path = os.path.dirname(libpath)\n        materials_path = f\"{path}/resources\"\n\n        materials = []\n\n        for entry in data:\n            file = entry.get('fbx_filename')\n            if file is None:\n                continue\n\n            bpy.ops.import_scene.fbx(filepath=f\"{materials_path}/{file}\")\n\n            mesh = [o for o in bpy.context.scene.objects if o.select_get()][0]\n            material = mesh.data.materials[0]\n            material.name = f\"{material.name}:{container_name}\"\n\n            texture_file = entry.get('tga_filename')\n            if texture_file:\n                node_tree = material.node_tree\n                pbsdf = node_tree.nodes['Principled BSDF']\n                base_color = pbsdf.inputs[0]\n                tex_node = base_color.links[0].from_node\n                tex_node.image.filepath = f\"{materials_path}/{texture_file}\"\n\n            materials.append(material)\n\n            for obj in objects:\n                for child in self.get_all_children(obj):\n                    mesh_name = child.name.split(':')[0]\n                    if mesh_name == material.name.split(':')[0]:\n                        child.data.materials.clear()\n                        child.data.materials.append(material)\n                        break\n\n            bpy.data.objects.remove(mesh)\n\n        return materials, objects\n\n    def process_asset(\n        self, context: dict, name: str, namespace: Optional[str] = None,\n        options: Optional[Dict] = None\n    ) -&gt; Optional[List]:\n        \"\"\"\n        Arguments:\n            name: Use pre-defined name\n            namespace: Use pre-defined namespace\n            context: Full parenthood of representation to load\n            options: Additional settings dictionary\n        \"\"\"\n\n        libpath = self.filepath_from_context(context)\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        lib_container = plugin.prepare_scene_name(\n            folder_name, product_name\n        )\n        unique_number = plugin.get_unique_number(\n            folder_name, product_name\n        )\n        namespace = namespace or f\"{folder_name}_{unique_number}\"\n        container_name = plugin.prepare_scene_name(\n            folder_name, product_name, unique_number\n        )\n\n        container = bpy.data.collections.new(lib_container)\n        container.name = container_name\n        containerise_existing(\n            container,\n            name,\n            namespace,\n            context,\n            self.__class__.__name__,\n        )\n\n        metadata = container.get(AYON_PROPERTY)\n\n        metadata[\"libpath\"] = libpath\n        metadata[\"lib_container\"] = lib_container\n\n        selected = [o for o in bpy.context.scene.objects if o.select_get()]\n\n        materials, objects = self._process(libpath, container_name, selected)\n\n        # Save the list of imported materials in the metadata container\n        metadata[\"objects\"] = objects\n        metadata[\"materials\"] = materials\n\n        metadata[\"parent\"] = context[\"representation\"][\"versionId\"]\n        metadata[\"product_type\"] = context[\"product\"][\"productType\"]\n        metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n        nodes = list(container.objects)\n        nodes.append(container)\n        self[:] = nodes\n        return nodes\n\n    def update(self, container: Dict, context: Dict):\n        collection = bpy.data.collections.get(container[\"objectName\"])\n        repre_entity = context[\"representation\"]\n        libpath = Path(self.filepath_from_context(context))\n        extension = libpath.suffix.lower()\n\n        self.log.info(\n            \"Container: %s\\nRepresentation: %s\",\n            pformat(container, indent=2),\n            pformat(repre_entity, indent=2),\n        )\n\n        assert collection, (\n            f\"The asset is not loaded: {container['objectName']}\"\n        )\n        assert not (collection.children), (\n            \"Nested collections are not supported.\"\n        )\n        assert libpath, (\n            \"No existing library file found for {container['objectName']}\"\n        )\n        assert libpath.is_file(), (\n            f\"The file doesn't exist: {libpath}\"\n        )\n        assert extension in VALID_EXTENSIONS, (\n            f\"Unsupported file: {libpath}\"\n        )\n\n        collection_metadata = collection.get(AYON_PROPERTY)\n        collection_libpath = collection_metadata[\"libpath\"]\n\n        normalized_collection_libpath = (\n            str(Path(bpy.path.abspath(collection_libpath)).resolve())\n        )\n        normalized_libpath = (\n            str(Path(bpy.path.abspath(str(libpath))).resolve())\n        )\n        self.log.debug(\n            \"normalized_collection_libpath:\\n  %s\\nnormalized_libpath:\\n  %s\",\n            normalized_collection_libpath,\n            normalized_libpath,\n        )\n        if normalized_collection_libpath == normalized_libpath:\n            self.log.info(\"Library already loaded, not updating...\")\n            return\n\n        for obj in collection_metadata['objects']:\n            for child in self.get_all_children(obj):\n                child.data.materials.clear()\n\n        for material in collection_metadata['materials']:\n            bpy.data.materials.remove(material)\n\n        namespace = collection_metadata['namespace']\n        name = collection_metadata['name']\n\n        container_name = f\"{namespace}_{name}\"\n\n        materials, objects = self._process(\n            libpath, container_name, collection_metadata['objects'])\n\n        collection_metadata[\"objects\"] = objects\n        collection_metadata[\"materials\"] = materials\n        collection_metadata[\"libpath\"] = str(libpath)\n        collection_metadata[\"representation\"] = repre_entity[\"id\"]\n        collection_metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    def remove(self, container: Dict) -&gt; bool:\n        collection = bpy.data.collections.get(container[\"objectName\"])\n        if not collection:\n            return False\n\n        collection_metadata = collection.get(AYON_PROPERTY)\n\n        for obj in collection_metadata['objects']:\n            for child in self.get_all_children(obj):\n                child.data.materials.clear()\n\n        for material in collection_metadata['materials']:\n            bpy.data.materials.remove(material)\n\n        bpy.data.collections.remove(collection)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/load/load_look.html#client.ayon_blender.plugins.load.load_look.BlendLookLoader.process_asset","title":"<code>process_asset(context, name, namespace=None, options=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Use pre-defined name</p> required <code>namespace</code> <code>Optional[str]</code> <p>Use pre-defined namespace</p> <code>None</code> <code>context</code> <code>dict</code> <p>Full parenthood of representation to load</p> required <code>options</code> <code>Optional[Dict]</code> <p>Additional settings dictionary</p> <code>None</code> Source code in <code>client/ayon_blender/plugins/load/load_look.py</code> <pre><code>def process_asset(\n    self, context: dict, name: str, namespace: Optional[str] = None,\n    options: Optional[Dict] = None\n) -&gt; Optional[List]:\n    \"\"\"\n    Arguments:\n        name: Use pre-defined name\n        namespace: Use pre-defined namespace\n        context: Full parenthood of representation to load\n        options: Additional settings dictionary\n    \"\"\"\n\n    libpath = self.filepath_from_context(context)\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    lib_container = plugin.prepare_scene_name(\n        folder_name, product_name\n    )\n    unique_number = plugin.get_unique_number(\n        folder_name, product_name\n    )\n    namespace = namespace or f\"{folder_name}_{unique_number}\"\n    container_name = plugin.prepare_scene_name(\n        folder_name, product_name, unique_number\n    )\n\n    container = bpy.data.collections.new(lib_container)\n    container.name = container_name\n    containerise_existing(\n        container,\n        name,\n        namespace,\n        context,\n        self.__class__.__name__,\n    )\n\n    metadata = container.get(AYON_PROPERTY)\n\n    metadata[\"libpath\"] = libpath\n    metadata[\"lib_container\"] = lib_container\n\n    selected = [o for o in bpy.context.scene.objects if o.select_get()]\n\n    materials, objects = self._process(libpath, container_name, selected)\n\n    # Save the list of imported materials in the metadata container\n    metadata[\"objects\"] = objects\n    metadata[\"materials\"] = materials\n\n    metadata[\"parent\"] = context[\"representation\"][\"versionId\"]\n    metadata[\"product_type\"] = context[\"product\"][\"productType\"]\n    metadata[\"project_name\"] = context[\"project\"][\"name\"]\n\n    nodes = list(container.objects)\n    nodes.append(container)\n    self[:] = nodes\n    return nodes\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_current_file.html#client.ayon_blender.plugins.publish.collect_current_file.CollectBlenderCurrentFile","title":"<code>CollectBlenderCurrentFile</code>","text":"<p>               Bases: <code>BlenderContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_blender/plugins/publish/collect_current_file.py</code> <pre><code>class CollectBlenderCurrentFile(plugin.BlenderContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Blender Current File\"\n    hosts = [\"blender\"]\n\n    def process(self, context):\n        \"\"\"Inject the current working file\"\"\"\n        current_file = workio.current_file()\n        context.data[\"currentFile\"] = current_file\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_current_file.html#client.ayon_blender.plugins.publish.collect_current_file.CollectBlenderCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_blender/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file\"\"\"\n    current_file = workio.current_file()\n    context.data[\"currentFile\"] = current_file\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_file_dependencies.html","title":"collect_file_dependencies","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_file_dependencies.html#client.ayon_blender.plugins.publish.collect_file_dependencies.CollectFileDependencies","title":"<code>CollectFileDependencies</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Gather all files referenced in this scene.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_file_dependencies.py</code> <pre><code>class CollectFileDependencies(pyblish.api.ContextPlugin):\n    \"\"\"Gather all files referenced in this scene.\"\"\"\n\n    label = \"Collect File Dependencies\"\n    order = pyblish.api.CollectorOrder - 0.49\n    hosts = [\"blender\"]\n    families = [\"render\"]\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        # Disable plug-in if not used for deadline submission anyway\n        # Note: This setting has been removed in `ayon-deadline` with\n        #   https://github.com/ynput/ayon-deadline/pull/49\n        #   but the logic here is kept for compatibility with older releases.\n        cls.enabled = (\n            project_settings\n            .get(\"deadline\", {})\n            .get(\"publish\", {})\n            .get(\"BlenderSubmitDeadline\", {})\n            .get(\"asset_dependencies\", True)\n        )\n\n    def process(self, context):\n        dependencies = set()\n\n        # Add alembic files as dependencies\n        for cache in bpy.data.cache_files:\n            dependencies.add(\n                Path(bpy.path.abspath(cache.filepath)).resolve().as_posix())\n\n        # Add image files as dependencies\n        for image in bpy.data.images:\n            if image.filepath:\n                dependencies.add(Path(\n                    bpy.path.abspath(image.filepath)).resolve().as_posix())\n\n        context.data[\"fileDependencies\"] = list(dependencies)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_instance.html","title":"collect_instance","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_instance.html#client.ayon_blender.plugins.publish.collect_instance.CollectBlenderInstanceData","title":"<code>CollectBlenderInstanceData</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Collect members of the instance.</p> <p>For a Collection this includes itself and all directly linked objects and their full hierarchy of children objects. It also includes direct child collections. It does not include objects or collections from collections inside the Collection (it does not recurse into nested collections).</p> <p>For an Object (e.g. instance asset group) this includes all its children hierarchy and the Object itself.</p> <p>These members are then set on the instance as a list of objects.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_instance.py</code> <pre><code>class CollectBlenderInstanceData(plugin.BlenderInstancePlugin,\n                                 AYONPyblishPluginMixin):\n    \"\"\"Collect members of the instance.\n\n    For a Collection this includes itself and all directly linked objects and\n    their full hierarchy of children objects. It also includes direct child\n    collections. It does *not* include objects or collections from collections\n    inside the Collection (it does not recurse into nested collections).\n\n    For an Object (e.g. instance asset group) this includes all its children\n    hierarchy and the Object itself.\n\n    These members are then set on the instance as a list of objects.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    hosts = [\"blender\"]\n    families = [\"model\", \"pointcache\", \"animation\", \"rig\", \"camera\", \"layout\",\n                \"blendScene\", \"usd\", \"action\"]\n    label = \"Collect Instance\"\n\n    def process(self, instance):\n        instance_node = instance.data[\"transientData\"][\"instance_node\"]\n\n        # Collect members of the instance\n        members: set[str] = {instance_node}\n        self.log.debug(f\"Found instance node: {instance_node}\")\n        if isinstance(instance_node, bpy.types.Collection):\n            # Add all linked objects to itself and all child collections\n            objects = set(instance_node.all_objects)\n            members.update(objects)\n\n            # Add all object children recursively (hierarchy)\n            # Note that for a `bpy.types.Collection` the `children` and\n            # `children_recursive` only include child collections, not objects.\n            # To get the linked objects (and their children) we first collect\n            # the objects, and then add all their `children_recursive`.\n            attr_values = self.get_attr_values_from_data(instance.data)\n            if attr_values.get(\n                \"collection_include_object_children_recursive\", True\n            ):\n                for obj in objects:\n                    members.update(obj.children_recursive)\n\n            # Add child collections\n            members.update(instance_node.children_recursive)\n\n            # Special case for animation instances, include armatures\n            if instance.data[\"productType\"] in [\"animation\", \"action\"]:\n                for obj in instance_node.objects:\n                    if obj.type == 'EMPTY' and obj.get(AYON_PROPERTY):\n                        members.update(\n                            child for child in obj.children\n                            if child.type == 'ARMATURE'\n                        )\n        elif isinstance(instance_node, bpy.types.Object):\n            members.update(instance_node.children_recursive)\n        else:\n            raise KnownPublishError(\n                f\"Unsupported instance node type '{type(instance_node)}' \"\n                f\"for instance '{instance}'\"\n            )\n\n        instance[:] = list(members)\n\n    @classmethod\n    def get_attr_defs_for_instance(\n        cls, create_context, instance\n    ):\n        if not cls.instance_matches_plugin_families(instance):\n            return []\n\n        # If the instance is a collection, we provide an optional option\n        # to include the children hierarchy of objects in the collection.\n        instance_node = instance.transient_data.get(\"instance_node\", None)\n        if not isinstance(instance_node, bpy.types.Collection):\n            return []\n\n        return [\n            BoolDef(\n                \"collection_include_object_children_recursive\",\n                label=\"Expand to All Children\",\n                default=True,\n                tooltip=(\n                    \"Includes all descendant children of the linked objects, \"\n                    \"even if not manually selected.\\n\"\n                    \"If disabled, only objects directly linked to the \"\n                    \"collection will be included.\"\n                )\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_instance_frame_range.html","title":"collect_instance_frame_range","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_local_render_instances.html","title":"collect_local_render_instances","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_local_render_instances.html#client.ayon_blender.plugins.publish.collect_local_render_instances.CollectLocalRenderInstances","title":"<code>CollectLocalRenderInstances</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Collect instances for local render.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_local_render_instances.py</code> <pre><code>class CollectLocalRenderInstances(plugin.BlenderInstancePlugin):\n    \"\"\"Collect instances for local render.\n    \"\"\"\n    order = pyblish.api.CollectorOrder + 0.31\n    families = [\"render\"]\n\n    label = \"Collect local render instances\"\n\n    transfer_keys = {\n        \"creator_attributes\",\n        \"publish_attributes\",\n    }\n\n    def process(self, instance):\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"Render on farm is enabled. \"\n                           \"Skipping local render collecting.\")\n            return\n\n        self.log.debug(\"Expected files for local render: %s\",\n                       instance.data.get(\"expectedFiles\"))\n\n        # Use same logic as how instances get created for farm submissions\n        skeleton = create_skeleton_instance(\n            instance,\n            # TODO: These should be fixed in core to just allow the default\n            #  None to work\n            families_transfer=[],\n            instance_transfer={},\n        )\n        for key in self.transfer_keys:\n            if key in instance.data:\n                skeleton[key] = instance.data[key]\n\n        aov_instances = create_instances_for_aov(\n            instance=instance,\n            skeleton=skeleton,\n            aov_filter={\"blender\": [\".*\"]},  # allow all as reviewables\n            skip_integration_repre_list=[],\n            do_not_add_review=False,\n        )\n\n        # Create instances for each AOV\n        context = instance.context\n        anatomy = context.data[\"anatomy\"]\n\n        render_target: str = instance.data.get(\"creator_attributes\", {}).get(\n            \"render_target\", \"local\"\n        )\n\n        # Add the instances directly to the current publish context\n        for aov_instance_data in aov_instances:\n            # Make a shallow copy of transient data because it'll likely\n            # contain data that can't be deep-copied, e.g. Blender objects.\n            if \"transientData\" in instance.data:\n                aov_instance_data[\"transientData\"] = dict(\n                    instance.data[\"transientData\"]\n                )\n\n            # The `create_instances_for_aov` makes some paths rootless paths,\n            # like the \"stagingDir\" for each representation which we will make\n            # absolute again.\n            for repre in aov_instance_data[\"representations\"]:\n                repre[\"stagingDir\"] = anatomy.fill_root(repre[\"stagingDir\"])\n\n            aov_instance = context.create_instance(\n                aov_instance_data[\"productName\"]\n            )\n            aov_instance.data.update(aov_instance_data)\n\n            families = [f\"render.{render_target}\"]\n            if \"review\" in aov_instance.data[\"families\"]:\n                families.append(\"review\")\n            aov_instance.data[\"families\"] = families\n\n        # Skip integrating original render instance.\n        # We are not removing it because it's used to trigger the render.\n        instance.data[\"integrate\"] = False\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html","title":"collect_render","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.CollectBlenderRender","title":"<code>CollectBlenderRender</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Gather all publishable render instances.</p> <p>For the instance node (bpy.types.CompositorNodeOutputFile) we collect the configured output paths (FileSlots or LayerSlots) and their colorspaces.</p>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.CollectBlenderRender--aov-identifiers","title":"AOV identifiers","text":"<p>When multiple outputs are present (only the case when not rendering to multilayer EXR) then we assign each output an 'aov identifier' that will be added to the product name. So that product: <code>renderLightingMain</code> becomes for example <code>renderLightingMain.beauty</code> and <code>renderLightingMain.diffuse</code>.</p>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.CollectBlenderRender--requires-enabled-compositing-node-tree","title":"Requires enabled compositing node tree","text":"<p>The render workflow requires Blender to be configured to use the Compositor Node Tree, because it relies on <code>CompositorNodeOutputFile</code> to define the output files for rendering.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_render.py</code> <pre><code>class CollectBlenderRender(plugin.BlenderInstancePlugin):\n    \"\"\"Gather all publishable render instances.\n\n    For the instance node (bpy.types.CompositorNodeOutputFile) we collect the\n    configured output paths (FileSlots or LayerSlots) and their colorspaces.\n\n    ### AOV identifiers\n\n    When multiple outputs are present (only the case when not rendering to\n    multilayer EXR) then we assign each output an 'aov identifier' that will\n    be added to the product name. So that product: `renderLightingMain` becomes\n    for example `renderLightingMain.beauty` and `renderLightingMain.diffuse`.\n\n    ### Requires enabled compositing node tree\n\n    The render workflow requires Blender to be configured to use the\n    Compositor Node Tree, because it relies on `CompositorNodeOutputFile` to\n    define the output files for rendering.\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.01\n    hosts = [\"blender\"]\n    families = [\"render\"]\n    label = \"Collect Render\"\n    sync_workfile_version = False\n\n    def process(self, instance: pyblish.api.Instance):\n\n        comp_output_node: \"bpy.types.CompositorNodeOutputFile\" = (\n            instance.data[\"transientData\"][\"instance_node\"])\n        frame_start: int = instance.data[\"frameStartHandle\"]\n        frame_end: int = instance.data[\"frameEndHandle\"]\n        creator_attributes: dict = instance.data[\"creator_attributes\"]\n        frame_step: int = creator_attributes.get(\"step\", 1)\n        review: bool = creator_attributes.get(\"review\", False)\n\n        colorspace_data = self.get_colorspace_data(comp_output_node)\n        self.log.debug(f\"Collected colorspace data: {colorspace_data}\")\n        if colorspace_data:\n            instance.data.update(colorspace_data)\n\n        render_products = colorspace.ARenderProduct(\n            frame_start=frame_start,\n            frame_end=frame_end\n        )\n\n        expected_files: dict[str, list[str]] = {}\n        outputs = self.get_expected_outputs(comp_output_node, instance)\n        for aov_identifier, output_path in outputs.items():\n            aov_label = aov_identifier or \"&lt;beauty&gt;\"\n            self.log.debug(f\"AOV '{aov_label}': {output_path}\")\n\n            expected_files[aov_identifier] = self.generate_expected_frames(\n                output_path,\n                frame_start,\n                frame_end,\n                frame_step\n            )\n\n            # We need to have a matching 'renderProduct' entry so that\n            # the logic in core for `_create_instances_for_aov` assigns\n            # the colorspace data to the relevant AOV instance.\n            aov_colorspace: str = (\n                colorspace_data[\"colorspace\"] if colorspace_data else \"\"\n            )\n            render_products.add_render_product(\n                product_name=aov_identifier,\n                colorspace=aov_colorspace\n            )\n\n            # Log the expected sequence of frames for the AOV\n            files = files_as_sequence(expected_files[aov_identifier])\n            self.log.debug(f\"Expected frames: {files}\")\n\n        # Collect Render Target\n        local_render: bool = creator_attributes.get(\"render_target\") == \"local\"\n\n        context = instance.context\n        instance.data.update({\n            \"families\": [\"render\", \"render.farm\"],\n            \"fps\": context.data[\"fps\"],\n            \"byFrameStep\": frame_step,\n            \"review\": review,\n            \"multipartExr\": self.is_multilayer_exr(comp_output_node),\n            \"farm\": not local_render,\n            \"expectedFiles\": [expected_files],\n            \"renderProducts\": render_products,\n        })\n\n    def get_colorspace_data(\n        self,\n        node: \"bpy.types.CompositorNodeOutputFile\"\n    ) -&gt; Optional[RenderColorspaceData]:\n        ocio_path = os.getenv(\"OCIO\")\n        if not ocio_path:\n            # Assume not color-managed\n            return None\n\n        # TODO: Technically Blender hides/disabled Display/View versus\n        #  Colorspace depending on `node.format.has_linear_colorspace`\n        #  which may mean it uses one of the two instead of both.\n        # Get from node or scene\n        if node.format.color_management == \"OVERRIDE\":\n            display: str = node.format.display_settings.display_device\n            view: str = node.format.view_settings.view_transform\n            colorspace: str = node.format.linear_colorspace_settings.name\n            # look: str = node.format.view_settings.look\n        else:\n            display: str = bpy.context.scene.display_settings.display_device\n            view: str = bpy.context.scene.view_settings.view_transform\n            # TODO: Where do we get colorspace if it doesn't come from node\n            #  override nor scene override? In Blender 5+ there seems to be\n            #  bpy.context.blend_data.colorspace.working_space but similar\n            #  does not exist in Blender 4\n            # This gets the scene render colorspace, which should technically\n            # only apply when it's set to \"Override\" on the scene output\n            # settings. But since we can't find the source Follow Scene value\n            # it's the best alternative for now to rely upon, especially\n            # because the default value does match the default render\n            # colorspace.\n            colorspace: str = (\n                bpy.context.scene.render\n                .image_settings.linear_colorspace_settings.name\n            )\n            # look: str = bpy.context.scene.view_settings.look\n\n        return {\n            \"colorspaceConfig\": ocio_path,\n            \"colorspaceDisplay\": display,\n            \"colorspaceView\": view,\n            \"colorspace\": colorspace\n        }\n\n    def is_multilayer_exr(\n        self,\n        node: \"bpy.types.CompositorNodeOutputFile\"\n    ) -&gt; bool:\n        return node.format.file_format == \"OPEN_EXR_MULTILAYER\"\n\n    def get_expected_outputs(\n        self,\n        node: \"bpy.types.CompositorNodeOutputFile\",\n        instance: pyblish.api.Instance\n    ) -&gt; dict[str, str]:\n        \"\"\"Return the expected output files from a compositor node output file.\n\n        The output paths are **not** converted to individual frames and will\n        still contain the `####` frame padding tokens to. So the final path\n        would still need to be constructed from the resulting path.\n\n        Even if the path set in the scene does not contain the `#` frame\n        tokens or an extension, this method will ensure that the returned\n        paths do and qualify as a full path with `#` as padding frame tokens.\n\n        Returns:\n            dict[str]: The full output image or sequence paths per identifier.\n\n        \"\"\"\n        # Blender 5\n        if lib.get_blender_version() &gt;= (5, 0, 0):\n            return self._get_expected_outputs_blender_5(node)\n\n        # Blender 4\n        output_paths = self._get_expected_outputs_blender_4(node)\n        is_multilayer = self.is_multilayer_exr(node)\n        outputs_per_aov = {}\n        for output_path in output_paths:\n            if is_multilayer:\n                # Only ever a single output - we enforce the identifier to an\n                # empty string to have it considered to not split into a\n                # subname for the product\n                aov_identifier = \"\"\n            else:\n                aov_identifier = self.get_aov_identifier(\n                    output_path,\n                    instance\n                )\n            outputs_per_aov[aov_identifier] = output_path\n        return outputs_per_aov\n\n    def _get_expected_outputs_blender_5(\n        self,\n        node: \"bpy.types.CompositorNodeOutputFile\"\n    ) -&gt; dict[str, str]:\n        \"\"\"Return output filepaths for CompositorNodeOutputFile in Blender 5\"\"\"\n        directory: str = node.directory\n        file_name: str = node.file_name\n        outputs: dict[str, str] = {}\n        base_path: str = os.path.join(directory, file_name)\n\n        if self.is_multilayer_exr(node):\n            file_path = self._resolve_full_render_path(\n                path=base_path,\n                file_format=node.format.file_format\n            )\n            outputs[\"\"] = file_path  # beauty only\n        else:\n            # Separate images\n            for output_item in node.file_output_items:\n                if output_item.override_node_format:\n                    output_format = output_item.format.file_format\n                else:\n                    output_format = node.format.file_format\n\n                # Resolve the full render path for the output path\n                file_path = self._resolve_full_render_path(\n                    path=f\"{base_path}{output_item.name}\",\n                    file_format=output_format\n                )\n\n                # Use the output item name as AOV identifier but remove any\n                # special characters like `#`, `_`, `.` and spaces.\n                aov_identifier: str = re.sub(\"[#_. ]\", \"\", output_item.name)\n                outputs[aov_identifier] = file_path\n        return outputs\n\n    def _get_expected_outputs_blender_4(\n        self,\n        node: \"bpy.types.CompositorNodeOutputFile\"\n    ) -&gt; list[str]:\n        \"\"\"Return output filepaths for CompositorNodeOutputFile in Blender 4\"\"\"\n        outputs: list[str] = []\n        base_path: str = node.base_path\n\n        if self.is_multilayer_exr(node):\n            # Single multi-layered EXR containing all the images as layers\n            # for layer_slot in node.layer_slots:\n            #     name = layer_slot.name\n            # Resolve the full render path for the output path\n            file_path = self._resolve_full_render_path(\n                path=base_path,\n                file_format=node.format.file_format\n            )\n            outputs.append(file_path)\n        else:\n            for file_slot in node.file_slots:\n                # TODO: Should we skip file slots that are not connected?\n                #  (what does blender do?)\n                # TODO: Do we need to check `file_slot.save_as_render`?\n                # TODO: Collect format from File Slot (it can override it)\n                #  however this would also need support by other publish\n                #  plug-ins to allow custom colorspace data per output AOV\n                #  (render product) within a single instance\n                if file_slot.use_node_format:\n                    output_format = node.format.file_format\n                else:\n                    output_format = file_slot.format.file_format\n\n                # Append slot path to base path\n                sub_path: str = file_slot.path\n                file_path = os.path.join(base_path, sub_path)\n\n                # Resolve the full render path for the output path\n                file_path = self._resolve_full_render_path(\n                    path=file_path,\n                    file_format=output_format\n                )\n\n                outputs.append(file_path)\n        return outputs\n\n    def _resolve_full_render_path(\n            self,\n            path: str,\n            file_format: str\n    ) -&gt; str:\n        \"\"\"Resolve the full render path for the output path.\n\n        Filepaths in render outputs may be set relatively, with or\n        without # tokens, with or without file extension. However, we need\n        them consistently formatted for collecting them correctly.\n        So we ensure the # token is present and the file extension is added.\n\n        The output path will be a normalized, absolute path with `#` tokens\n        in it that indicated the padded frame number.\n\n        \"\"\"\n        # Ensure the extension is for the file\n        extension = render_lib.get_file_format_extension(file_format)\n        path = bpy.path.ensure_ext(path, f\".{extension}\")\n\n        # If the path does not contain a frame token `#` then we append\n        # the default frame token `####` to the end of the path before the\n        # extension.\n        if \"#\" not in os.path.basename(path):\n            base, ext = os.path.splitext(path)\n            path = f\"{base}####{ext}\"\n\n        # Generate an absolute normalized path for the output\n        path = bpy.path.abspath(path)\n        path = os.path.normpath(path)\n        return path\n\n    @staticmethod\n    def generate_expected_frames(\n        path_with_frame_token: str,\n        frame_start: int,\n        frame_end: int,\n        frame_step: int\n    ) -&gt; list[str]:\n        \"\"\"Generate the expected files for each frame.\n\n        It replaces the sequence of `#` with the frame number.\n\n        Returns:\n            list[str]: All frames for input path.\n\n        \"\"\"\n        directory, filename = os.path.split(path_with_frame_token)\n\n        # Find the last occurrence of `#+` in the filename to determine\n        # the frame token position. If multiple `%#` patterns are present\n        # in the filename Blender uses the last one for the frame number.\n        match = re.search(r\"(#+)[^#]+$\", filename)\n        if not match:\n            raise ValueError(\n                f\"Path '{path_with_frame_token}' does not contain a frame \"\n                \"token '#'.\"\n            )\n        padding: int = len(match.group(1))\n        filename, ext = os.path.splitext(filename)\n\n        filename_head = filename[:match.start(1)]\n        filename_tail = filename[match.end(1):]\n\n        expected_files: list[str] = []\n        for frame in range(frame_start, frame_end + 1, frame_step):\n            # Replace #### with padded number\n            frame_str = str(frame).zfill(padding)\n            frame_filename = f\"{filename_head}{frame_str}{filename_tail}\"\n            expected_file = f\"{os.path.join(directory, frame_filename)}{ext}\"\n            expected_files.append(expected_file.replace(\"\\\\\", \"/\"))\n\n        return expected_files\n\n    def get_aov_identifier(\n            self, path: str,\n            instance: pyblish.api.Instance\n    ) -&gt; str:\n        # TODO: Define sensible way to compute AOV name for the publish product\n        #  based on the image outputs the comp node (when NOT multilayer EXR).\n        #  This identifier will be the suffix for the product, like:\n        #  `renderLightingMain.{aov}` -&gt; `renderLightingMain.beauty`\n        # Change \"/path/to/my_filename.####.exr\" to \"my_filename\"\n        aov_identifier = os.path.basename(path).split(\"#\", 1)[0].strip(\"._\")\n\n        # The creator's prepare rendering setup logic will create the filenames\n        # prefixed with `{variant}_`. We don't want to include that as a part\n        # of the AOV identifier because it'd double the variant in the product\n        # name.\n        variant = instance.data.get(\"variant\", \"\")\n        variant_prefix = f\"{variant}_\"\n        if aov_identifier.startswith(variant_prefix):\n            self.log.debug(\n                f\"Stripping variant '{variant}' prefix from AOV identifier: \"\n                f\"{aov_identifier}\"\n            )\n            aov_identifier = aov_identifier.removeprefix(variant_prefix)\n        return aov_identifier\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.CollectBlenderRender.generate_expected_frames","title":"<code>generate_expected_frames(path_with_frame_token, frame_start, frame_end, frame_step)</code>  <code>staticmethod</code>","text":"<p>Generate the expected files for each frame.</p> <p>It replaces the sequence of <code>#</code> with the frame number.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: All frames for input path.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_render.py</code> <pre><code>@staticmethod\ndef generate_expected_frames(\n    path_with_frame_token: str,\n    frame_start: int,\n    frame_end: int,\n    frame_step: int\n) -&gt; list[str]:\n    \"\"\"Generate the expected files for each frame.\n\n    It replaces the sequence of `#` with the frame number.\n\n    Returns:\n        list[str]: All frames for input path.\n\n    \"\"\"\n    directory, filename = os.path.split(path_with_frame_token)\n\n    # Find the last occurrence of `#+` in the filename to determine\n    # the frame token position. If multiple `%#` patterns are present\n    # in the filename Blender uses the last one for the frame number.\n    match = re.search(r\"(#+)[^#]+$\", filename)\n    if not match:\n        raise ValueError(\n            f\"Path '{path_with_frame_token}' does not contain a frame \"\n            \"token '#'.\"\n        )\n    padding: int = len(match.group(1))\n    filename, ext = os.path.splitext(filename)\n\n    filename_head = filename[:match.start(1)]\n    filename_tail = filename[match.end(1):]\n\n    expected_files: list[str] = []\n    for frame in range(frame_start, frame_end + 1, frame_step):\n        # Replace #### with padded number\n        frame_str = str(frame).zfill(padding)\n        frame_filename = f\"{filename_head}{frame_str}{filename_tail}\"\n        expected_file = f\"{os.path.join(directory, frame_filename)}{ext}\"\n        expected_files.append(expected_file.replace(\"\\\\\", \"/\"))\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.CollectBlenderRender.get_expected_outputs","title":"<code>get_expected_outputs(node, instance)</code>","text":"<p>Return the expected output files from a compositor node output file.</p> <p>The output paths are not converted to individual frames and will still contain the <code>####</code> frame padding tokens to. So the final path would still need to be constructed from the resulting path.</p> <p>Even if the path set in the scene does not contain the <code>#</code> frame tokens or an extension, this method will ensure that the returned paths do and qualify as a full path with <code>#</code> as padding frame tokens.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str]: The full output image or sequence paths per identifier.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_render.py</code> <pre><code>def get_expected_outputs(\n    self,\n    node: \"bpy.types.CompositorNodeOutputFile\",\n    instance: pyblish.api.Instance\n) -&gt; dict[str, str]:\n    \"\"\"Return the expected output files from a compositor node output file.\n\n    The output paths are **not** converted to individual frames and will\n    still contain the `####` frame padding tokens to. So the final path\n    would still need to be constructed from the resulting path.\n\n    Even if the path set in the scene does not contain the `#` frame\n    tokens or an extension, this method will ensure that the returned\n    paths do and qualify as a full path with `#` as padding frame tokens.\n\n    Returns:\n        dict[str]: The full output image or sequence paths per identifier.\n\n    \"\"\"\n    # Blender 5\n    if lib.get_blender_version() &gt;= (5, 0, 0):\n        return self._get_expected_outputs_blender_5(node)\n\n    # Blender 4\n    output_paths = self._get_expected_outputs_blender_4(node)\n    is_multilayer = self.is_multilayer_exr(node)\n    outputs_per_aov = {}\n    for output_path in output_paths:\n        if is_multilayer:\n            # Only ever a single output - we enforce the identifier to an\n            # empty string to have it considered to not split into a\n            # subname for the product\n            aov_identifier = \"\"\n        else:\n            aov_identifier = self.get_aov_identifier(\n                output_path,\n                instance\n            )\n        outputs_per_aov[aov_identifier] = output_path\n    return outputs_per_aov\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.RenderColorspaceData","title":"<code>RenderColorspaceData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Colorspace data for the render instance.</p> <p>This is used to store the colorspace configuration for the render output. It includes the OCIO configuration, display, and view settings.</p> <p>Attributes:</p> Name Type Description <code>colorspaceConfig</code> <code>str</code> <p>Path to the OCIO configuration file.</p> <code>colorspaceDisplay</code> <code>str</code> <p>Display device name.</p> <code>colorspaceView</code> <code>str</code> <p>View transform name.</p> <code>colorspace</code> <code>str</code> <p>Colorspace of the output image.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_render.py</code> <pre><code>class RenderColorspaceData(TypedDict):\n    \"\"\"Colorspace data for the render instance.\n\n    This is used to store the colorspace configuration for the render output.\n    It includes the OCIO configuration, display, and view settings.\n\n    Attributes:\n        colorspaceConfig (str): Path to the OCIO configuration file.\n        colorspaceDisplay (str): Display device name.\n        colorspaceView (str): View transform name.\n        colorspace (str): Colorspace of the output image.\n    \"\"\"\n    colorspaceConfig: str\n    colorspaceDisplay: str\n    colorspaceView: str\n    colorspace: str\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_render.html#client.ayon_blender.plugins.publish.collect_render.files_as_sequence","title":"<code>files_as_sequence(files)</code>","text":"<p>Convert sequence of files to sequence pattern.</p> <p>Convert a list of files to a sequence pattern purely used for improved human-readable logging purposes.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_render.py</code> <pre><code>def files_as_sequence(files) -&gt; list[str]:\n    \"\"\"Convert sequence of files to sequence pattern.\n\n    Convert a list of files to a sequence pattern purely used for improved\n    human-readable logging purposes.\"\"\"\n    # clique.PATTERNS[\"frames\"] but also allow `_` before digits\n    pattern = r\"(?P&lt;index&gt;(?P&lt;padding&gt;0*)\\d+)\\.\\D+\\d?$\"\n    files = [os.path.basename(f) for f in files]\n    collections, remainder = clique.assemble(\n        files,\n        patterns=[pattern],\n        assume_padded_when_ambiguous=True,\n    )\n    names = [str(collection) for collection in collections]\n    names.extend(remainder)\n    return names\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_review.html","title":"collect_review","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_review.html#client.ayon_blender.plugins.publish.collect_review.CollectReview","title":"<code>CollectReview</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Collect Review data</p> Source code in <code>client/ayon_blender/plugins/publish/collect_review.py</code> <pre><code>class CollectReview(plugin.BlenderInstancePlugin):\n    \"\"\"Collect Review data\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.3\n    label = \"Collect Review Data\"\n    families = [\"review\"]\n\n    def process(self, instance):\n\n        self.log.debug(f\"instance: {instance}\")\n\n        datablock = instance.data[\"transientData\"][\"instance_node\"]\n\n        # get cameras\n        cameras = [\n            obj\n            for obj in datablock.all_objects\n            if isinstance(obj, bpy.types.Object) and obj.type == \"CAMERA\"\n        ]\n\n        assert len(cameras) == 1, (\n            f\"Not a single camera found in extraction: {cameras}\"\n        )\n        camera = cameras[0].name\n        self.log.debug(f\"camera: {camera}\")\n\n        focal_length = cameras[0].data.lens\n\n        # get isolate objects list from meshes instance members.\n        types = {\"MESH\", \"GPENCIL\"}\n        isolate_objects = [\n            obj\n            for obj in instance\n            if isinstance(obj, bpy.types.Object) and obj.type in types\n        ]\n\n        # Store focal length in `burninDataMembers`\n        burninData = instance.data.setdefault(\"burninDataMembers\", {})\n        burninData[\"focalLength\"] = focal_length\n\n        instance.data.update({\n            \"review_camera\": camera,\n            \"fps\": instance.context.data[\"fps\"],\n            \"isolate\": isolate_objects,\n        })\n\n        self.log.debug(f\"instance data: {instance.data}\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_workfile.html#client.ayon_blender.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Inject workfile data into its instance.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(plugin.BlenderInstancePlugin):\n    \"\"\"Inject workfile data into its instance.\"\"\"\n\n    order = CollectorOrder\n    label = \"Collect Workfile\"\n    hosts = [\"blender\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Process collector.\"\"\"\n\n        context = instance.context\n        filepath = context.data.get(\"currentFile\")\n        if not filepath:\n            self.log.warning(\"Deactivating workfile instance because no \"\n                             \"current filepath is found. Please save your \"\n                             \"workfile.\")\n            instance.data[\"publish\"] = False\n            return\n\n        filepath = Path(filepath)\n        ext = filepath.suffix\n\n        instance.data.update(\n            {\n                \"setMembers\": [filepath.as_posix()],\n                \"frameStart\": context.data.get(\"frameStart\", 1),\n                \"frameEnd\": context.data.get(\"frameEnd\", 1),\n                \"handleStart\": context.data.get(\"handleStart\", 1),\n                \"handledEnd\": context.data.get(\"handleEnd\", 1),\n                \"representations\": [\n                    {\n                        \"name\": ext.lstrip(\".\"),\n                        \"ext\": ext.lstrip(\".\"),\n                        \"files\": filepath.name,\n                        \"stagingDir\": filepath.parent,\n                    }\n                ],\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/collect_workfile.html#client.ayon_blender.plugins.publish.collect_workfile.CollectWorkfile.process","title":"<code>process(instance)</code>","text":"<p>Process collector.</p> Source code in <code>client/ayon_blender/plugins/publish/collect_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Process collector.\"\"\"\n\n    context = instance.context\n    filepath = context.data.get(\"currentFile\")\n    if not filepath:\n        self.log.warning(\"Deactivating workfile instance because no \"\n                         \"current filepath is found. Please save your \"\n                         \"workfile.\")\n        instance.data[\"publish\"] = False\n        return\n\n    filepath = Path(filepath)\n    ext = filepath.suffix\n\n    instance.data.update(\n        {\n            \"setMembers\": [filepath.as_posix()],\n            \"frameStart\": context.data.get(\"frameStart\", 1),\n            \"frameEnd\": context.data.get(\"frameEnd\", 1),\n            \"handleStart\": context.data.get(\"handleStart\", 1),\n            \"handledEnd\": context.data.get(\"handleEnd\", 1),\n            \"representations\": [\n                {\n                    \"name\": ext.lstrip(\".\"),\n                    \"ext\": ext.lstrip(\".\"),\n                    \"files\": filepath.name,\n                    \"stagingDir\": filepath.parent,\n                }\n            ],\n        }\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc.html","title":"extract_abc","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc.html#client.ayon_blender.plugins.publish.extract_abc.ExtractABC","title":"<code>ExtractABC</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as ABC.</p> <p>For more details on the export options, see: https://docs.blender.org/api/current/bpy.ops.wm.html#bpy.ops.wm.alembic_export   # noqa</p> Source code in <code>client/ayon_blender/plugins/publish/extract_abc.py</code> <pre><code>class ExtractABC(plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin):\n    \"\"\"Extract as ABC.\n\n    For more details on the export options, see:\n    https://docs.blender.org/api/current/bpy.ops.wm.html#bpy.ops.wm.alembic_export   # noqa\n    \"\"\"\n\n    label = \"Extract ABC\"\n    hosts = [\"blender\"]\n    families = [\"pointcache\"]\n\n    subdiv_schema: bool = False\n    evaluation_mode: str = \"RENDER\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        attr_values = self.get_attr_values_from_data(instance.data)\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.abc\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        selected = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object):\n                obj.select_set(True)\n                selected.append(obj)\n\n        context = plugin.create_blender_context(\n            active=asset_group, selected=selected)\n\n        # Supply frame range if set on instance\n        kwargs = {}\n        if \"frameStartHandle\" in instance.data:\n            kwargs[\"start\"]: int = instance.data[\"frameStartHandle\"]\n        if \"frameEndHandle\" in instance.data:\n            kwargs[\"end\"]: int = instance.data[\"frameEndHandle\"]\n\n        with bpy.context.temp_override(**context):\n            # We export the abc\n            bpy.ops.wm.alembic_export(\n                filepath=filepath,\n                selected=True,\n                flatten=False,\n                subdiv_schema=attr_values.get(\"subdiv_schema\",\n                                              self.subdiv_schema),\n                evaluation_mode=attr_values.get(\"evaluation_mode\",\n                                                self.evaluation_mode),\n                **kwargs\n            )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            BoolDef(\n                \"subdiv_schema\",\n                label=\"Alembic Mesh Subdiv Schema\",\n                tooltip=\"Export Meshes using Alembic's subdivision schema.\\n\"\n                        \"Enabling this includes creases with the export but \"\n                        \"excludes the mesh's normals.\\n\"\n                        \"Enabling this usually result in smaller file size \"\n                        \"due to lack of normals.\",\n                default=cls.subdiv_schema\n            ),\n            EnumDef(\n                \"evaluation_mode\",\n                label=\"Alembic Evaluation Mode\",\n                items=[\n                    {\"value\": \"RENDER\", \"label\": \"Render\"},\n                    {\"value\": \"VIEWPORT\", \"label\": \"Viewport\"},\n                ],\n                tooltip=(\n                    \"For Alembic export determines visibility of objects, \"\n                    \"modifier settings, and other areas\\nwhere there are \"\n                    \"different settings for viewport and rendering.\"\n                ),\n                default=cls.evaluation_mode\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc.html#client.ayon_blender.plugins.publish.extract_abc.ExtractModelABC","title":"<code>ExtractModelABC</code>","text":"<p>               Bases: <code>ExtractABC</code></p> <p>Extract model as ABC.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_abc.py</code> <pre><code>class ExtractModelABC(ExtractABC):\n    \"\"\"Extract model as ABC.\"\"\"\n\n    label = \"Extract Model ABC\"\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    optional = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc_animation.html","title":"extract_abc_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_abc_animation.html#client.ayon_blender.plugins.publish.extract_abc_animation.ExtractAnimationABC","title":"<code>ExtractAnimationABC</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as ABC.</p> <p>For more details on the export options, see: https://docs.blender.org/api/current/bpy.ops.wm.html#bpy.ops.wm.alembic_export   # noqa</p> Source code in <code>client/ayon_blender/plugins/publish/extract_abc_animation.py</code> <pre><code>class ExtractAnimationABC(\n    plugin.BlenderExtractor,\n    publish.OptionalPyblishPluginMixin,\n):\n    \"\"\"Extract as ABC.\n\n    For more details on the export options, see:\n    https://docs.blender.org/api/current/bpy.ops.wm.html#bpy.ops.wm.alembic_export   # noqa\n    \"\"\"\n\n    label = \"Extract Animation ABC\"\n    hosts = [\"blender\"]\n    families = [\"animation\"]\n    optional = True\n\n    subdiv_schema: bool = False\n    evaluation_mode: str = \"RENDER\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        attr_values = self.get_attr_values_from_data(instance.data)\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.abc\"\n\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        selected = []\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        objects = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Collection):\n                for child in obj.all_objects:\n                    objects.append(child)\n        for obj in objects:\n            children = [o for o in bpy.data.objects if o.parent == obj]\n            for child in children:\n                objects.append(child)\n\n        for obj in objects:\n            obj.select_set(True)\n            selected.append(obj)\n\n        context = plugin.create_blender_context(\n            active=asset_group, selected=selected)\n        with bpy.context.temp_override(**context):\n            # We export the abc\n            bpy.ops.wm.alembic_export(\n                filepath=filepath,\n                selected=True,\n                flatten=False,\n                start=instance.data[\"frameStartHandle\"],\n                end=instance.data[\"frameEndHandle\"],\n                subdiv_schema=attr_values.get(\"subdiv_schema\",\n                                              self.subdiv_schema),\n                evaluation_mode=attr_values.get(\"evaluation_mode\",\n                                                self.evaluation_mode),\n            )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            BoolDef(\n                \"subdiv_schema\",\n                label=\"Alembic Mesh Subdiv Schema\",\n                tooltip=\"Export Meshes using Alembic's subdivision schema.\\n\"\n                        \"Enabling this includes creases with the export but \"\n                        \"excludes the mesh's normals.\\n\"\n                        \"Enabling this usually result in smaller file size \"\n                        \"due to lack of normals.\",\n                default=cls.subdiv_schema\n            ),\n            EnumDef(\n                \"evaluation_mode\",\n                label=\"Alembic Evaluation Mode\",\n                items=[\n                    {\"value\": \"RENDER\", \"label\": \"Render\"},\n                    {\"value\": \"VIEWPORT\", \"label\": \"Viewport\"},\n                ],\n                tooltip=(\n                    \"For Alembic export determines visibility of objects, \"\n                    \"modifier settings, and other areas\\nwhere there are \"\n                    \"different settings for viewport and rendering.\"\n                ),\n                default=cls.evaluation_mode\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html","title":"extract_blend","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html#client.ayon_blender.plugins.publish.extract_blend.ExtractBlend","title":"<code>ExtractBlend</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a blend file.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend.py</code> <pre><code>class ExtractBlend(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract a blend file.\"\"\"\n\n    label = \"Extract Blend\"\n    hosts = [\"blender\"]\n    families = [\"model\", \"camera\", \"rig\", \"layout\", \"blendScene\"]\n    optional = True\n\n    # From settings\n    compress = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.blend\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        data_blocks = self.add_datablock(instance)\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n        containers = list(ls())\n        with contextlib.ExitStack() as stack:\n            # If the instance node is a Collection, we want to enforce the\n            # full child hierarchies to be included in the written collections.\n            instance_node = instance.data[\"transientData\"][\"instance_node\"]\n            if isinstance(instance_node, bpy.types.Collection):\n                # We only link children nodes to the 'parent' collection it is\n                # in so that the full children hierarchy is preserved for the\n                # main collection, and all its child collections.\n                collections = [instance_node]\n                collections.extend(instance_node.children_recursive)\n                for collection in set(collections):\n                    missing_child_hierarchy = set()\n                    for obj in collection.objects:\n                        for child in obj.children_recursive:\n                            if collection not in child.users_collection:\n                                missing_child_hierarchy.add(child)\n\n                    if missing_child_hierarchy:\n                        stack.enter_context(link_to_collection(\n                            collection, list(missing_child_hierarchy)))\n\n            stack.enter_context(strip_container_data(containers))\n            stack.enter_context(strip_instance_data(asset_group))\n            stack.enter_context(strip_namespace(containers))\n            stack.enter_context(packed_images(data_blocks, logger=self.log))\n            self.log.debug(\"Datablocks: %s\", data_blocks)\n            bpy.data.libraries.write(\n                filepath, data_blocks, compress=self.compress\n            )\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'blend',\n            'ext': 'blend',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n\n    def add_datablock(self, instance: pyblish.api.Instance) -&gt; set:\n        \"\"\"Add a data block to the blend file.\n\n        Args:\n            instance (pyblish.api.Instance): The instance to add.\n\n        Returns:\n            set: A set of data blocks added.\n        \"\"\"\n        return set(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html#client.ayon_blender.plugins.publish.extract_blend.ExtractBlend.add_datablock","title":"<code>add_datablock(instance)</code>","text":"<p>Add a data block to the blend file.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The instance to add.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of data blocks added.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend.py</code> <pre><code>def add_datablock(self, instance: pyblish.api.Instance) -&gt; set:\n    \"\"\"Add a data block to the blend file.\n\n    Args:\n        instance (pyblish.api.Instance): The instance to add.\n\n    Returns:\n        set: A set of data blocks added.\n    \"\"\"\n    return set(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html#client.ayon_blender.plugins.publish.extract_blend.ExtractBlendAction","title":"<code>ExtractBlendAction</code>","text":"<p>               Bases: <code>ExtractBlend</code></p> <p>Extract a blend file from the current scene.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend.py</code> <pre><code>class ExtractBlendAction(ExtractBlend):\n    \"\"\"Extract a blend file from the current scene.\n    \"\"\"\n    families = [\"action\"]\n    label = \"Extract Blend (Action)\"\n    optional = False\n    # From settings\n    compress = False\n\n    def add_datablock(self, instance: pyblish.api.Instance) -&gt; set:\n        \"\"\"Add a data block to the blend file.\n\n        Args:\n            instance (pyblish.api.Instance): The instance to add.\n\n        Returns:\n            set: A set of data blocks added.\n        \"\"\"\n        return {\n            action for action in bpy.data.actions\n            if action.name == instance.data[\"productName\"]\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html#client.ayon_blender.plugins.publish.extract_blend.ExtractBlendAction.add_datablock","title":"<code>add_datablock(instance)</code>","text":"<p>Add a data block to the blend file.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The instance to add.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of data blocks added.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend.py</code> <pre><code>def add_datablock(self, instance: pyblish.api.Instance) -&gt; set:\n    \"\"\"Add a data block to the blend file.\n\n    Args:\n        instance (pyblish.api.Instance): The instance to add.\n\n    Returns:\n        set: A set of data blocks added.\n    \"\"\"\n    return {\n        action for action in bpy.data.actions\n        if action.name == instance.data[\"productName\"]\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend.html#client.ayon_blender.plugins.publish.extract_blend.link_to_collection","title":"<code>link_to_collection(collection, objects)</code>","text":"<p>Link objects to a collection during context</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend.py</code> <pre><code>@contextlib.contextmanager\ndef link_to_collection(collection, objects):\n    \"\"\"Link objects to a collection during context\"\"\"\n    unlink_after = []\n    try:\n        for obj in objects:\n            if not isinstance(obj, bpy.types.Object):\n                continue\n            if collection not in obj.users_collection:\n                unlink_after.append(obj)\n                collection.objects.link(obj)\n        yield\n    finally:\n        for obj in unlink_after:\n            collection.objects.unlink(obj)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend_animation.html","title":"extract_blend_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_blend_animation.html#client.ayon_blender.plugins.publish.extract_blend_animation.ExtractBlendAnimation","title":"<code>ExtractBlendAnimation</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a blend file.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_blend_animation.py</code> <pre><code>class ExtractBlendAnimation(\n    plugin.BlenderExtractor,\n    publish.OptionalPyblishPluginMixin,\n):\n    \"\"\"Extract a blend file.\"\"\"\n\n    label = \"Extract Blend\"\n    hosts = [\"blender\"]\n    families = [\"animation\"]\n    optional = True\n\n    # From settings\n    compress = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.blend\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        data_blocks = set()\n\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == 'EMPTY':\n                child = obj.children[0]\n                if child and child.type == 'ARMATURE':\n                    if child.animation_data and child.animation_data.action:\n                        if not obj.animation_data:\n                            obj.animation_data_create()\n                        obj.animation_data.action = child.animation_data.action\n                        obj.animation_data_clear()\n                        data_blocks.add(child.animation_data.action)\n            if not (\n                isinstance(obj, bpy.types.Object) and obj.type in {'MESH', 'EMPTY', 'ARMATURE'}\n            ):\n                continue\n\n            data_blocks.add(obj)\n\n        containers = list(ls())\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n        with contextlib.ExitStack() as stack:\n            stack.enter_context(strip_container_data(containers))\n            stack.enter_context(strip_instance_data(asset_group))\n            self.log.debug(f\"Data blocks to be written: {data_blocks}\")\n            bpy.data.libraries.write(filepath, data_blocks, compress=self.compress)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'blend',\n            'ext': 'blend',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_abc.html","title":"extract_camera_abc","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_abc.html#client.ayon_blender.plugins.publish.extract_camera_abc.ExtractCameraABC","title":"<code>ExtractCameraABC</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract camera as ABC.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_camera_abc.py</code> <pre><code>class ExtractCameraABC(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract camera as ABC.\"\"\"\n\n    label = \"Extract Camera (ABC)\"\n    hosts = [\"blender\"]\n    families = [\"camera\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.abc\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        instance_node = instance.data[\"transientData\"][\"instance_node\"]\n        if isinstance(instance_node, bpy.types.Collection):\n            members = list(instance)\n            active = lib.get_highest_root(members)\n            selected = members\n        elif isinstance(instance_node, bpy.types.Object):\n            # Legacy behavior where camera instances were asset groups\n            asset_group = instance_node\n            # Need to cast to list because children is a tuple\n            selected = list(asset_group.children)\n            active = selected[0]\n        else:\n            raise TypeError(\n                \"Instance node is of wrong type, expecting object or \"\n                f\"collection but got: {instance_node}\"\n            )\n\n        for obj in selected:\n            if isinstance(obj, bpy.types.Object):\n                obj.select_set(True)\n\n        context = plugin.create_blender_context(\n            active=active, selected=selected)\n\n        scene_overrides = {\n            \"unit_settings.scale_length\": instance.data.get(\"unitScale\"),\n        }\n        # Skip None value overrides\n        scene_overrides = {\n            key: value for key, value in scene_overrides.items()\n            if value is not None\n        }\n\n        with lib.attribute_overrides(bpy.context.scene, scene_overrides):\n            with bpy.context.temp_override(**context):\n                # We export the abc\n                bpy.ops.wm.alembic_export(\n                    filepath=filepath,\n                    selected=True,\n                    flatten=True,\n                    start=instance.data[\"frameStartHandle\"],\n                    end=instance.data[\"frameEndHandle\"]\n                )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'abc',\n            'ext': 'abc',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_fbx.html","title":"extract_camera_fbx","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_camera_fbx.html#client.ayon_blender.plugins.publish.extract_camera_fbx.ExtractCamera","title":"<code>ExtractCamera</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as the camera as FBX.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_camera_fbx.py</code> <pre><code>class ExtractCamera(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract as the camera as FBX.\"\"\"\n\n    label = \"Extract Camera (FBX)\"\n    hosts = [\"blender\"]\n    families = [\"camera\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.fbx\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        selected = []\n\n        camera = None\n\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == \"CAMERA\":\n                obj.select_set(True)\n                selected.append(obj)\n                camera = obj\n                break\n\n        assert camera, \"No camera found\"\n\n        context = plugin.create_blender_context(\n            active=camera, selected=selected)\n\n        scene_overrides = {\n            \"frame_start\": instance.data.get(\"frameStart\"),\n            \"frame_end\": instance.data.get(\"frameEnd\"),\n            \"frame_step\": instance.data.get(\"frameStep\"),\n            \"render.fps\": instance.data.get(\"fps\")\n        }\n        # Skip None value overrides\n        scene_overrides = {\n            key: value for key, value in scene_overrides.items()\n            if value is not None\n        }\n        if \"render.fps\" in scene_overrides:\n            scene_overrides[\"render.fps_base\"] = 1\n\n        with lib.attribute_overrides(bpy.context.scene, scene_overrides):\n            with bpy.context.temp_override(**context):\n                # We export the fbx\n                bpy.ops.export_scene.fbx(\n                    filepath=filepath,\n                    use_active_collection=False,\n                    use_selection=True,\n                    bake_anim_use_nla_strips=False,\n                    bake_anim_use_all_actions=False,\n                    add_leaf_bones=False,\n                    armature_nodetype='ROOT',\n                    object_types={'CAMERA'},\n                    bake_anim_simplify_factor=0.0\n                )\n\n        plugin.deselect_all()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx.html","title":"extract_fbx","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx.html#client.ayon_blender.plugins.publish.extract_fbx.ExtractFBX","title":"<code>ExtractFBX</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as FBX.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_fbx.py</code> <pre><code>class ExtractFBX(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract as FBX.\"\"\"\n\n    label = \"Extract FBX\"\n    hosts = [\"blender\"]\n    families = [\"model\", \"rig\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        filename = f\"{instance_name}.fbx\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        plugin.deselect_all()\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        selected = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object):\n                obj.select_set(True)\n                selected.append(obj)\n\n        context = plugin.create_blender_context(\n            active=asset_group, selected=selected)\n\n        new_materials = []\n        new_materials_objs = []\n        objects = list(asset_group.children)\n\n        for obj in objects:\n            objects.extend(obj.children)\n            if obj.type == 'MESH' and len(obj.data.materials) == 0:\n                mat = bpy.data.materials.new(obj.name)\n                obj.data.materials.append(mat)\n                new_materials.append(mat)\n                new_materials_objs.append(obj)\n\n        with bpy.context.temp_override(**context):\n            # We export the fbx\n            bpy.ops.export_scene.fbx(\n                filepath=filepath,\n                use_active_collection=False,\n                use_selection=True,\n                mesh_smooth_type='FACE',\n                add_leaf_bones=False\n            )\n\n        plugin.deselect_all()\n\n        for mat in new_materials:\n            bpy.data.materials.remove(mat)\n\n        for obj in new_materials_objs:\n            obj.data.materials.pop()\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx_animation.html","title":"extract_fbx_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx_animation.html#client.ayon_blender.plugins.publish.extract_fbx_animation.ExtractAnimationFBX","title":"<code>ExtractAnimationFBX</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as animation.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_fbx_animation.py</code> <pre><code>class ExtractAnimationFBX(\n    plugin.BlenderExtractor,\n    publish.OptionalPyblishPluginMixin,\n):\n    \"\"\"Extract as animation.\"\"\"\n\n    label = \"Extract FBX\"\n    hosts = [\"blender\"]\n    families = [\"animation\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        # Get objects in this collection (but not in children collections)\n        # and for those objects include the children hierarchy\n        # TODO: Would it make more sense for the Collect Instance collector\n        #   to also always retrieve all the children?\n        objects = set(asset_group.objects)\n\n        # From the direct children of the collection find the 'root' node\n        # that we want to export - it is the 'highest' node in a hierarchy\n        root = get_highest_root(objects)\n\n        for obj in list(objects):\n            objects.update(obj.children_recursive)\n\n        # Find all armatures among the objects, assume to find only one\n        armatures = [obj for obj in objects if obj.type == \"ARMATURE\"]\n        if not armatures:\n            raise RuntimeError(\n                f\"Unable to find ARMATURE in collection: \"\n                f\"{asset_group.name}\"\n            )\n        elif len(armatures) &gt; 1:\n            self.log.warning(\n                \"Found more than one ARMATURE, using \"\n                f\"only first of: {armatures}\"\n            )\n        armature = armatures[0]\n\n        object_action_pairs = []\n        original_actions = []\n\n        starting_frames = []\n        ending_frames = []\n\n        # For each armature, we make a copy of the current action\n        if armature.animation_data and armature.animation_data.action:\n            curr_action = armature.animation_data.action\n            copy_action = curr_action.copy()\n\n            curr_frame_range = curr_action.frame_range\n\n            starting_frames.append(curr_frame_range[0])\n            ending_frames.append(curr_frame_range[1])\n        else:\n            self.log.info(\n                f\"Armature '{armature.name}' has no animation, \"\n                f\"skipping FBX animation extraction for {instance}.\"\n            )\n            return\n\n        asset_group_name = asset_group.name\n        asset_name = asset_group.get(AYON_PROPERTY).get(\"asset_name\")\n        if asset_name:\n            # Rename for the export; this data is only present when loaded\n            # from a JSON Layout (layout family)\n            asset_group.name = asset_name\n\n        # Remove : from the armature name for the export\n        armature_name = armature.name\n        original_name = armature_name.rsplit(':', 1)[-1]\n        armature.name = original_name\n\n        object_action_pairs.append((armature, copy_action))\n        original_actions.append(curr_action)\n\n        # We compute the starting and ending frames\n        max_frame = min(starting_frames)\n        min_frame = max(ending_frames)\n\n        blender_version = get_blender_version()\n        if blender_version &gt;= (4, 1, 0):\n            # We bake the copy of the current action for each object\n            bake_options = bpy_extras.anim_utils.BakeOptions(\n                only_selected=False,\n                do_pose=True,\n                do_object=False,\n                do_visual_keying=True,\n                do_constraint_clear=False,\n                do_parents_clear=False,\n                do_clean=False,\n                do_location=True,\n                do_rotation=True,\n                do_scale=True,\n                do_bbone=True,\n                do_custom_props=True\n            )\n            bpy_extras.anim_utils.bake_action_objects(\n                object_action_pairs,\n                frames=range(int(min_frame), int(max_frame)),\n                bake_options=bake_options\n            )\n        else:\n            bpy_extras.anim_utils.bake_action_objects(\n                object_action_pairs,\n                frames=range(int(min_frame), int(max_frame)),\n                do_object=False,\n                do_clean=False\n            )\n\n        for obj in bpy.data.objects:\n            obj.select_set(False)\n\n        root.select_set(True)\n        armature.select_set(True)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        fbx_filename = f\"{instance_name}_{armature.name}.fbx\"\n        filepath = os.path.join(stagingdir, fbx_filename)\n\n        override = plugin.create_blender_context(\n            active=root, selected=[root, armature])\n\n        with bpy.context.temp_override(**override):\n            # We export the fbx\n            bpy.ops.export_scene.fbx(\n                filepath=filepath,\n                use_active_collection=False,\n                use_selection=True,\n                bake_anim_use_nla_strips=False,\n                bake_anim_use_all_actions=False,\n                add_leaf_bones=False,\n                armature_nodetype='ROOT',\n                object_types={'EMPTY', 'ARMATURE'}\n            )\n\n        armature.name = armature_name\n        asset_group.name = asset_group_name\n        root.select_set(True)\n        armature.select_set(False)\n\n        # We delete the baked action and set the original one back\n        for i in range(0, len(object_action_pairs)):\n            pair = object_action_pairs[i]\n            action = original_actions[i]\n\n            if action:\n                pair[0].animation_data.action = action\n\n            if pair[1]:\n                pair[1].user_clear()\n                bpy.data.actions.remove(pair[1])\n\n        json_filename = f\"{instance_name}.json\"\n        json_path = os.path.join(stagingdir, json_filename)\n\n        json_dict = {\n            \"instance_name\": asset_group.get(AYON_PROPERTY).get(\"objectName\")\n        }\n\n        # collection = instance.data.get(\"name\")\n        # container = None\n        # for obj in bpy.data.collections[collection].objects:\n        #     if obj.type == \"ARMATURE\":\n        #         container_name = obj.get(\"ayon\").get(\"container_name\")\n        #         container = bpy.data.collections[container_name]\n        # if container:\n        #     json_dict = {\n        #         \"instance_name\": container.get(\"ayon\").get(\"instance_name\")\n        #     }\n\n        with open(json_path, \"w+\") as file:\n            json.dump(json_dict, fp=file, indent=2)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        fbx_representation = {\n            'name': 'fbx',\n            'ext': 'fbx',\n            'files': fbx_filename,\n            \"stagingDir\": stagingdir,\n        }\n        json_representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(fbx_representation)\n        instance.data[\"representations\"].append(json_representation)\n\n        self.log.debug(\"Extracted instance '{}' to: {}\".format(\n                       instance.name, fbx_representation))\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_fbx_animation.html#client.ayon_blender.plugins.publish.extract_fbx_animation.get_all_parents","title":"<code>get_all_parents(obj)</code>","text":"<p>Get all recursive parents of object</p> Source code in <code>client/ayon_blender/plugins/publish/extract_fbx_animation.py</code> <pre><code>def get_all_parents(obj):\n    \"\"\"Get all recursive parents of object\"\"\"\n    result = []\n    while True:\n        obj = obj.parent\n        if not obj:\n            break\n        result.append(obj)\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_layout.html","title":"extract_layout","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_layout.html#client.ayon_blender.plugins.publish.extract_layout.ExtractLayout","title":"<code>ExtractLayout</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract a layout.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_layout.py</code> <pre><code>class ExtractLayout(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"Extract a layout.\"\"\"\n\n    label = \"Extract Layout (JSON)\"\n    hosts = [\"blender\"]\n    families = [\"layout\"]\n    optional = True\n\n    def _export_animation(self, asset, instance, stagingdir, fbx_count):\n        n = fbx_count\n\n        for obj in asset.children:\n            if obj.type != \"ARMATURE\":\n                continue\n\n            object_action_pairs = []\n            original_actions = []\n\n            starting_frames = []\n            ending_frames = []\n\n            # For each armature, we make a copy of the current action\n            curr_action = None\n            copy_action = None\n\n            if obj.animation_data and obj.animation_data.action:\n                curr_action = obj.animation_data.action\n                copy_action = curr_action.copy()\n\n                curr_frame_range = curr_action.frame_range\n\n                starting_frames.append(curr_frame_range[0])\n                ending_frames.append(curr_frame_range[1])\n            else:\n                self.log.info(\"Object has no animation.\")\n                continue\n\n            asset_group_name = asset.name\n            asset.name = asset.get(AYON_PROPERTY).get(\"asset_name\")\n\n            # Remove : from the armature name for the export\n            armature_name = obj.name\n            original_name = armature_name.rsplit(\":\", 1)[-1]\n            obj.name = original_name\n\n            object_action_pairs.append((obj, copy_action))\n            original_actions.append(curr_action)\n\n            # We compute the starting and ending frames\n            max_frame = min(starting_frames)\n            min_frame = max(ending_frames)\n\n            # We bake the copy of the current action for each object\n            bpy_extras.anim_utils.bake_action_objects(\n                object_action_pairs,\n                frames=range(int(min_frame), int(max_frame)),\n                do_object=False,\n                do_clean=False\n            )\n\n            for o in bpy.data.objects:\n                o.select_set(False)\n\n            asset.select_set(True)\n            obj.select_set(True)\n            fbx_filename = f\"{n:03d}.fbx\"\n            filepath = os.path.join(stagingdir, fbx_filename)\n\n            override = plugin.create_blender_context(\n                active=asset, selected=[asset, obj])\n            with bpy.context.temp_override(**override):\n                # We export the fbx\n                bpy.ops.export_scene.fbx(\n                    filepath=filepath,\n                    use_active_collection=False,\n                    use_selection=True,\n                    bake_anim_use_nla_strips=False,\n                    bake_anim_use_all_actions=False,\n                    add_leaf_bones=False,\n                    armature_nodetype='ROOT',\n                    object_types={'EMPTY', 'ARMATURE'}\n                )\n            obj.name = armature_name\n            asset.name = asset_group_name\n            asset.select_set(False)\n            obj.select_set(False)\n\n            # We delete the baked action and set the original one back\n            for i in range(0, len(object_action_pairs)):\n                pair = object_action_pairs[i]\n                action = original_actions[i]\n\n                if action:\n                    pair[0].animation_data.action = action\n\n                if pair[1]:\n                    pair[1].user_clear()\n                    bpy.data.actions.remove(pair[1])\n\n            return fbx_filename, n + 1\n\n        return None, n\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        json_data = []\n        fbx_files = []\n\n        asset_group = instance.data[\"transientData\"][\"instance_node\"]\n\n        fbx_count = 0\n\n        project_name = instance.context.data[\"projectName\"]\n        version_ids = set()\n        filtered_assets = []\n        for asset in asset_group.children:\n            metadata = asset.get(AYON_PROPERTY)\n            if not metadata:\n                # Avoid raising error directly if there's just invalid data\n                # inside the instance; better to log it to the artist\n                # TODO: This should actually be validated in a validator\n                self.log.warning(\n                    f\"Found content in layout that is not a loaded \"\n                    f\"asset, skipping: {asset.name_full}\"\n                )\n                continue\n\n            filtered_assets.append((asset, metadata))\n            version_ids.add(metadata[\"parent\"])\n\n        repre_entities = get_representations(\n            project_name,\n            representation_names={\"blend\", \"fbx\", \"abc\"},\n            version_ids=version_ids,\n            fields={\"id\", \"versionId\", \"name\"}\n        )\n        repre_mapping_by_version_id = {\n            version_id: {}\n            for version_id in version_ids\n        }\n        for repre_entity in repre_entities:\n            version_id = repre_entity[\"versionId\"]\n            repre_mapping_by_version_id[version_id][repre_entity[\"name\"]] = (\n                repre_entity\n            )\n\n        for asset, metadata in filtered_assets:\n            version_id = metadata[\"parent\"]\n            product_type = metadata.get(\"product_type\")\n            if product_type is None:\n                product_type = metadata[\"family\"]\n\n            repres_by_name = repre_mapping_by_version_id[version_id]\n\n            self.log.debug(\"Parent: {}\".format(version_id))\n            # Get blend, fbx and abc reference\n            blend_id = repres_by_name.get(\"blend\", {}).get(\"id\")\n            fbx_id = repres_by_name.get(\"fbx\", {}).get(\"id\")\n            abc_id = repres_by_name.get(\"abc\", {}).get(\"id\")\n            json_element = {\n                key: value\n                for key, value in (\n                    (\"reference\", blend_id),\n                    (\"reference_fbx\", fbx_id),\n                    (\"reference_abc\", abc_id),\n                )\n                if value\n            }\n            json_element[\"product_type\"] = product_type\n            json_element[\"instance_name\"] = asset.name\n            json_element[\"asset_name\"] = metadata[\"asset_name\"]\n            json_element[\"file_path\"] = metadata[\"libpath\"]\n\n            json_element[\"transform\"] = {\n                \"translation\": {\n                    \"x\": asset.location.x,\n                    \"y\": asset.location.y,\n                    \"z\": asset.location.z\n                },\n                \"rotation\": {\n                    \"x\": asset.rotation_euler.x,\n                    \"y\": asset.rotation_euler.y,\n                    \"z\": asset.rotation_euler.z\n                },\n                \"scale\": {\n                    \"x\": asset.scale.x,\n                    \"y\": asset.scale.y,\n                    \"z\": asset.scale.z\n                }\n            }\n\n            json_element[\"transform_matrix\"] = []\n\n            for row in list(asset.matrix_world.transposed()):\n                json_element[\"transform_matrix\"].append(list(row))\n\n            json_element[\"basis\"] = [\n                [1, 0, 0, 0],\n                [0, -1, 0, 0],\n                [0, 0, 1, 0],\n                [0, 0, 0, 1]\n            ]\n\n            # Extract the animation as well\n            if product_type == \"rig\":\n                f, n = self._export_animation(\n                    asset, instance, stagingdir, fbx_count)\n                if f:\n                    fbx_files.append(f)\n                    json_element[\"animation\"] = f\n                    fbx_count = n\n\n            json_data.append(json_element)\n\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        instance_name = f\"{folder_name}_{product_name}\"\n        json_filename = f\"{instance_name}.json\"\n\n        json_path = os.path.join(stagingdir, json_filename)\n\n        with open(json_path, \"w+\") as file:\n            json.dump(json_data, fp=file, indent=2)\n\n        json_representation = {\n            'name': 'json',\n            'ext': 'json',\n            'files': json_filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(json_representation)\n\n        self.log.debug(fbx_files)\n\n        if len(fbx_files) == 1:\n            fbx_representation = {\n                'name': 'fbx',\n                'ext': '000.fbx',\n                'files': fbx_files[0],\n                \"stagingDir\": stagingdir,\n            }\n            instance.data[\"representations\"].append(fbx_representation)\n        elif len(fbx_files) &gt; 1:\n            fbx_representation = {\n                'name': 'fbx',\n                'ext': 'fbx',\n                'files': fbx_files,\n                \"stagingDir\": stagingdir,\n            }\n            instance.data[\"representations\"].append(fbx_representation)\n\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, json_representation)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_playblast.html","title":"extract_playblast","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_playblast.html#client.ayon_blender.plugins.publish.extract_playblast.ExtractPlayblast","title":"<code>ExtractPlayblast</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract viewport playblast.</p> <p>Takes review camera and creates review Quicktime video based on viewport capture.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_playblast.py</code> <pre><code>class ExtractPlayblast(\n    plugin.BlenderExtractor, publish.OptionalPyblishPluginMixin\n):\n    \"\"\"\n    Extract viewport playblast.\n\n    Takes review camera and creates review Quicktime video based on viewport\n    capture.\n    \"\"\"\n\n    label = \"Extract Playblast\"\n    hosts = [\"blender\"]\n    families = [\"review.playblast\"]\n    optional = True\n    order = pyblish.api.ExtractorOrder + 0.01\n\n    presets = \"{}\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # get scene fps\n        fps = instance.data.get(\"fps\")\n        if fps is None:\n            fps = bpy.context.scene.render.fps\n            instance.data[\"fps\"] = fps\n\n        self.log.debug(f\"fps: {fps}\")\n\n        # If start and end frames cannot be determined,\n        # get them from Blender timeline.\n        start = instance.data.get(\"frameStart\", bpy.context.scene.frame_start)\n        end = instance.data.get(\"frameEnd\", bpy.context.scene.frame_end)\n\n        self.log.debug(f\"start: {start}, end: {end}\")\n        assert end &gt;= start, \"Invalid time range!\"\n\n        # get cameras\n        camera = instance.data(\"review_camera\", None)\n\n        # get isolate objects list\n        isolate = instance.data(\"isolate\", None)\n\n        # get output path\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        filename = f\"{folder_name}_{product_name}\"\n\n        path = os.path.join(stagingdir, filename)\n\n        self.log.debug(f\"Outputting images to {path}\")\n\n        presets = json.loads(self.presets)\n        preset = presets.get(\"default\")\n        preset.update({\n            \"camera\": camera,\n            \"start_frame\": start,\n            \"end_frame\": end,\n            \"filename\": path,\n            \"overwrite\": True,\n            \"isolate\": isolate,\n        })\n        preset.setdefault(\n            \"image_settings\",\n            {\n                \"file_format\": \"PNG\",\n                \"color_mode\": \"RGB\",\n                \"color_depth\": \"8\",\n                \"compression\": 15,\n            },\n        )\n\n        with maintained_time():\n            path = capture(**preset)\n\n        self.log.debug(f\"playblast path {path}\")\n        self._maintain_publisher_focus()\n\n        collected_files = os.listdir(stagingdir)\n        collections, remainder = clique.assemble(\n            collected_files,\n            patterns=[f\"{filename}\\\\.{clique.DIGITS_PATTERN}\\\\.png$\"],\n            minimum_items=1\n        )\n\n        if len(collections) &gt; 1:\n            raise RuntimeError(\n                f\"More than one collection found in stagingdir: {stagingdir}\"\n            )\n        elif len(collections) == 0:\n            raise RuntimeError(\n                f\"No collection found in stagingdir: {stagingdir}\"\n            )\n\n        frame_collection = collections[0]\n\n        self.log.debug(f\"Found collection of interest {frame_collection}\")\n\n        # `instance.data[\"files\"]` must be `str` if single frame\n        files = list(frame_collection)\n        if len(files) == 1:\n            files = files[0]\n\n        tags = [\"review\"]\n        if not instance.data.get(\"keepImages\"):\n            tags.append(\"delete\")\n\n        representation = {\n            \"name\": \"png\",\n            \"ext\": \"png\",\n            \"files\": files,\n            \"stagingDir\": stagingdir,\n            \"frameStart\": start,\n            \"frameEnd\": end,\n            \"fps\": fps,\n            \"tags\": tags,\n            \"camera_name\": camera\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n\n    def _maintain_publisher_focus(self):\n        \"\"\"Restore publisher at the top widget by using bpy.app.timers.\"\"\"\n        def delayed_publisher_restore():\n            \"\"\"Delayed call to bring publisher window back to front.\"\"\"\n            # Double-check availability before calling\n            if not hasattr(bpy.ops.wm, 'ayon_publisher'):\n                return\n            bpy.ops.wm.ayon_publisher()\n\n        self.log.debug(\"Publisher focus restoration setup completed\")\n        bpy.app.timers.register(\n            delayed_publisher_restore,\n            first_interval=0.1\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_render.html","title":"extract_render","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_render.html#client.ayon_blender.plugins.publish.extract_render.ExtractLocalRender","title":"<code>ExtractLocalRender</code>","text":"<p>               Bases: <code>BlenderExtractor</code></p> <p>Render the sequence locally during publish when not using farm.</p> <p>This extractor renders the current scene's animation to the file output paths collected on the render instance. It only runs when the instance is not marked for farm processing (farm=False).</p> Source code in <code>client/ayon_blender/plugins/publish/extract_render.py</code> <pre><code>class ExtractLocalRender(\n    plugin.BlenderExtractor\n):\n    \"\"\"Render the sequence locally during publish when not using farm.\n\n    This extractor renders the current scene's animation to the file output\n    paths collected on the render instance. It only runs when the instance\n    is not marked for farm processing (farm=False).\n    \"\"\"\n\n    label = \"Extract Local Render\"\n    hosts = [\"blender\"]\n    families = [\"render\"]\n    # Run after scene save but before other extractors\n    order = pyblish.api.ExtractorOrder - 0.4\n\n    def process(self, instance):\n        # Skip if explicitly marked for farm\n        if instance.data.get(\"farm\"):\n            self.log.debug(\"Instance marked for farm, skipping local render.\")\n            return\n\n        if instance.data.get(\"creator_attributes\", {}).get(\n            \"render_target\"\n        ) != \"local\":\n            self.log.debug(\n                \"Instance render target is not local, skipping local render.\"\n            )\n            return\n\n        frame_start: int = instance.data[\"frameStartHandle\"]\n        frame_end: int = instance.data[\"frameEndHandle\"]\n        step: int = int(instance.data.get(\"step\", 1))\n\n        # Ensure overwrite to avoid stopping on existing files\n        bpy.context.scene.render.use_overwrite = True\n\n        self.log.info(\"Rendering animation locally...\")\n        with render_range(frame_start, frame_end, step=step):\n            bpy.ops.render.render(\n                animation=True,\n                write_still=False,\n                # TODO: These arguments are only supported in Blender 5.0+\n                #  so once we drop older releases we can potentially avoid\n                #  the render range context manager\n                # frame_start=frame_start,\n                # frame_end=frame_end,\n            )\n        self.log.info(\"Local render finished.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_render.html#client.ayon_blender.plugins.publish.extract_render.render_range","title":"<code>render_range(frame_start, frame_end, step=1)</code>","text":"<p>Context manager to temporarily set render frame range.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_render.py</code> <pre><code>@contextlib.contextmanager\ndef render_range(frame_start, frame_end, step=1):\n    \"\"\"Context manager to temporarily set render frame range.\"\"\"\n    scene = bpy.context.scene\n    original_start = scene.frame_start\n    original_end = scene.frame_end\n    original_step = scene.frame_step\n    try:\n        scene.frame_start = frame_start\n        scene.frame_end = frame_end\n        scene.frame_step = step\n        yield\n    finally:\n        scene.frame_start = original_start\n        scene.frame_end = original_end\n        scene.frame_step = original_step\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_thumbnail.html","title":"extract_thumbnail","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_thumbnail.html#client.ayon_blender.plugins.publish.extract_thumbnail.ExtractThumbnail","title":"<code>ExtractThumbnail</code>","text":"<p>               Bases: <code>BlenderExtractor</code></p> <p>Extract viewport thumbnail.</p> <p>Takes review camera and creates a thumbnail based on viewport capture.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_thumbnail.py</code> <pre><code>class ExtractThumbnail(plugin.BlenderExtractor):\n    \"\"\"Extract viewport thumbnail.\n\n    Takes review camera and creates a thumbnail based on viewport\n    capture.\n\n    \"\"\"\n\n    label = \"Extract Thumbnail\"\n    hosts = [\"blender\"]\n    families = [\"review.playblast\"]\n    order = pyblish.api.ExtractorOrder + 0.01\n    presets = \"{}\"\n\n    def process(self, instance):\n        self.log.debug(\"Extracting capture..\")\n\n        if instance.data.get(\"thumbnailSource\"):\n            self.log.debug(\"Thumbnail source found, skipping...\")\n            return\n\n        stagingdir = self.staging_dir(instance)\n        folder_name = instance.data[\"folderEntity\"][\"name\"]\n        product_name = instance.data[\"productName\"]\n        filename = f\"{folder_name}_{product_name}\"\n\n        path = os.path.join(stagingdir, filename)\n\n        self.log.debug(f\"Outputting images to {path}\")\n\n        camera = instance.data.get(\"review_camera\", \"AUTO\")\n        start = instance.data.get(\"frameStart\", bpy.context.scene.frame_start)\n        product_type = instance.data[\"productType\"]\n        isolate = instance.data(\"isolate\", None)\n\n        presets = json.loads(self.presets)\n        preset = presets.get(product_type, {})\n\n        preset.update({\n            \"camera\": camera,\n            \"start_frame\": start,\n            \"end_frame\": start,\n            \"filename\": path,\n            \"overwrite\": True,\n            \"isolate\": isolate,\n        })\n        preset.setdefault(\n            \"image_settings\",\n            {\n                \"file_format\": \"JPEG\",\n                \"color_mode\": \"RGB\",\n                \"quality\": 100,\n            },\n        )\n\n        with maintained_time():\n            path = capture(**preset)\n\n        thumbnail = os.path.basename(self._fix_output_path(path))\n\n        self.log.debug(f\"thumbnail: {thumbnail}\")\n\n        instance.data.setdefault(\"representations\", [])\n\n        representation = {\n            \"name\": \"thumbnail\",\n            \"ext\": \"jpg\",\n            \"files\": thumbnail,\n            \"stagingDir\": stagingdir,\n            \"thumbnail\": True\n        }\n        instance.data[\"representations\"].append(representation)\n\n    def _fix_output_path(self, filepath):\n        \"\"\"Workaround to return correct filepath.\n\n        To workaround this we just glob.glob() for any file extensions and\n        assume the latest modified file is the correct file and return it.\n\n        \"\"\"\n        # Catch cancelled playblast\n        if filepath is None:\n            self.log.warning(\n                \"Playblast did not result in output path. \"\n                \"Playblast is probably interrupted.\"\n            )\n            return None\n\n        if not os.path.exists(filepath):\n            files = glob.glob(f\"{filepath}.*.jpg\")\n\n            if not files:\n                raise RuntimeError(f\"Couldn't find playblast from: {filepath}\")\n            filepath = max(files, key=os.path.getmtime)\n\n        return filepath\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_usd.html","title":"extract_usd","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_usd.html#client.ayon_blender.plugins.publish.extract_usd.ExtractModelUSD","title":"<code>ExtractModelUSD</code>","text":"<p>               Bases: <code>ExtractUSD</code></p> <p>Extract model as USD.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_usd.py</code> <pre><code>class ExtractModelUSD(ExtractUSD):\n    \"\"\"Extract model as USD.\"\"\"\n\n    label = \"Extract USD (Model)\"\n    hosts = [\"blender\"]\n    families = [\"model\"]\n\n    # Driven by settings\n    optional = True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_usd.html#client.ayon_blender.plugins.publish.extract_usd.ExtractUSD","title":"<code>ExtractUSD</code>","text":"<p>               Bases: <code>BlenderExtractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract as USD.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_usd.py</code> <pre><code>class ExtractUSD(plugin.BlenderExtractor,\n                 OptionalPyblishPluginMixin):\n    \"\"\"Extract as USD.\"\"\"\n\n    label = \"Extract USD\"\n    hosts = [\"blender\"]\n    families = [\"usd\"]\n\n    convert_orientation = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # Ignore runtime instances (e.g. USD layers)\n        # TODO: This is better done via more specific `families`\n        if not instance.data.get(\"transientData\", {}).get(\"instance_node\"):\n            return\n\n        # Define extract output file path\n        stagingdir = self.staging_dir(instance)\n        filename = f\"{instance.name}.usd\"\n        filepath = os.path.join(stagingdir, filename)\n\n        # Perform extraction\n        self.log.debug(\"Performing extraction..\")\n\n        # Select all members to \"export selected\"\n        plugin.deselect_all()\n\n        selected = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object):\n                obj.select_set(True)\n                selected.append(obj)\n\n        root = lib.get_highest_root(objects=instance[:])\n        if not root:\n            instance_node = instance.data[\"transientData\"][\"instance_node\"]\n            raise KnownPublishError(\n                f\"No root object found in instance: {instance_node.name}\"\n            )\n        self.log.debug(f\"Exporting using active root: {root.name}\")\n\n        context = plugin.create_blender_context(\n            active=root, selected=selected)\n\n        attribute_values = self.get_attr_values_from_data(instance.data)\n        convert_orientation = attribute_values.get(\n            \"convert_orientation\",\n            self.convert_orientation\n        )\n        kwargs = {\n            \"convert_orientation\": convert_orientation,\n            \"export_global_forward_selection\": attribute_values.get(\"forward_axis\", \"Z\"),\n            \"export_global_up_selection\": attribute_values.get(\"up_axis\", \"Y\"),\n        }\n\n        blender_version = lib.get_blender_version()\n        if blender_version &lt; (4, 2, 1):\n            kwargs = {}\n            if convert_orientation:\n                self.log.warning(\n                    \"Convert orientation was enabled for USD export but is not \"\n                    \"supported in Blender &lt; \\\"4.2.1\\\". Please update to at least Blender \"\n                    \"4.2.1 to support it.\"\n                )\n\n        # See: https://docs.blender.org/api/current/bpy.ops.wm.html#bpy.ops.wm.usd_export  # noqa\n        if blender_version &gt;= (5, 0, 0):\n            kwargs[\"export_textures_mode\"] = \"KEEP\"\n        else:\n            kwargs[\"export_textures\"] = False\n\n        # Export USD\n        with bpy.context.temp_override(**context):\n            bpy.ops.wm.usd_export(\n                # Override the `/root` default value. If left as an empty \n                # string, Blender will use the top-level object as the root prim.\n                filepath=filepath,\n                root_prim_path=\"\",  \n                selected_objects_only=True,\n                relative_paths=False,\n                export_animation=False,\n                export_hair=False,\n                export_uvmaps=True,\n                # TODO: add for new version of Blender (4+?)\n                # export_mesh_colors=True,\n                export_normals=True,\n                export_materials=True,\n                use_instancing=True,\n                # Convert Orientation\n                **kwargs\n            )\n\n        plugin.deselect_all()\n\n        # Add representation\n        representation = {\n            'name': 'usd',\n            'ext': 'usd',\n            'files': filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data.setdefault(\"representations\", []).append(representation)\n        self.log.debug(\"Extracted instance '%s' to: %s\",\n                       instance.name, representation)\n\n    @classmethod\n    def get_attr_defs_for_instance(cls, create_context, instance):\n        # Filtering of instance, if needed, can be customized\n        if not cls.instance_matches_plugin_families(instance):\n            return []\n\n        # Attributes logic\n        publish_attributes = cls.get_attr_values_from_data_for_plugin(\n            cls, instance\n        )\n\n        visible = publish_attributes.get(\"convert_orientation\", cls.convert_orientation)\n\n        orientation_axes = {\n            \"X\": \"X\",\n            \"Y\": \"Y\",  \n            \"Z\": \"Z\",\n            \"NEGATIVE_X\": \"-X\",\n            \"NEGATIVE_Y\": \"-Y\",\n            \"NEGATIVE_Z\": \"-Z\",\n        }\n\n        return [\n            BoolDef(\"convert_orientation\",\n                    label=\"Convert Orientation\",\n                    tooltip=\"Convert orientation axis to a different\"\n                    \" convention to match other applications.\",\n                    default=cls.convert_orientation),\n            EnumDef(\"forward_axis\",\n                    label=\"Forward Axis\",\n                    items=orientation_axes,\n                    default=\"Z\",\n                    visible=visible),\n            EnumDef(\"up_axis\",\n                    label=\"Up Axis\",\n                    items=orientation_axes,\n                    default=\"Y\",\n                    visible=visible)\n        ]\n\n    @classmethod\n    def register_create_context_callbacks(cls, create_context):\n        create_context.add_value_changed_callback(cls.on_values_changed)\n\n    @classmethod\n    def on_values_changed(cls, event):\n        \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n        # Update attributes if any of the following plug-in attributes\n        # change:\n        keys = [\"convert_orientation\"]\n\n        for instance_change in event[\"changes\"]:\n            instance = instance_change[\"instance\"]\n            if not cls.instance_matches_plugin_families(instance):\n                continue\n            value_changes = instance_change[\"changes\"]\n            plugin_attribute_changes = cls.get_attr_values_from_data_for_plugin(\n                cls, value_changes\n            )\n\n            if not any(key in plugin_attribute_changes for key in keys):\n                continue\n\n            # Update the attribute definitions\n            new_attrs = cls.get_attr_defs_for_instance(\n                event[\"create_context\"], instance\n            )\n            instance.set_publish_plugin_attr_defs(cls.__name__, new_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/extract_usd.html#client.ayon_blender.plugins.publish.extract_usd.ExtractUSD.on_values_changed","title":"<code>on_values_changed(event)</code>  <code>classmethod</code>","text":"<p>Update instance attribute definitions on attribute changes.</p> Source code in <code>client/ayon_blender/plugins/publish/extract_usd.py</code> <pre><code>@classmethod\ndef on_values_changed(cls, event):\n    \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n    # Update attributes if any of the following plug-in attributes\n    # change:\n    keys = [\"convert_orientation\"]\n\n    for instance_change in event[\"changes\"]:\n        instance = instance_change[\"instance\"]\n        if not cls.instance_matches_plugin_families(instance):\n            continue\n        value_changes = instance_change[\"changes\"]\n        plugin_attribute_changes = cls.get_attr_values_from_data_for_plugin(\n            cls, value_changes\n        )\n\n        if not any(key in plugin_attribute_changes for key in keys):\n            continue\n\n        # Update the attribute definitions\n        new_attrs = cls.get_attr_defs_for_instance(\n            event[\"create_context\"], instance\n        )\n        instance.set_publish_plugin_attr_defs(cls.__name__, new_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/increment_workfile_version.html","title":"increment_workfile_version","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/increment_workfile_version.html#client.ayon_blender.plugins.publish.increment_workfile_version.IncrementWorkfileVersion","title":"<code>IncrementWorkfileVersion</code>","text":"<p>               Bases: <code>BlenderContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Increment current workfile version.</p> Source code in <code>client/ayon_blender/plugins/publish/increment_workfile_version.py</code> <pre><code>class IncrementWorkfileVersion(\n    plugin.BlenderContextPlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Increment current workfile version.\"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.9\n    label = \"Increment Workfile Version\"\n    optional = True\n    hosts = [\"blender\"]\n    families = [\"animation\", \"model\", \"rig\", \"action\", \"layout\", \"blendScene\",\n                \"pointcache\", \"render.farm\"]\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        assert all(result[\"success\"] for result in context.data[\"results\"]), (\n            \"Publishing not successful so version is not increased.\")\n\n        current_filepath: str = context.data[\"currentFile\"]\n        try:\n            from ayon_core.pipeline.workfile import save_next_version\n            from ayon_core.host.interfaces import SaveWorkfileOptionalData\n\n            current_filename = os.path.basename(current_filepath)\n            save_next_version(\n                description=(\n                    f\"Incremented by publishing from {current_filename}\"\n                ),\n                # Optimize the save by reducing needed queries for context\n                prepared_data=SaveWorkfileOptionalData(\n                    project_entity=context.data[\"projectEntity\"],\n                    project_settings=context.data[\"project_settings\"],\n                    anatomy=context.data[\"anatomy\"],\n                )\n            )\n        except ImportError:\n            # Backwards compatibility before ayon-core 1.5.0\n            self.log.debug(\n                \"Using legacy `version_up`. Update AYON core addon to \"\n                \"use newer `save_next_version` function.\"\n            )\n            new_filepath = version_up(current_filepath)\n            host: IWorkfileHost = registered_host()\n            host.save_workfile(new_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/integrate_animation.html","title":"integrate_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/integrate_animation.html#client.ayon_blender.plugins.publish.integrate_animation.IntegrateAnimation","title":"<code>IntegrateAnimation</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Generate a JSON file for animation.</p> Source code in <code>client/ayon_blender/plugins/publish/integrate_animation.py</code> <pre><code>class IntegrateAnimation(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Generate a JSON file for animation.\"\"\"\n\n    label = \"Integrate Animation\"\n    order = pyblish.api.IntegratorOrder + 0.1\n    optional = True\n    hosts = [\"blender\"]\n    families = [\"setdress\"]\n\n    def process(self, instance):\n        self.log.debug(\"Integrate Animation\")\n\n        representation = instance.data.get('representations')[0]\n        json_path = representation.get('publishedFiles')[0]\n\n        with open(json_path, \"r\") as file:\n            data = json.load(file)\n\n        # Update the json file for the setdress to add the published\n        # representations of the animations\n        for json_dict in data:\n            json_product_name = json_dict[\"productName\"]\n            i = None\n            for elem in instance.context:\n                if elem.data[\"productName\"] == json_product_name:\n                    i = elem\n                    break\n            if not i:\n                continue\n            rep = None\n            pub_repr = i.data[\"published_representations\"]\n            for elem in pub_repr:\n                if pub_repr[elem][\"representation\"][\"name\"] == \"fbx\":\n                    rep = pub_repr[elem]\n                    break\n            if not rep:\n                continue\n            obj_id = rep[\"representation\"][\"id\"]\n\n            if obj_id:\n                json_dict[\"representation_id\"] = str(obj_id)\n\n        with open(json_path, \"w\") as file:\n            json.dump(data, fp=file, indent=2)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/save_scene.html#client.ayon_blender.plugins.publish.save_scene.SaveCurrentSceneBlender","title":"<code>SaveCurrentSceneBlender</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save current scene.</p> <p>Always ensure the current scene is saved before we continue extracting, so that our scene state is reproducable and consistent.</p> Source code in <code>client/ayon_blender/plugins/publish/save_scene.py</code> <pre><code>class SaveCurrentSceneBlender(pyblish.api.ContextPlugin):\n    \"\"\"Save current scene.\n\n    Always ensure the current scene is saved before we continue extracting,\n    so that our scene state is reproducable and consistent.\n    \"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"blender\"]\n\n    def process(self, context):\n        host = registered_host()\n\n        # If file has no modifications, skip forcing a file save\n        # TODO: Making changes to the scene through Python does not mark the\n        #  scene as modified, so we cannot rely on this.\n        # if not host.workfile_has_unsaved_changes():\n        #     self.log.debug(\"Skipping file save as there \"\n        #                    \"are no unsaved changes..\")\n        #     return\n\n        # Filename must not have changed since collecting\n        current_file = host.get_current_workfile()\n        if context.data[\"currentFile\"] != current_file:\n            raise KnownPublishError(\n                \"Collected filename mismatches from current scene name.\"\n            )\n\n        self.log.debug(f\"Saving current file: {current_file}\")\n        host.save_workfile()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_absolute_external_data_paths.html","title":"validate_absolute_external_data_paths","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_absolute_external_data_paths.html#client.ayon_blender.plugins.publish.validate_absolute_external_data_paths.ValidateAbsoluteDataBlockPaths","title":"<code>ValidateAbsoluteDataBlockPaths</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates Absolute Data Block Paths</p> <p>This validator checks if all external data paths are absolute to ensure the links would not be broken when publishing</p> Source code in <code>client/ayon_blender/plugins/publish/validate_absolute_external_data_paths.py</code> <pre><code>class ValidateAbsoluteDataBlockPaths(pyblish.api.ContextPlugin,\n                                     OptionalPyblishPluginMixin):\n    \"\"\"Validates Absolute Data Block Paths\n\n    This validator checks if all external data paths are absolute\n    to ensure the links would not be broken when publishing\n    \"\"\"\n\n    label = \"Validate Absolute Data Block Paths\"\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"workfile\"]\n    optional = True\n    actions = [RepairContextAction]\n\n    @classmethod\n    def get_invalid(cls, context):\n        invalid = []\n        object_type = type(bpy.data.objects)\n        for attr in dir(bpy.data):\n            collections = getattr(bpy.data, attr)\n            if not isinstance(collections, object_type):\n                continue\n            for data_block in collections:\n                if not hasattr(data_block, \"filepath\"):\n                    continue\n                if not data_block.filepath:\n                    continue\n                if data_block.filepath == bpy.path.abspath(data_block.filepath):\n                    continue\n\n                cls.log.error(f\"Data block filepath {data_block.filepath} \"\n                              \"is not absolute path\")\n                invalid.append(data_block.filepath)\n        return invalid\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            self.log.debug(\"Skipping Validate Absolute Data Block Paths...\")\n            return\n        invalid = self.get_invalid(context)\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid Data block filepaths\",\n                title=\"Relative Data block filepaths\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_description(cls):\n        return inspect.cleandoc(\"\"\"\n            ### Data block filepaths are invalid\n            Data block filepaths must be absolute paths to avoid issues during relocation\n            of the published workfile into the publish folder.\n\n            #### How to repair?\n\n            Using the Repair action will turn all datablock filepaths in your scene into\n            absolute filepaths.\n\n        \"\"\")\n\n    @classmethod\n    def repair(cls, context):\n        return bpy.ops.file.make_paths_absolute()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_camera_zero_keyframe.html","title":"validate_camera_zero_keyframe","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_camera_zero_keyframe.html#client.ayon_blender.plugins.publish.validate_camera_zero_keyframe.ValidateCameraZeroKeyframe","title":"<code>ValidateCameraZeroKeyframe</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Camera must have a keyframe at frame 0.</p> <p>Unreal shifts the first keyframe to frame 0. Forcing the camera to have a keyframe at frame 0 will ensure that the animation will be the same in Unreal and Blender.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_camera_zero_keyframe.py</code> <pre><code>class ValidateCameraZeroKeyframe(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Camera must have a keyframe at frame 0.\n\n    Unreal shifts the first keyframe to frame 0. Forcing the camera to have\n    a keyframe at frame 0 will ensure that the animation will be the same\n    in Unreal and Blender.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"camera\"]\n    label = \"Zero Keyframe\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == \"CAMERA\":\n                if obj.animation_data and obj.animation_data.action:\n                    action = obj.animation_data.action\n                    frames_set = set()\n                    for fcu in action.fcurves:\n                        for kp in fcu.keyframe_points:\n                            frames_set.add(kp.co[0])\n                    frames = list(frames_set)\n                    frames.sort()\n                    if frames[0] != 0.0:\n                        invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Camera must have a keyframe at frame 0: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_file_saved.html","title":"validate_file_saved","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_file_saved.html#client.ayon_blender.plugins.publish.validate_file_saved.SaveWorkfileAction","title":"<code>SaveWorkfileAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Save Workfile.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_file_saved.py</code> <pre><code>class SaveWorkfileAction(pyblish.api.Action):\n    \"\"\"Save Workfile.\"\"\"\n    label = \"Save Workfile\"\n    on = \"failed\"\n    icon = \"save\"\n\n    def process(self, context, plugin):\n        bpy.ops.wm.ayon_workfiles()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_file_saved.html#client.ayon_blender.plugins.publish.validate_file_saved.ValidateFileSaved","title":"<code>ValidateFileSaved</code>","text":"<p>               Bases: <code>BlenderContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the workfile has been saved.</p> <p>If ayon-core version is &gt;=1.4.1, this validation will be ignored due to an equivalent validation implementation in ayon-core.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_file_saved.py</code> <pre><code>class ValidateFileSaved(\n    plugin.BlenderContextPlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validate that the workfile has been saved.\n\n    If ayon-core version is &gt;=1.4.1, this validation will be ignored due to\n    an equivalent validation implementation in ayon-core.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.01\n    hosts = [\"blender\"]\n    label = \"Validate File Saved (Legacy)\"\n    optional = False\n    actions = [SaveWorkfileAction]\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        if context.data.get(\"currentFile\"):\n            # File has been saved at least once and has a filename\n            return\n\n        # We only invalidate here if an older AYON core version is used.\n        ayon_core_version = get_ayon_core_version()\n        if ayon_core_version is None:\n            self.log.warning(\n                \"Unable to parse ayon-core version. Skipping validation.\"\n            )\n            return\n\n        # Check if ayon-core version is &gt;=1.4.1, if so this validation is\n        # superseded by ValidateCurrentSaveFile in ayon-core.\n        if ayon_core_version &gt; semver.VersionInfo(1, 4, 0):\n            self.log.debug(\n                \"Skipping workfile saved validation in favor of equivalent\"\n                f\"validation in ayon-core {ayon_core_version}\"\n            )\n            return\n\n        if not context.data[\"currentFile\"]:\n            # File has not been saved at all and has no filename\n            raise PublishValidationError(\n                \"Current workfile has not been saved yet.\\n\"\n                \"Save the workfile before continuing.\",\n                title=\"Validate File Saved\",\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_frame_range.html","title":"validate_frame_range","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_frame_range.html#client.ayon_blender.plugins.publish.validate_frame_range.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the frame ranges.</p> <p>This is an optional validator checking if the frame range on instance matches the frame range specified for the folder.</p> <p>It also validates render frame ranges of render layers.</p> <p>Repair action will change everything to match the folder frame range.</p> <p>This can be turned off by the artist to allow custom ranges.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_frame_range.py</code> <pre><code>class ValidateFrameRange(pyblish.api.InstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validates the frame ranges.\n\n    This is an optional validator checking if the frame range on instance\n    matches the frame range specified for the folder.\n\n    It also validates render frame ranges of render layers.\n\n    Repair action will change everything to match the folder frame range.\n\n    This can be turned off by the artist to allow custom ranges.\n    \"\"\"\n\n    label = \"Validate Frame Range\"\n    order = ValidateContentsOrder\n    families = [\"animation\", \"camera\", \"pointcache\", \"render\", \"review\"]\n    hosts = [\"blender\"]\n    optional = True\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate Frame Range...\")\n            return\n\n        frame_range = self.get_expected_frame_range(instance)\n        inst_frame_start = instance.data[\"frameStart\"]\n        inst_frame_end = instance.data[\"frameEnd\"]\n\n        if inst_frame_start is None or inst_frame_end is None:\n            raise KnownPublishError(\n                \"Missing frame start and frame end on \"\n                \"instance to validate.\"\n            )\n        frame_start = frame_range[\"frameStart\"]\n        frame_end = frame_range[\"frameEnd\"]\n        errors = []\n        if frame_start != inst_frame_start:\n            errors.append(\n                f\"Start frame ({inst_frame_start}) on instance does not match \"\n                f\"with the start frame ({frame_start}) set on the task \"\n                \"attributes.\")\n        if frame_end != inst_frame_end:\n            errors.append(\n                f\"End frame ({inst_frame_end}) on instance does not match \"\n                f\"with the end frame ({frame_end}) \"\n                \"from the task attributes.\")\n\n        if errors:\n            bullet_point_errors = \"\\n\".join(\n                \"- {}\".format(error) for error in errors\n            )\n            report = (\n                \"Frame range settings are incorrect.\\n\\n\"\n                f\"{bullet_point_errors}\\n\\n\"\n                \"You can use repair action to fix it.\"\n            )\n            raise PublishValidationError(report, title=\"Frame Range incorrect\")\n\n    @classmethod\n    def get_expected_frame_range(\n        cls, instance: pyblish.api.Instance\n    ) -&gt; Dict[str, int]:\n        \"\"\"Get required frame range\"\"\"\n        entity = instance.data[\"taskEntity\"]\n\n        # Task is not required for a publish instance, so we may need to\n        # validate against the folder entity\n        if not entity:\n            entity = instance.data[\"folderEntity\"]\n        return get_frame_range(entity)\n\n    @classmethod\n    def repair(cls, instance):\n        frame_range = cls.get_expected_frame_range(instance)\n\n        # Update the frame range attributes on the instance\n        create_context = instance.context.data[\"create_context\"]\n        create_instance = create_context.get_instance_by_id(\n            instance.data[\"instance_id\"]\n        )\n\n        creator_attributes = create_instance[\"creator_attributes\"]\n        creator_attributes[\"frameStart\"] = frame_range[\"frameStart\"]\n        creator_attributes[\"frameEnd\"] = frame_range[\"frameEnd\"]\n        create_context.save_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_frame_range.html#client.ayon_blender.plugins.publish.validate_frame_range.ValidateFrameRange.get_expected_frame_range","title":"<code>get_expected_frame_range(instance)</code>  <code>classmethod</code>","text":"<p>Get required frame range</p> Source code in <code>client/ayon_blender/plugins/publish/validate_frame_range.py</code> <pre><code>@classmethod\ndef get_expected_frame_range(\n    cls, instance: pyblish.api.Instance\n) -&gt; Dict[str, int]:\n    \"\"\"Get required frame range\"\"\"\n    entity = instance.data[\"taskEntity\"]\n\n    # Task is not required for a publish instance, so we may need to\n    # validate against the folder entity\n    if not entity:\n        entity = instance.data[\"folderEntity\"]\n    return get_frame_range(entity)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_instance_empty.html","title":"validate_instance_empty","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_instance_empty.html#client.ayon_blender.plugins.publish.validate_instance_empty.ValidateInstanceEmpty","title":"<code>ValidateInstanceEmpty</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Validator to verify that the instance is not empty</p> Source code in <code>client/ayon_blender/plugins/publish/validate_instance_empty.py</code> <pre><code>class ValidateInstanceEmpty(plugin.BlenderInstancePlugin):\n    \"\"\"Validator to verify that the instance is not empty\"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.01\n    hosts = [\"blender\"]\n    families = [\"model\", \"pointcache\", \"rig\", \"camera\" \"layout\", \"blendScene\"]\n    label = \"Validate Instance is not Empty\"\n    optional = False\n\n    def process(self, instance):\n        # Members are collected by `collect_instance` so we only need to check\n        # whether any member is included. The instance node will be included\n        # as a member as well, hence we will check for at least 2 members\n        if len(instance) &lt; 2:\n            raise PublishValidationError(f\"Instance {instance.name} is empty.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_has_uv.html","title":"validate_mesh_has_uv","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_has_uv.html#client.ayon_blender.plugins.publish.validate_mesh_has_uv.ValidateMeshHasUvs","title":"<code>ValidateMeshHasUvs</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the current mesh has UV's.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_mesh_has_uv.py</code> <pre><code>class ValidateMeshHasUvs(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Validate that the current mesh has UV's.\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Mesh Has UVs\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n    optional = True\n\n    @staticmethod\n    def has_uvs(obj: bpy.types.Object) -&gt; bool:\n        \"\"\"Check if an object has uv's.\"\"\"\n        if not obj.data.uv_layers:\n            return False\n        for uv_layer in obj.data.uv_layers:\n            for polygon in obj.data.polygons:\n                for loop_index in polygon.loop_indices:\n                    if (\n                        loop_index &gt;= len(uv_layer.data)\n                        or not uv_layer.data[loop_index].uv\n                    ):\n                        return False\n\n        return True\n\n    @classmethod\n    def get_invalid(cls, instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == 'MESH':\n                if obj.mode != \"OBJECT\":\n                    cls.log.warning(\n                        f\"Mesh object {obj.name} should be in 'OBJECT' mode\"\n                        \" to be properly checked.\"\n                    )\n                if not cls.has_uvs(obj):\n                    invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"Meshes found in instance without valid UV's: {invalid}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_has_uv.html#client.ayon_blender.plugins.publish.validate_mesh_has_uv.ValidateMeshHasUvs.has_uvs","title":"<code>has_uvs(obj)</code>  <code>staticmethod</code>","text":"<p>Check if an object has uv's.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_mesh_has_uv.py</code> <pre><code>@staticmethod\ndef has_uvs(obj: bpy.types.Object) -&gt; bool:\n    \"\"\"Check if an object has uv's.\"\"\"\n    if not obj.data.uv_layers:\n        return False\n    for uv_layer in obj.data.uv_layers:\n        for polygon in obj.data.polygons:\n            for loop_index in polygon.loop_indices:\n                if (\n                    loop_index &gt;= len(uv_layer.data)\n                    or not uv_layer.data[loop_index].uv\n                ):\n                    return False\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_no_negative_scale.html","title":"validate_mesh_no_negative_scale","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_mesh_no_negative_scale.html#client.ayon_blender.plugins.publish.validate_mesh_no_negative_scale.ValidateMeshNoNegativeScale","title":"<code>ValidateMeshNoNegativeScale</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure that meshes don't have a negative scale.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_mesh_no_negative_scale.py</code> <pre><code>class ValidateMeshNoNegativeScale(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Ensure that meshes don't have a negative scale.\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Mesh No Negative Scale\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.type == 'MESH':\n                if any(v &lt; 0 for v in obj.scale):\n                    invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Meshes found in instance with negative scale: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_model_uv_map1.html","title":"validate_model_uv_map1","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_model_uv_map1.html#client.ayon_blender.plugins.publish.validate_model_uv_map1.ValidateModelMeshUvMap1","title":"<code>ValidateModelMeshUvMap1</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate model mesh uvs are named <code>map1</code>.</p> <p>This is solely to get them to work nicely for the Maya pipeline.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_model_uv_map1.py</code> <pre><code>class ValidateModelMeshUvMap1(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Validate model mesh uvs are named `map1`.\n\n    This is solely to get them to work nicely for the Maya pipeline.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Mesh UVs named map1\"\n    actions = [ayon_blender.api.action.SelectInvalidAction,\n               RepairAction]\n    optional = True\n    enabled = False\n\n    @classmethod\n    def get_invalid(cls, instance) -&gt; List:\n\n        invalid = []\n        for obj in instance:\n            if obj.mode != \"OBJECT\":\n                cls.log.warning(\n                    f\"Mesh object {obj.name} should be in 'OBJECT' mode\"\n                    \" to be properly checked.\"\n                )\n\n            obj_data = obj.data\n            if isinstance(obj_data, bpy.types.Mesh):\n                mesh = obj_data\n\n                # Ignore mesh without UVs\n                if not mesh.uv_layers:\n                    continue\n\n                # If mesh has map1 all is ok\n                if mesh.uv_layers.get(\"map1\"):\n                    continue\n\n                cls.log.warning(\n                    f\"Mesh object {obj.name} should be in 'OBJECT' mode\"\n                    \" to be properly checked.\"\n                )\n                invalid.append(obj)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        for obj in cls.get_invalid(instance):\n            mesh = obj.data\n\n            # Rename the first UV set to map1\n            mesh.uv_layers[0].name = \"map1\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                f\"Meshes found in instance without valid UV's: {invalid}\",\n                description=self.get_description()\n            )\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"## Meshes must have map1 uv set\n\n            To accompany a better Maya-focused pipeline with Alembics it is\n            expected that a Mesh has a `map1` UV set. Blender defaults to\n            a UV set named `UVMap` and thus needs to be renamed.\n\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_action.html","title":"validate_no_action","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_action.html#client.ayon_blender.plugins.publish.validate_no_action.ValidateNoAction","title":"<code>ValidateNoAction</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Ensure that objects have action with animation data.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_no_action.py</code> <pre><code>class ValidateNoAction(plugin.BlenderInstancePlugin):\n    \"\"\"Ensure that objects have action with animation data.\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"action\"]\n    label = \"No Action\"\n    actions = [SelectInvalidAction, RepairAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n        for data in instance:\n            if not (\n                isinstance(data, bpy.types.Object) and data.type in\n                {'MESH', 'EMPTY', 'ARMATURE'}\n            ):\n                continue\n            # just in case the instance node contains either Armature or top empty\n            child = data.children[0] if data.children else data\n            if child and child.type == 'ARMATURE':\n                if not child.animation_data:\n                    cls.log.error(f\"No animation data: {child.name}\")\n                    invalid.append(child)\n                else:\n                    product_name = instance.data[\"productName\"]\n                    if not child.animation_data.action:\n                        cls.log.error(f\"No action data: {child.name}\")\n                        invalid.append(child)\n                    elif child.animation_data.action.name != product_name:\n                        cls.log.error(\n                            f\"Action name mismatch: {product_name} ({child.animation_data.action.name})\"\n                        )\n                        invalid.append(child)\n        return invalid\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                \"Objects found in instance which have\"\n                f\" no action: {names}\",\n                title=\"No Action found on Objects\",\n                description=self.get_description()\n            )\n\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### No Action found on Objects\n            Objects must contain any action data.\n            Please add the action to the objects before publishing.\n        \"\"\")\n\n    @classmethod\n    def repair(cls, instance):\n        product_name = instance.data[\"productName\"]\n        invalid_object = cls.get_invalid(instance)\n        for obj in invalid_object:\n            if not obj.animation_data:\n                obj.animation_data_create()\n            if not obj.animation_data.action:\n                action = bpy.data.actions.new(name=product_name)\n                obj.animation_data.action = action\n            else:\n                obj.animation_data.action.name = product_name\n        cls.log.info(\"Created action data for objects in instance.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_animation.html","title":"validate_no_animation","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_animation.html#client.ayon_blender.plugins.publish.validate_no_animation.ValidateNoAnimation","title":"<code>ValidateNoAnimation</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Ensure that meshes do not have animation data.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_no_animation.py</code> <pre><code>class ValidateNoAnimation(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Ensure that meshes do not have animation data.\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"blendScene\", \"model\", \"rig\"]\n    label = \"No Animation\"\n    optional = True\n    actions = [SelectInvalidAction, RepairAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object):\n                if obj.animation_data and obj.animation_data.action:\n                    invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate No Animation...\")\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                \"Objects found in instance which have\"\n                f\" animation data: {names}\",\n                title=\"Keyframes on Objects\",\n                description=self.get_description()\n            )\n\n    def get_description(self):\n        return inspect.cleandoc(\"\"\"\n            ### Keyframes on Objects\n\n            Objects must not contain any keyframe animation data.\n            Please remove all keyframes before publishing.\n        \"\"\")\n\n    @classmethod\n    def repair(cls, instance):\n        invalid_objects = cls.get_invalid(instance)\n        for obj in invalid_objects:\n            obj.animation_data.action = None\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_colons_in_name.html","title":"validate_no_colons_in_name","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_no_colons_in_name.html#client.ayon_blender.plugins.publish.validate_no_colons_in_name.ValidateNoColonsInName","title":"<code>ValidateNoColonsInName</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>There cannot be colons in names</p> <p>Object or bone names cannot include colons. Other software do not handle colons correctly.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_no_colons_in_name.py</code> <pre><code>class ValidateNoColonsInName(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"There cannot be colons in names\n\n    Object or bone names cannot include colons. Other software do not\n    handle colons correctly.\n\n    \"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\", \"rig\"]\n    label = \"No Colons in names\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if ':' in obj.name:\n                invalid.append(obj)\n            if isinstance(obj, bpy.types.Object) and obj.type == 'ARMATURE':\n                for bone in obj.data.bones:\n                    if ':' in bone.name:\n                        invalid.append(obj)\n                        break\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Objects found with colon in name: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_object_mode.html","title":"validate_object_mode","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_object_mode.html#client.ayon_blender.plugins.publish.validate_object_mode.ValidateObjectIsInObjectMode","title":"<code>ValidateObjectIsInObjectMode</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the objects in the instance are in Object Mode.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_object_mode.py</code> <pre><code>class ValidateObjectIsInObjectMode(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin,\n):\n    \"\"\"Validate that the objects in the instance are in Object Mode.\"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.01\n    hosts = [\"blender\"]\n    families = [\"model\", \"rig\", \"layout\"]\n    label = \"Validate Object Mode\"\n    actions = [ayon_blender.api.action.SelectInvalidAction]\n    optional = False\n\n    @staticmethod\n    def get_invalid(instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if isinstance(obj, bpy.types.Object) and obj.mode != \"OBJECT\":\n                invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                f\"Object found in instance is not in Object Mode: {names}\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_camera_is_set.html","title":"validate_render_camera_is_set","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_camera_is_set.html#client.ayon_blender.plugins.publish.validate_render_camera_is_set.ValidateRenderCameraIsSet","title":"<code>ValidateRenderCameraIsSet</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that there is a camera set as active for rendering.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_camera_is_set.py</code> <pre><code>class ValidateRenderCameraIsSet(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validate that there is a camera set as active for rendering.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"blender\"]\n    families = [\"render\"]\n    label = \"Validate Render Camera Is Set\"\n    optional = False\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if not bpy.context.scene.camera:\n            raise PublishValidationError(\"No camera is active for rendering.\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_existing_frames.html","title":"validate_render_existing_frames","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_existing_frames.html#client.ayon_blender.plugins.publish.validate_render_existing_frames.ValidateRenderLocalHasExistingFrames","title":"<code>ValidateRenderLocalHasExistingFrames</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code></p> <p>Validate all files for the representations exist on disk.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_existing_frames.py</code> <pre><code>class ValidateRenderLocalHasExistingFrames(plugin.BlenderInstancePlugin):\n    \"\"\"Validate all files for the representations exist on disk.\"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"render.local_no_render\"]\n    label = \"Validate Existing Frames\"\n\n    def process(self, instance):\n        missing_paths = []\n        for repre in instance.data.get(\"representations\", []):\n            files = repre.get(\"files\")\n            if isinstance(files, str):\n                files = [files]\n\n            staging_dir = repre[\"stagingDir\"]\n            for fname in files:\n                path = os.path.join(staging_dir, fname)\n                if not os.path.exists(path):\n                    missing_paths.append(path)\n\n        if missing_paths:\n            collections, remainder = clique.assemble(missing_paths)\n            for path in itertools.chain(collections, remainder):\n                self.log.warning(f\"Missing files: {path}\")\n\n            raise PublishValidationError(\n                title=\"Missing existing frames\",\n                message=(\n                    \"Render has missing files. Please make sure to render the \"\n                    \"missing frames or pick another render target.\"\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_inputs.html","title":"validate_render_inputs","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_inputs.html#client.ayon_blender.plugins.publish.validate_render_inputs.ValidateRenderCompositorNodeFileOutputConnected","title":"<code>ValidateRenderCompositorNodeFileOutputConnected</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the Compositor File Output Node has all its image slots connected to an input.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_inputs.py</code> <pre><code>class ValidateRenderCompositorNodeFileOutputConnected(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validate the Compositor File Output Node has all its image slots\n    connected to an input.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"blender\"]\n    families = [\"render\"]\n    label = \"Validate Render Inputs\"\n    # TODO: Not sure how to select a Compositor Node through Python API so\n    #       until then, we can't select the node via the UI.\n    # actions = [SelectInvalidAction]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n\n            node = invalid[0].node\n            node_name = node.name\n\n            labels = []\n            for socket in invalid:\n                label = socket.name\n                labels.append(label)\n\n            raise PublishValidationError(\n                f\"The Compositor File Output Node '{node_name}' has the \"\n                \"following unconnected image slots:\\n{}\".format(\n                    \"\\n\".join(f\"- {label}\" for label in labels)\n                ),\n                title=\"Unconnected image slots\",\n                description=self.get_description(),\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        output: bpy.types.CompositorNodeOutputFile = (\n            instance.data[\"transientData\"][\"instance_node\"]\n        )\n\n        # Check all the slots are connected\n        invalid = []\n        for input_ in output.inputs:\n            # Assume all `NodeSocketColor` entries have inputs.\n            # TODO: Validate only entries that relate to the `slots`, but how?\n            if isinstance(input_, bpy.types.NodeSocketColor):\n                if not input_.links:\n                    invalid.append(input_)\n\n        return invalid\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"### Unconnected image slots\n\n        The Compositor File Output Node has unconnected input image slots.\n        Make sure to connect each of the individual slots to an input, or\n        remove the irrelevant slots if they are not needed.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_output_paths.html","title":"validate_render_output_paths","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_output_paths.html#client.ayon_blender.plugins.publish.validate_render_output_paths.ValidateCompositorNodeFileOutputPaths","title":"<code>ValidateCompositorNodeFileOutputPaths</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate output render paths from the Compositor Node Output File.</p> <p>This validator checks that the render output paths set in the <code>CompositorNodeOutputFile</code> adhere to a few strict requirements: - The output base path must include the workfile name in the output path. - The output filename must end with <code>.{frame}.{ext}</code> where it is fine   if the path on the node is set as <code>filename.</code> because if frame number   and extension are missing Blender will automatically append them.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_output_paths.py</code> <pre><code>class ValidateCompositorNodeFileOutputPaths(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validate output render paths from the Compositor Node Output File.\n\n    This validator checks that the render output paths set in the\n    `CompositorNodeOutputFile` adhere to a few strict requirements:\n    - The output base path must include the workfile name in the output path.\n    - The output filename must end with `.{frame}.{ext}` where it is fine\n      if the path on the node is set as `filename.` because if frame number\n      and extension are missing Blender will automatically append them.\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"render\"]\n    hosts = [\"blender\"]\n    label = \"Validate Output Paths\"\n    optional_tooltip = (\n        \"Validate whether Compositor Node Output File nodes \"\n        \"have correct filepaths set.\"\n    )\n    optional = True\n    actions = [RepairAction]\n\n    # TODO: Fix validator - it should just validate against the pre-collected\n    #  expected output files instead so that we do not need to duplicate the\n    #  logic of exactly figuring out the output filepaths.\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid_error_message = self.get_invalid(instance)\n        if invalid_error_message:\n            raise PublishValidationError(\n                invalid_error_message,\n                title=\"Invalid compositor render outputs\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def get_invalid(cls, instance) -&gt; Optional[str]:\n\n        workfile_filepath: str = bpy.data.filepath\n        if not workfile_filepath:\n            cls.log.warning(\"No workfile scene filepath set. \"\n                            \"Please save the workfile.\")\n            return None\n\n        workfile_filename = os.path.basename(workfile_filepath)\n        workfile_filename_no_ext, _ext = os.path.splitext(workfile_filename)\n\n        # Get expected files per AOV\n        expected_files: dict[str, list[str]] = (\n            instance.data[\"expectedFiles\"][0]\n        )\n\n        # For each AOV output check the output filenames as they must end with\n        # `.{frame}.{ext}` where the frame is a number and ext is the extension\n        for _aov, output_files in expected_files.items():\n            first_file = output_files[0]\n\n            if workfile_filename_no_ext not in first_file:\n                return (\n                    \"Render output does not include workfile name: \"\n                    f\"{workfile_filename_no_ext}.\\n\\n\"\n                    \"Use Repair action to fix the render base filepath.\"\n                )\n\n            # Requirements below are only valid for Blender 4 and below\n            # because Blender 5+ does not have a decent place to put the\n            # frame indicator and extensions for non-multilayer outputs\n            if lib.get_blender_version() &gt;= (5, 0, 0):\n                continue\n\n            # Ensure filename ends with `.{frame}.{ext}` by checking whether\n            file_no_ext = os.path.splitext(first_file)[0]\n            if not file_no_ext[-1].isdigit():\n                cls.log.warning(\n                    f\"Output file '{first_file}' does not end with \"\n                    \"`.{frame}.{extension}`.\"\n                )\n                return (\n                    \"Output file does not contain a frame number before the \"\n                    \"extension.\"\n                )\n\n            # Before the digits there must be a dot `.`\n            file_no_frame = file_no_ext.rstrip(\"1234567890\")\n            if not file_no_frame.endswith(\".\"):\n                cls.log.warning(\n                    f\"Output file '{first_file}' does not end with \"\n                    \"`.{frame}.{extension}`.\"\n                )\n                return (\n                    \"Output file does not end with a dot separator before the \"\n                    \"frame number.\"\n                )\n\n        return None\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Update the render output path to include the scene name.\"\"\"\n        output_node: \"bpy.types.CompositorNodeOutputFile\" = (\n            instance.data[\"transientData\"][\"instance_node\"]\n        )\n        # See: https://developer.blender.org/docs/release_notes/5.0/python_api/#nodes  # noqa\n        if lib.get_blender_version() &gt;= (5, 0, 0):\n            cls._repair_blender_5(output_node)\n        else:\n            cls._repair_blender_4(output_node)\n\n    @classmethod\n    def _repair_blender_5(\n        cls,\n        output_node: \"bpy.types.CompositorNodeOutputFile\"\n    ):\n        # Ensure a directory is included that matches the current filename\n        blend_file: str = os.path.basename(bpy.data.filepath)\n        blend_file = os.path.splitext(blend_file)[0]\n        orig_output_path = output_node.directory\n        output_node_dir = os.path.dirname(orig_output_path)\n        new_output_dir = os.path.join(output_node_dir, blend_file)\n        output_node.directory = new_output_dir\n\n    @classmethod\n    def _repair_blender_4(\n        cls,\n        output_node: \"bpy.types.CompositorNodeOutputFile\"\n    ):\n        # Check whether CompositorNodeOutputFile is rendering to multilayer EXR\n        file_format: str = output_node.format.file_format\n        is_multilayer: bool = file_format == \"OPEN_EXR_MULTILAYER\"\n\n        filename = os.path.basename(bpy.data.filepath)\n        filename, ext = os.path.splitext(filename)\n        orig_output_path = output_node.base_path\n        if is_multilayer:\n            # If the output node is a multilayer EXR then the base path\n            # includes the render filename like `Main_beauty.####.exr`\n            # So we split that off, and assume that the parent folder to\n            # the filename is the workfile filename named folder.\n            render_folder, render_filename = os.path.split(orig_output_path)\n            output_node_dir = os.path.dirname(render_folder)\n            new_output_dir = os.path.join(output_node_dir,\n                                          filename,\n                                          render_filename)\n        else:\n            output_node_dir = os.path.dirname(orig_output_path)\n            new_output_dir = os.path.join(output_node_dir, filename)\n\n        output_node.base_path = new_output_dir\n\n        # Repair all output filenames to ensure they end with `.{frame}.{ext}`\n        base_path: str = output_node.base_path\n\n        if is_multilayer:\n            file_format = output_node.format.file_format\n            ext = render_lib.get_file_format_extension(file_format)\n            ext = f\".{ext}\"\n            output_node.base_path = fix_filename(base_path, extension=ext)\n        else:\n            for file_slot in output_node.file_slots:\n                if file_slot.use_node_format:\n                    file_format = output_node.format.file_format\n                else:\n                    file_format = file_slot.format.file_format\n\n                ext = render_lib.get_file_format_extension(file_format)\n                ext = f\".{ext}\"\n                file_slot.path = fix_filename(file_slot.path, extension=ext)\n\n    @staticmethod\n    def get_description():\n        doc = inspect.cleandoc(\"\"\"\n        ### Compositor Output Filepaths Invalid\n\n        The Output File node in the Compositor has invalid output paths.\n\n        The filepaths must:\n\n        - Include the workfile name in the output path, this is to ensure\n          unique render paths for each workfile version.\n        \"\"\")\n\n        if lib.get_blender_version() &lt; (5, 0, 0):\n            doc += \"\\n\" + inspect.cleandoc(\"\"\"\n            - End with `.####.{ext}`. It is allowed to specify no extension \n              and frame tokens at all. As such, `filename.` is valid, because \n              if frame number and extension are missing Blender will \n              automatically append them.\n            \"\"\")\n\n        return doc\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_output_paths.html#client.ayon_blender.plugins.publish.validate_render_output_paths.ValidateCompositorNodeFileOutputPaths.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Update the render output path to include the scene name.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_output_paths.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Update the render output path to include the scene name.\"\"\"\n    output_node: \"bpy.types.CompositorNodeOutputFile\" = (\n        instance.data[\"transientData\"][\"instance_node\"]\n    )\n    # See: https://developer.blender.org/docs/release_notes/5.0/python_api/#nodes  # noqa\n    if lib.get_blender_version() &gt;= (5, 0, 0):\n        cls._repair_blender_5(output_node)\n    else:\n        cls._repair_blender_4(output_node)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_output_paths.html#client.ayon_blender.plugins.publish.validate_render_output_paths.ValidateSceneRenderFilePath","title":"<code>ValidateSceneRenderFilePath</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Scene Render Output File Path is not empty.</p> <p>Validates <code>bpy.context.scene.render.filepath</code> is set to a valid directory.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_output_paths.py</code> <pre><code>class ValidateSceneRenderFilePath(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Validate Scene Render Output File Path is not empty.\n\n    Validates `bpy.context.scene.render.filepath` is set to a valid directory.\n    \"\"\"\n    order = ValidateContentsOrder\n    families = [\"render\"]\n    hosts = [\"blender\"]\n    label = \"Validate Scene Output\"\n    optional_tooltip = (\n        \"Validate whether the scene-wide render filepath is set as required.\"\n    )\n    optional = True\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        if not bpy.data.filepath:\n            # Blender workfile is not saved, so we can't validate the\n            # scene render filepath correctly.\n            self.log.warning(\n                \"Blender workfile is not saved. \"\n                \"Please save the workfile before publishing.\"\n            )\n            return\n\n        expected_render_path = self._get_expected_render_path(instance)\n        if (\n            Path(bpy.context.scene.render.filepath) !=\n            Path(expected_render_path)\n        ):\n            self.log.warning(\n                f\"Current scene output: {bpy.context.scene.render.filepath} \"\n            )\n            self.log.info(f\"Expected scene output: {expected_render_path}\")\n            raise PublishValidationError(\n                message=(\n                    \"Scene Render filepath not set correctly. \"\n                    \"Use Repair action to fix the render filepath.\"\n                ),\n                description=self.get_description(),\n                title=\"Invalid scene render filepath set\"\n            )\n\n        if not bpy.context.scene.render.use_overwrite:\n            raise PublishValidationError(\n                title=\"Scene render overwrite is disabled\",\n                message=\"Scene Render overwrite is disabled.\",\n                description=(\n                    \"### Scene Render Overwrite Disabled\\n\\n\"\n                    \"It's recommended to enable this so that requeue on farm \"\n                    \"will not skip rendering just because the file already \"\n                    \"exists. Use Repair action to enable overwrite.\"\n                )\n            )\n\n    @staticmethod\n    def _get_expected_render_path(instance: pyblish.api.Instance) -&gt; str:\n        \"\"\"Get the expected render path based on the current scene.\"\"\"\n        project_settings = instance.context.data[\"project_settings\"]\n        return render_lib.get_tmp_scene_render_output_path(project_settings)\n\n    @classmethod\n    def repair(cls, instance):\n        project_settings = instance.context.data[\"project_settings\"]\n        render_lib.set_tmp_scene_render_output_path(project_settings)\n\n        # Force enable overwrite so re-queue on the farm does not stop just\n        # because a file already exists.\n        bpy.context.scene.render.use_overwrite = True\n\n    @staticmethod\n    def get_description():\n        return inspect.cleandoc(\"\"\"\n        ### Scene render filepath invalid\n\n        The scene output filepath is set to incorrectly.\n\n        We are enforcing the scene output filepath to be set to a `tmp`\n        file inside the renders folder of the work directory. This is because\n        the scene render output is unused by AYON since we only manage the\n        Compositor's Output File node for render outputs. The scene wide render\n        outputs can't be disabled, so we set it to a temporary filepath.\n\n        The temporary filepath is unique per workfile version to avoid \n        conflicts of different workfile versions being rendered simultaneous \n        on the farm and resulting in write locks on the same file.\n        \"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_render_output_paths.html#client.ayon_blender.plugins.publish.validate_render_output_paths.fix_filename","title":"<code>fix_filename(path, extension=None)</code>","text":"<p>Ensure the filename ends with <code>.{frame}.{ext}</code>.</p> <p>It's also fine for the path to not specify frame number and extension, in which case Blender will automatically add it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fix_filename(\"folder/beauty\")\n'folder/beauty.'\n</code></pre> <pre><code>&gt;&gt;&gt; fix_filename(\"folder/beauty#.exr\")\n'folder/beauty.#.exr'\n</code></pre> <pre><code>&gt;&gt;&gt; fix_filename(\"test.exr\")\n'test.####.exr'\n</code></pre> <pre><code>&gt;&gt;&gt; fix_filename(\"test.\", extension=\".exr\")\n'test.'\n</code></pre> <pre><code>&gt;&gt;&gt; fix_filename(\"test.####.aov.exr\", extension=\".png\")\n'test.aov.####.png'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path to fix.</p> required <code>extension</code> <code>Optional[str]</code> <p>The file extension to use. If not provided, it will be inferred from the filename if it has an extension. If the <code>path</code> does not have an extension, the <code>extensions</code> argument will remain unused. The extension should start with a dot, e.g. <code>.exr</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fixed file path with the filename ending in <code>.{frame}.{ext}</code>.</p> Source code in <code>client/ayon_blender/plugins/publish/validate_render_output_paths.py</code> <pre><code>def fix_filename(path: str, extension: Optional[str] = None) -&gt; str:\n    \"\"\"Ensure the filename ends with `.{frame}.{ext}`.\n\n    It's also fine for the path to not specify frame number\n    and extension, in which case Blender will automatically add it.\n\n    Examples:\n        &gt;&gt;&gt; fix_filename(\"folder/beauty\")\n        'folder/beauty.'\n\n        &gt;&gt;&gt; fix_filename(\"folder/beauty#.exr\")\n        'folder/beauty.#.exr'\n\n        &gt;&gt;&gt; fix_filename(\"test.exr\")\n        'test.####.exr'\n\n        &gt;&gt;&gt; fix_filename(\"test.\", extension=\".exr\")\n        'test.'\n\n        &gt;&gt;&gt; fix_filename(\"test.####.aov.exr\", extension=\".png\")\n        'test.aov.####.png'\n\n    Arguments:\n        path (str): The file path to fix.\n        extension (Optional[str]): The file extension to use. If not provided,\n            it will be inferred from the filename if it has an extension.\n            If the `path` does not have an extension, the `extensions` argument\n            will remain unused. The extension should start with a dot, e.g.\n            `.exr`.\n\n    Returns:\n        str: The fixed file path with the filename ending in `.{frame}.{ext}`.\n\n    \"\"\"\n    folder, filename = os.path.split(path)\n\n    # Get characteristics of the current filename to determine what\n    # we want to preserve.\n    has_extension: bool = bool(re.search(r\".*\\.[A-Za-z]+$\", filename))\n    if extension is None and has_extension:\n        extension = os.path.splitext(filename)[-1]\n    has_frame_token: bool = \"#\" in filename\n    frame_padding: int = filename.count(\"#\") or 4\n\n    # Remove extension and frame tokens\n    if has_extension:\n        filename = os.path.splitext(filename)[0]\n    if has_frame_token:\n        # remove any dots with frame tokens to avoid e.g. `test.####.aov.exr`\n        # becoming `test..aov.exr`\n        filename = filename.replace(\".#\", \"\")\n        filename = filename.replace(\"#\", \"\")\n\n    # Remove any trailing dots or underscores\n    filename = filename.rstrip(\"._\")\n\n    filename += \".\"  # Ensure there's a dot before the frame number\n    if has_extension or has_frame_token:\n        filename += f\"{'#' * frame_padding}\"\n    if has_extension:\n        filename += extension\n\n    return os.path.join(folder, filename)\n</code></pre>"},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_transform_zero.html","title":"validate_transform_zero","text":""},{"location":"autoapi/client/ayon_blender/plugins/publish/validate_transform_zero.html#client.ayon_blender.plugins.publish.validate_transform_zero.ValidateTransformZero","title":"<code>ValidateTransformZero</code>","text":"<p>               Bases: <code>BlenderInstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Transforms can't have any values</p> Source code in <code>client/ayon_blender/plugins/publish/validate_transform_zero.py</code> <pre><code>class ValidateTransformZero(\n    plugin.BlenderInstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Transforms can't have any values\"\"\"\n\n    order = ValidateContentsOrder\n    hosts = [\"blender\"]\n    families = [\"model\"]\n    label = \"Transform Zero\"\n    actions = [ayon_blender.api.action.SelectInvalidAction,\n               RepairAction]\n\n    _identity = mathutils.Matrix()\n\n    @classmethod\n    def get_invalid(cls, instance) -&gt; List:\n        invalid = []\n        for obj in instance:\n            if (\n                isinstance(obj, bpy.types.Object)\n                and obj.matrix_basis != cls._identity\n            ):\n                invalid.append(obj)\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \", \".join(obj.name for obj in invalid)\n            raise PublishValidationError(\n                \"Objects found in instance which do not\"\n                f\" have transform set to zero: {names}\",\n                description=self.get_description()\n            )\n\n    @classmethod\n    def repair(cls, instance):\n\n        invalid = cls.get_invalid(instance)\n        if not invalid:\n            return\n\n        context = plugin.create_blender_context(\n            active=invalid[0], selected=invalid\n        )\n        with lib.maintained_selection():\n            with bpy.context.temp_override(**context):\n                plugin.deselect_all()\n                for obj in invalid:\n                    obj.select_set(True)\n\n                # TODO: Preferably this does allow custom pivot point locations\n                #  and if so, this should likely apply to the delta instead\n                #  using `bpy.ops.object.transforms_to_deltas(mode=\"ALL\")`\n                bpy.ops.object.transform_apply(location=True,\n                                               rotation=True,\n                                               scale=True)\n\n    def get_description(self):\n        return inspect.cleandoc(\n            \"\"\"## Transforms can't have any values.\n\n            The location, rotation and scale on the transform must be at\n            the default values. This also goes for the delta transforms.\n\n            To solve this issue, try freezing the transforms:\n            - `Object` &gt; `Apply` &gt; `All Transforms`\n\n            Using the Repair action directly will do the same.\n\n            So long as the transforms, rotation and scale values are zero,\n            you're all good.\n            \"\"\"\n        )\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/creators.html","title":"creators","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/loaders.html","title":"loaders","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/render_settings.html","title":"render_settings","text":"<p>Providing models and values for Blender Render Settings.</p>"},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.CustomPassesModel","title":"<code>CustomPassesModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Custom Passes</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>class CustomPassesModel(BaseSettingsModel):\n    \"\"\"Custom Passes\"\"\"\n    _layout = \"compact\"\n\n    attribute: str = SettingsField(\"\", title=\"Attribute name\")\n    value: str = SettingsField(\n        \"COLOR\",\n        title=\"Type\",\n        enum_resolver=custom_passes_types_enum\n    )\n</code></pre>"}]}